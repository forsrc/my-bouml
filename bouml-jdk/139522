format 222
"channels" // jdk1.8::java::nio::channels
  revision 3
  modified_by 2 "forsrc"
  // class settings
  
  classdiagramsettings member_max_width 0 end
  
  classcompositediagramsettings end
  
  usecasediagramsettings end
  
  sequencediagramsettings end
  
  collaborationdiagramsettings end
  
  objectdiagramsettings end
  
  objectcompositediagramsettings end
  
  componentdiagramsettings
   end
  
  deploymentdiagramsettings
   end
  
  statediagramsettings
   end
  
  activitydiagramsettings
   end
  
  java_dir "/Volumes/My/My/git/MyGit/my-bouml/jdk1.8/java/nio/channels/"
  java_package "java.nio.channels"
  classview 136834 "channels"
    
    classdiagramsettings member_max_width 0 end
    
    classcompositediagramsettings end
    
    collaborationdiagramsettings end
    
    objectdiagramsettings end
    
    objectcompositediagramsettings end
    
    sequencediagramsettings end
    
    statediagramsettings
     end
    
    
    activitydiagramsettings
     end
    class 210434 "SelectableChannel"
      abstract visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A channel that can be multiplexed via a {@link Selector}.

<p> In order to be used with a selector, an instance of this class must
first be <i>registered</i> via the {@link #register(Selector,int,Object)
register} method.  This method returns a new {@link SelectionKey} object
that represents the channel's registration with the selector.

<p> Once registered with a selector, a channel remains registered until it
is <i>deregistered</i>.  This involves deallocating whatever resources were
allocated to the channel by the selector.

<p> A channel cannot be deregistered directly; instead, the key representing
its registration must be <i>cancelled</i>.  Cancelling a key requests that
the channel be deregistered during the selector's next selection operation.
A key may be cancelled explicitly by invoking its {@link
SelectionKey#cancel() cancel} method.  All of a channel's keys are cancelled
implicitly when the channel is closed, whether by invoking its {@link
Channel#close close} method or by interrupting a thread blocked in an I/O
operation upon the channel.

<p> If the selector itself is closed then the channel will be deregistered,
and the key representing its registration will be invalidated, without
further delay.

<p> A channel may be registered at most once with any particular selector.

<p> Whether or not a channel is registered with one or more selectors may be
determined by invoking the {@link #isRegistered isRegistered} method.

<p> Selectable channels are safe for use by multiple concurrent
threads. </p>


<a name=\"bm\"></a>
<h2>Blocking mode</h2>

A selectable channel is either in <i>blocking</i> mode or in
<i>non-blocking</i> mode.  In blocking mode, every I/O operation invoked
upon the channel will block until it completes.  In non-blocking mode an I/O
operation will never block and may transfer fewer bytes than were requested
or possibly no bytes at all.  The blocking mode of a selectable channel may
be determined by invoking its {@link #isBlocking isBlocking} method.

<p> Newly-created selectable channels are always in blocking mode.
Non-blocking mode is most useful in conjunction with selector-based
multiplexing.  A channel must be placed into non-blocking mode before being
registered with a selector, and may not be returned to blocking mode until
it has been deregistered.


@author Mark Reinhold
@author JSR-51 Expert Group
@since 1.4

@see SelectionKey
@see Selector
"
      classrelation 3294466 // <generalisation>
	relation 3294466 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3294466 // <generalisation>
	  b parent class_ref 987138 // AbstractInterruptibleChannel
      end

      classrelation 3294594 // <realization>
	relation 3294594 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3294594 // <realization>
	  b parent class_ref 940034 // Channel
      end

      operation 7780994 "SelectableChannel"
	protected explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Initializes a new instance of this class.
"
      end

      operation 7781122 "provider"
	abstract public return_type class_ref 988034 // SelectorProvider
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the provider that created this channel.

@return  The provider that created this channel
"
      end

      operation 7781250 "validOps"
	abstract public explicit_return_type "int"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an <a href=\"SelectionKey.html#opsets\">operation set</a>
identifying this channel's supported operations.  The bits that are set
in this integer value denote exactly the operations that are valid for
this channel.  This method always returns the same value for a given
concrete channel class.

@return  The valid-operation set
"
      end

      operation 7781378 "isRegistered"
	abstract public explicit_return_type "boolean"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Internal state:
   keySet, may be empty but is never null, typ. a tiny array
   boolean isRegistered, protected by key set
   regLock, lock object to prevent duplicate registrations
   boolean isBlocking, protected by regLock

Tells whether or not this channel is currently registered with any
selectors.  A newly-created channel is not registered.

<p> Due to the inherent delay between key cancellation and channel
deregistration, a channel may remain registered for some time after all
of its keys have been cancelled.  A channel may also remain registered
for some time after it is closed.  </p>

@return <tt>true</tt> if, and only if, this channel is registered
"
      end

      operation 7781506 "keyFor"
	abstract public return_type class_ref 210562 // SelectionKey
	nparams 1
	  param inout name "sel" type class_ref 275586 // Selector
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " sync(keySet) { return isRegistered; }

Retrieves the key representing the channel's registration with the given
selector.

@param   sel
         The selector

@return  The key returned when this channel was last registered with the
         given selector, or <tt>null</tt> if this channel is not
         currently registered with that selector
"
      end

      operation 7781634 "register"
	abstract public return_type class_ref 210562 // SelectionKey
	nparams 3
	  param inout name "sel" type class_ref 275586 // Selector
	  param in name "ops" explicit_type "int"
	  param inout name "att" type class_ref 129538 // Object
	nexceptions 1
	  exception class_ref 985474 // ClosedChannelException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " sync(keySet) { return findKey(sel); }

Registers this channel with the given selector, returning a selection
key.

<p> If this channel is currently registered with the given selector then
the selection key representing that registration is returned.  The key's
interest set will have been changed to <tt>ops</tt>, as if by invoking
the {@link SelectionKey#interestOps(int) interestOps(int)} method.  If
the <tt>att</tt> argument is not <tt>null</tt> then the key's attachment
will have been set to that value.  A {@link CancelledKeyException} will
be thrown if the key has already been cancelled.

<p> Otherwise this channel has not yet been registered with the given
selector, so it is registered and the resulting new key is returned.
The key's initial interest set will be <tt>ops</tt> and its attachment
will be <tt>att</tt>.

<p> This method may be invoked at any time.  If this method is invoked
while another invocation of this method or of the {@link
#configureBlocking(boolean) configureBlocking} method is in progress
then it will first block until the other operation is complete.  This
method will then synchronize on the selector's key set and therefore may
block if invoked concurrently with another registration or selection
operation involving the same selector. </p>

<p> If this channel is closed while this operation is in progress then
the key returned by this method will have been cancelled and will
therefore be invalid. </p>

@param  sel
        The selector with which this channel is to be registered

@param  ops
        The interest set for the resulting key

@param  att
        The attachment for the resulting key; may be <tt>null</tt>

@throws  ClosedChannelException
         If this channel is closed

@throws  ClosedSelectorException
         If the selector is closed

@throws  IllegalBlockingModeException
         If this channel is in blocking mode

@throws  IllegalSelectorException
         If this channel was not created by the same provider
         as the given selector

@throws  CancelledKeyException
         If this channel is currently registered with the given selector
         but the corresponding key has already been cancelled

@throws  IllegalArgumentException
         If a bit in the <tt>ops</tt> set does not correspond to an
         operation that is supported by this channel, that is, if
         {@code set & ~validOps() != 0}

@return  A key representing the registration of this channel with
         the given selector
"
      end

      operation 7781762 "register"
	public return_type class_ref 210562 // SelectionKey
	nparams 2
	  param inout name "sel" type class_ref 275586 // Selector
	  param in name "ops" explicit_type "int"
	nexceptions 1
	  exception class_ref 985474 // ClosedChannelException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " sync(regLock) {
   sync(keySet) { look for selector }
   if (channel found) { set interest ops -- may block in selector;
                        return key; }
   create new key -- may block somewhere in selector;
   sync(keySet) { add key; }
   attach(attachment);
   return key;
 }

Registers this channel with the given selector, returning a selection
key.

<p> An invocation of this convenience method of the form

<blockquote><tt>sc.register(sel, ops)</tt></blockquote>

behaves in exactly the same way as the invocation

<blockquote><tt>sc.{@link
#register(java.nio.channels.Selector,int,java.lang.Object)
register}(sel, ops, null)</tt></blockquote>

@param  sel
        The selector with which this channel is to be registered

@param  ops
        The interest set for the resulting key

@throws  ClosedChannelException
         If this channel is closed

@throws  ClosedSelectorException
         If the selector is closed

@throws  IllegalBlockingModeException
         If this channel is in blocking mode

@throws  IllegalSelectorException
         If this channel was not created by the same provider
         as the given selector

@throws  CancelledKeyException
         If this channel is currently registered with the given selector
         but the corresponding key has already been cancelled

@throws  IllegalArgumentException
         If a bit in <tt>ops</tt> does not correspond to an operation
         that is supported by this channel, that is, if {@code set &
         ~validOps() != 0}

@return  A key representing the registration of this channel with
         the given selector
"
      end

      operation 7781890 "configureBlocking"
	abstract public return_type class_ref 210434 // SelectableChannel
	nparams 1
	  param inout name "block" explicit_type "boolean"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Adjusts this channel's blocking mode.

<p> If this channel is registered with one or more selectors then an
attempt to place it into blocking mode will cause an {@link
IllegalBlockingModeException} to be thrown.

<p> This method may be invoked at any time.  The new blocking mode will
only affect I/O operations that are initiated after this method returns.
For some implementations this may require blocking until all pending I/O
operations are complete.

<p> If this method is invoked while another invocation of this method or
of the {@link #register(Selector, int) register} method is in progress
then it will first block until the other operation is complete. </p>

@param  block  If <tt>true</tt> then this channel will be placed in
               blocking mode; if <tt>false</tt> then it will be placed
               non-blocking mode

@return  This selectable channel

@throws  ClosedChannelException
         If this channel is closed

@throws  IllegalBlockingModeException
         If <tt>block</tt> is <tt>true</tt> and this channel is
         registered with one or more selectors

@throws IOException
        If an I/O error occurs
"
      end

      operation 7782018 "isBlocking"
	abstract public explicit_return_type "boolean"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " sync(regLock) {
   sync(keySet) { throw IBME if block && isRegistered; }
   change mode;
 }

Tells whether or not every I/O operation on this channel will block
until it completes.  A newly-created channel is always in blocking mode.

<p> If this channel is closed then the value returned by this method is
not specified. </p>

@return <tt>true</tt> if, and only if, this channel is in blocking mode
"
      end

      operation 7782146 "blockingLock"
	abstract public return_type class_ref 129538 // Object
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Retrieves the object upon which the {@link #configureBlocking
configureBlocking} and {@link #register register} methods synchronize.
This is often useful in the implementation of adaptors that require a
specific blocking mode to be maintained for a short period of time.

@return  The blocking-mode lock object
"
      end
    end

    class 210562 "SelectionKey"
      abstract visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A token representing the registration of a {@link SelectableChannel} with a
{@link Selector}.

<p> A selection key is created each time a channel is registered with a
selector.  A key remains valid until it is <i>cancelled</i> by invoking its
{@link #cancel cancel} method, by closing its channel, or by closing its
selector.  Cancelling a key does not immediately remove it from its
selector; it is instead added to the selector's <a
href=\"Selector.html#ks\"><i>cancelled-key set</i></a> for removal during the
next selection operation.  The validity of a key may be tested by invoking
its {@link #isValid isValid} method.

<a name=\"opsets\"></a>

<p> A selection key contains two <i>operation sets</i> represented as
integer values.  Each bit of an operation set denotes a category of
selectable operations that are supported by the key's channel.

<ul>

  <li><p> The <i>interest set</i> determines which operation categories will
  be tested for readiness the next time one of the selector's selection
  methods is invoked.  The interest set is initialized with the value given
  when the key is created; it may later be changed via the {@link
  #interestOps(int)} method. </p></li>

  <li><p> The <i>ready set</i> identifies the operation categories for which
  the key's channel has been detected to be ready by the key's selector.
  The ready set is initialized to zero when the key is created; it may later
  be updated by the selector during a selection operation, but it cannot be
  updated directly. </p></li>

</ul>

<p> That a selection key's ready set indicates that its channel is ready for
some operation category is a hint, but not a guarantee, that an operation in
such a category may be performed by a thread without causing the thread to
block.  A ready set is most likely to be accurate immediately after the
completion of a selection operation.  It is likely to be made inaccurate by
external events and by I/O operations that are invoked upon the
corresponding channel.

<p> This class defines all known operation-set bits, but precisely which
bits are supported by a given channel depends upon the type of the channel.
Each subclass of {@link SelectableChannel} defines an {@link
SelectableChannel#validOps() validOps()} method which returns a set
identifying just those operations that are supported by the channel.  An
attempt to set or test an operation-set bit that is not supported by a key's
channel will result in an appropriate run-time exception.

<p> It is often necessary to associate some application-specific data with a
selection key, for example an object that represents the state of a
higher-level protocol and handles readiness notifications in order to
implement that protocol.  Selection keys therefore support the
<i>attachment</i> of a single arbitrary object to a key.  An object can be
attached via the {@link #attach attach} method and then later retrieved via
the {@link #attachment() attachment} method.

<p> Selection keys are safe for use by multiple concurrent threads.  The
operations of reading and writing the interest set will, in general, be
synchronized with certain operations of the selector.  Exactly how this
synchronization is performed is implementation-dependent: In a naive
implementation, reading or writing the interest set may block indefinitely
if a selection operation is already in progress; in a high-performance
implementation, reading or writing the interest set may block briefly, if at
all.  In any case, a selection operation will always use the interest-set
value that was current at the moment that the operation began.  </p>


@author Mark Reinhold
@author JSR-51 Expert Group
@since 1.4

@see SelectableChannel
@see Selector
"
      operation 7796866 "SelectionKey"
	protected explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end

      operation 7796994 "channel"
	abstract public return_type class_ref 210434 // SelectableChannel
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " -- Channel and selector operations --

Returns the channel for which this key was created.  This method will
continue to return the channel even after the key is cancelled.

@return  This key's channel
"
      end

      operation 7797122 "selector"
	abstract public return_type class_ref 275586 // Selector
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the selector for which this key was created.  This method will
continue to return the selector even after the key is cancelled.

@return  This key's selector
"
      end

      operation 7797250 "isValid"
	abstract public explicit_return_type "boolean"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Tells whether or not this key is valid.

<p> A key is valid upon creation and remains so until it is cancelled,
its channel is closed, or its selector is closed.  </p>

@return  <tt>true</tt> if, and only if, this key is valid
"
      end

      operation 7797378 "cancel"
	abstract public explicit_return_type "void"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Requests that the registration of this key's channel with its selector
be cancelled.  Upon return the key will be invalid and will have been
added to its selector's cancelled-key set.  The key will be removed from
all of the selector's key sets during the next selection operation.

<p> If this key has already been cancelled then invoking this method has
no effect.  Once cancelled, a key remains forever invalid. </p>

<p> This method may be invoked at any time.  It synchronizes on the
selector's cancelled-key set, and therefore may block briefly if invoked
concurrently with a cancellation or selection operation involving the
same selector.  </p>
"
      end

      operation 7797506 "interestOps"
	abstract public explicit_return_type "int"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " -- Operation-set accessors --

Retrieves this key's interest set.

<p> It is guaranteed that the returned set will only contain operation
bits that are valid for this key's channel.

<p> This method may be invoked at any time.  Whether or not it blocks,
and for how long, is implementation-dependent.  </p>

@return  This key's interest set

@throws  CancelledKeyException
         If this key has been cancelled
"
      end

      operation 7797634 "interestOps"
	abstract public return_type class_ref 210562 // SelectionKey
	nparams 1
	  param in name "ops" explicit_type "int"
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sets this key's interest set to the given value.

<p> This method may be invoked at any time.  Whether or not it blocks,
and for how long, is implementation-dependent.  </p>

@param  ops  The new interest set

@return  This selection key

@throws  IllegalArgumentException
         If a bit in the set does not correspond to an operation that
         is supported by this key's channel, that is, if
         {@code (ops & ~channel().validOps()) != 0}

@throws  CancelledKeyException
         If this key has been cancelled
"
      end

      operation 7797762 "readyOps"
	abstract public explicit_return_type "int"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Retrieves this key's ready-operation set.

<p> It is guaranteed that the returned set will only contain operation
bits that are valid for this key's channel.  </p>

@return  This key's ready-operation set

@throws  CancelledKeyException
         If this key has been cancelled
"
      end

      attribute 1811970 "OP_READ"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1 << 0"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " -- Operation bits and bit-testing convenience methods --

Operation-set bit for read operations.

<p> Suppose that a selection key's interest set contains
<tt>OP_READ</tt> at the start of a <a
href=\"Selector.html#selop\">selection operation</a>.  If the selector
detects that the corresponding channel is ready for reading, has reached
end-of-stream, has been remotely shut down for further reading, or has
an error pending, then it will add <tt>OP_READ</tt> to the key's
ready-operation set and add the key to its selected-key&nbsp;set.  </p>

"
      end

      attribute 1812098 "OP_WRITE"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1 << 2"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "Operation-set bit for write operations.

<p> Suppose that a selection key's interest set contains
<tt>OP_WRITE</tt> at the start of a <a
href=\"Selector.html#selop\">selection operation</a>.  If the selector
detects that the corresponding channel is ready for writing, has been
remotely shut down for further writing, or has an error pending, then it
will add <tt>OP_WRITE</tt> to the key's ready set and add the key to its
selected-key&nbsp;set.  </p>

"
      end

      attribute 1812226 "OP_CONNECT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1 << 3"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "Operation-set bit for socket-connect operations.

<p> Suppose that a selection key's interest set contains
<tt>OP_CONNECT</tt> at the start of a <a
href=\"Selector.html#selop\">selection operation</a>.  If the selector
detects that the corresponding socket channel is ready to complete its
connection sequence, or has an error pending, then it will add
<tt>OP_CONNECT</tt> to the key's ready set and add the key to its
selected-key&nbsp;set.  </p>

"
      end

      attribute 1812354 "OP_ACCEPT"
	class_attribute const_attribute public explicit_type "int"
	init_value " 1 << 4"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "Operation-set bit for socket-accept operations.

<p> Suppose that a selection key's interest set contains
<tt>OP_ACCEPT</tt> at the start of a <a
href=\"Selector.html#selop\">selection operation</a>.  If the selector
detects that the corresponding server-socket channel is ready to accept
another connection, or has an error pending, then it will add
<tt>OP_ACCEPT</tt> to the key's ready set and add the key to its
selected-key&nbsp;set.  </p>

"
      end

      operation 7797890 "isReadable"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Tests whether this key's channel is ready for reading.

<p> An invocation of this method of the form <tt>k.isReadable()</tt>
behaves in exactly the same way as the expression

<blockquote><pre>{@code
k.readyOps() & OP_READ != 0
}</pre></blockquote>

<p> If this key's channel does not support read operations then this
method always returns <tt>false</tt>.  </p>

@return  <tt>true</tt> if, and only if,
{@code readyOps() & OP_READ} is nonzero

@throws  CancelledKeyException
         If this key has been cancelled
"
      end

      operation 7798018 "isWritable"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Tests whether this key's channel is ready for writing.

<p> An invocation of this method of the form <tt>k.isWritable()</tt>
behaves in exactly the same way as the expression

<blockquote><pre>{@code
k.readyOps() & OP_WRITE != 0
}</pre></blockquote>

<p> If this key's channel does not support write operations then this
method always returns <tt>false</tt>.  </p>

@return  <tt>true</tt> if, and only if,
         {@code readyOps() & OP_WRITE} is nonzero

@throws  CancelledKeyException
         If this key has been cancelled
"
      end

      operation 7798146 "isConnectable"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Tests whether this key's channel has either finished, or failed to
finish, its socket-connection operation.

<p> An invocation of this method of the form <tt>k.isConnectable()</tt>
behaves in exactly the same way as the expression

<blockquote><pre>{@code
k.readyOps() & OP_CONNECT != 0
}</pre></blockquote>

<p> If this key's channel does not support socket-connect operations
then this method always returns <tt>false</tt>.  </p>

@return  <tt>true</tt> if, and only if,
         {@code readyOps() & OP_CONNECT} is nonzero

@throws  CancelledKeyException
         If this key has been cancelled
"
      end

      operation 7798274 "isAcceptable"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Tests whether this key's channel is ready to accept a new socket
connection.

<p> An invocation of this method of the form <tt>k.isAcceptable()</tt>
behaves in exactly the same way as the expression

<blockquote><pre>{@code
k.readyOps() & OP_ACCEPT != 0
}</pre></blockquote>

<p> If this key's channel does not support socket-accept operations then
this method always returns <tt>false</tt>.  </p>

@return  <tt>true</tt> if, and only if,
         {@code readyOps() & OP_ACCEPT} is nonzero

@throws  CancelledKeyException
         If this key has been cancelled
"
      end

      classrelation 3300226 // attachment (<unidirectional association>)
	relation 3300226 --->
	  a role_name "attachment" init_value " null" volatile private
	    comment " -- Attachments --
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 3300226 // attachment (<unidirectional association>)
	  b parent class_ref 129538 // Object
      end

      classrelation 3300354 // attachmentUpdater (<unidirectional association>)
	relation 3300354 --->
	  a role_name "attachmentUpdater" init_value " AtomicReferenceFieldUpdater.newUpdater(
            SelectionKey.class, Object.class, \"attachment\"
        )" class_relation const_relation private
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<SelectionKey,Object> ${name}${value};
"
	    classrelation_ref 3300354 // attachmentUpdater (<unidirectional association>)
	  b parent class_ref 921474 // AtomicReferenceFieldUpdater
      end

      operation 7798402 "attach"
	public return_type class_ref 129538 // Object
	nparams 1
	  param inout name "ob" type class_ref 129538 // Object
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attaches the given object to this key.

<p> An attached object may later be retrieved via the {@link #attachment()
attachment} method.  Only one object may be attached at a time; invoking
this method causes any previous attachment to be discarded.  The current
attachment may be discarded by attaching <tt>null</tt>.  </p>

@param  ob
        The object to be attached; may be <tt>null</tt>

@return  The previously-attached object, if any,
         otherwise <tt>null</tt>
"
      end

      operation 7798530 "attachment"
	public return_type class_ref 129538 // Object
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Retrieves the current attachment.

@return  The object currently attached to this key,
         or <tt>null</tt> if there is no attachment
"
      end
    end

    class 211714 "ServerSocketChannel"
      abstract visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A selectable channel for stream-oriented listening sockets.

<p> A server-socket channel is created by invoking the {@link #open() open}
method of this class.  It is not possible to create a channel for an arbitrary,
pre-existing {@link ServerSocket}. A newly-created server-socket channel is
open but not yet bound.  An attempt to invoke the {@link #accept() accept}
method of an unbound server-socket channel will cause a {@link NotYetBoundException}
to be thrown. A server-socket channel can be bound by invoking one of the
{@link #bind(java.net.SocketAddress,int) bind} methods defined by this class.

<p> Socket options are configured using the {@link #setOption(SocketOption,Object)
setOption} method. Server-socket channels support the following options:
<blockquote>
<table border summary=\"Socket options\">
  <tr>
    <th>Option Name</th>
    <th>Description</th>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} </td>
    <td> The size of the socket receive buffer </td>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR} </td>
    <td> Re-use address </td>
  </tr>
</table>
</blockquote>
Additional (implementation specific) options may also be supported.

<p> Server-socket channels are safe for use by multiple concurrent threads.
</p>

@author Mark Reinhold
@author JSR-51 Expert Group
@since 1.4
"
      classrelation 3300610 // <generalisation>
	relation 3300610 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3300610 // <generalisation>
	  b parent class_ref 987906 // AbstractSelectableChannel
      end

      classrelation 3300738 // <realization>
	relation 3300738 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3300738 // <realization>
	  b parent class_ref 986114 // NetworkChannel
      end

      operation 7800066 "ServerSocketChannel"
	protected explicit_return_type ""
	nparams 1
	  param inout name "provider" type class_ref 988034 // SelectorProvider
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Initializes a new instance of this class.

@param  provider
        The provider that created this channel
"
      end

      operation 7800194 "open"
	class_operation public return_type class_ref 211714 // ServerSocketChannel
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Opens a server-socket channel.

<p> The new channel is created by invoking the {@link
java.nio.channels.spi.SelectorProvider#openServerSocketChannel
openServerSocketChannel} method of the system-wide default {@link
java.nio.channels.spi.SelectorProvider} object.

<p> The new channel's socket is initially unbound; it must be bound to a
specific address via one of its socket's {@link
java.net.ServerSocket#bind(SocketAddress) bind} methods before
connections can be accepted.  </p>

@return  A new socket channel

@throws  IOException
         If an I/O error occurs
"
      end

      operation 7800322 "validOps"
	public explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an operation set identifying this channel's supported
operations.

<p> Server-socket channels only support the accepting of new
connections, so this method returns {@link SelectionKey#OP_ACCEPT}.
</p>

@return  The valid-operation set
"
      end

      operation 7800450 "bind"
	public return_type class_ref 211714 // ServerSocketChannel
	nparams 1
	  param inout name "local" type class_ref 962178 // SocketAddress
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " -- ServerSocket-specific operations --

Binds the channel's socket to a local address and configures the socket
to listen for connections.

<p> An invocation of this method is equivalent to the following:
<blockquote><pre>
bind(local, 0);
</pre></blockquote>

@param   local
         The local address to bind the socket, or {@code null} to bind
         to an automatically assigned socket address

@return  This channel

@throws  AlreadyBoundException               {@inheritDoc}
@throws  UnsupportedAddressTypeException     {@inheritDoc}
@throws  ClosedChannelException              {@inheritDoc}
@throws  IOException                         {@inheritDoc}
@throws  SecurityException
         If a security manager has been installed and its {@link
         SecurityManager#checkListen checkListen} method denies the
         operation

@since 1.7
"
      end

      operation 7800578 "bind"
	abstract public return_type class_ref 211714 // ServerSocketChannel
	nparams 2
	  param inout name "local" type class_ref 962178 // SocketAddress
	  param in name "backlog" explicit_type "int"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Binds the channel's socket to a local address and configures the socket to
listen for connections.

<p> This method is used to establish an association between the socket and
a local address. Once an association is established then the socket remains
bound until the channel is closed.

<p> The {@code backlog} parameter is the maximum number of pending
connections on the socket. Its exact semantics are implementation specific.
In particular, an implementation may impose a maximum length or may choose
to ignore the parameter altogther. If the {@code backlog} parameter has
the value {@code 0}, or a negative value, then an implementation specific
default is used.

@param   local
         The address to bind the socket, or {@code null} to bind to an
         automatically assigned socket address
@param   backlog
         The maximum number of pending connections

@return  This channel

@throws  AlreadyBoundException
         If the socket is already bound
@throws  UnsupportedAddressTypeException
         If the type of the given address is not supported
@throws  ClosedChannelException
         If this channel is closed
@throws  IOException
         If some other I/O error occurs
@throws  SecurityException
         If a security manager has been installed and its {@link
         SecurityManager#checkListen checkListen} method denies the
         operation

@since 1.7
"
      end

      operation 7800706 "setOption"
	abstract public return_type class_ref 211714 // ServerSocketChannel
	nparams 2
	  param inout name "name" type class_ref 962434 // SocketOption
	  param inout name "value" explicit_type "T"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<T> ${type} ${name}${(}${t0}<T> ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "@throws  UnsupportedOperationException           {@inheritDoc}
@throws  IllegalArgumentException                {@inheritDoc}
@throws  ClosedChannelException                  {@inheritDoc}
@throws  IOException                             {@inheritDoc}

@since 1.7
"
      end

      operation 7800834 "socket"
	abstract public return_type class_ref 208898 // ServerSocket
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Retrieves a server socket associated with this channel.

<p> The returned object will not declare any public methods that are not
declared in the {@link java.net.ServerSocket} class.  </p>

@return  A server socket associated with this channel
"
      end

      operation 7800962 "accept"
	abstract public return_type class_ref 212482 // SocketChannel
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Accepts a connection made to this channel's socket.

<p> If this channel is in non-blocking mode then this method will
immediately return <tt>null</tt> if there are no pending connections.
Otherwise it will block indefinitely until a new connection is available
or an I/O error occurs.

<p> The socket channel returned by this method, if any, will be in
blocking mode regardless of the blocking mode of this channel.

<p> This method performs exactly the same security checks as the {@link
java.net.ServerSocket#accept accept} method of the {@link
java.net.ServerSocket} class.  That is, if a security manager has been
installed then for each new connection this method verifies that the
address and port number of the connection's remote endpoint are
permitted by the security manager's {@link
java.lang.SecurityManager#checkAccept checkAccept} method.  </p>

@return  The socket channel for the new connection,
         or <tt>null</tt> if this channel is in non-blocking mode
         and no connection is available to be accepted

@throws  ClosedChannelException
         If this channel is closed

@throws  AsynchronousCloseException
         If another thread closes this channel
         while the accept operation is in progress

@throws  ClosedByInterruptException
         If another thread interrupts the current thread
         while the accept operation is in progress, thereby
         closing the channel and setting the current thread's
         interrupt status

@throws  NotYetBoundException
         If this channel's socket has not yet been bound

@throws  SecurityException
         If a security manager has been installed
         and it does not permit access to the remote endpoint
         of the new connection

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7801090 "getLocalAddress"
	abstract public return_type class_ref 962178 // SocketAddress
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
	comment "{@inheritDoc}
<p>
If there is a security manager set, its {@code checkConnect} method is
called with the local address and {@code -1} as its arguments to see
if the operation is allowed. If the operation is not allowed,
a {@code SocketAddress} representing the
{@link java.net.InetAddress#getLoopbackAddress loopback} address and the
local port of the channel's socket is returned.

@return  The {@code SocketAddress} that the socket is bound to, or the
         {@code SocketAddress} representing the loopback address if
         denied by the security manager, or {@code null} if the
         channel's socket is not bound

@throws  ClosedChannelException     {@inheritDoc}
@throws  IOException                {@inheritDoc}
"
      end
    end

    class 212482 "SocketChannel"
      abstract visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A selectable channel for stream-oriented connecting sockets.

<p> A socket channel is created by invoking one of the {@link #open open}
methods of this class.  It is not possible to create a channel for an arbitrary,
pre-existing socket. A newly-created socket channel is open but not yet
connected.  An attempt to invoke an I/O operation upon an unconnected
channel will cause a {@link NotYetConnectedException} to be thrown.  A
socket channel can be connected by invoking its {@link #connect connect}
method; once connected, a socket channel remains connected until it is
closed.  Whether or not a socket channel is connected may be determined by
invoking its {@link #isConnected isConnected} method.

<p> Socket channels support <i>non-blocking connection:</i>&nbsp;A socket
channel may be created and the process of establishing the link to the
remote socket may be initiated via the {@link #connect connect} method for
later completion by the {@link #finishConnect finishConnect} method.
Whether or not a connection operation is in progress may be determined by
invoking the {@link #isConnectionPending isConnectionPending} method.

<p> Socket channels support <i>asynchronous shutdown,</i> which is similar
to the asynchronous close operation specified in the {@link Channel} class.
If the input side of a socket is shut down by one thread while another
thread is blocked in a read operation on the socket's channel, then the read
operation in the blocked thread will complete without reading any bytes and
will return <tt>-1</tt>.  If the output side of a socket is shut down by one
thread while another thread is blocked in a write operation on the socket's
channel, then the blocked thread will receive an {@link
AsynchronousCloseException}.

<p> Socket options are configured using the {@link #setOption(SocketOption,Object)
setOption} method. Socket channels support the following options:
<blockquote>
<table border summary=\"Socket options\">
  <tr>
    <th>Option Name</th>
    <th>Description</th>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#SO_SNDBUF SO_SNDBUF} </td>
    <td> The size of the socket send buffer </td>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} </td>
    <td> The size of the socket receive buffer </td>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#SO_KEEPALIVE SO_KEEPALIVE} </td>
    <td> Keep connection alive </td>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR} </td>
    <td> Re-use address </td>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#SO_LINGER SO_LINGER} </td>
    <td> Linger on close if data is present (when configured in blocking mode
         only) </td>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#TCP_NODELAY TCP_NODELAY} </td>
    <td> Disable the Nagle algorithm </td>
  </tr>
</table>
</blockquote>
Additional (implementation specific) options may also be supported.

<p> Socket channels are safe for use by multiple concurrent threads.  They
support concurrent reading and writing, though at most one thread may be
reading and at most one thread may be writing at any given time.  The {@link
#connect connect} and {@link #finishConnect finishConnect} methods are
mutually synchronized against each other, and an attempt to initiate a read
or write operation while an invocation of one of these methods is in
progress will block until that invocation is complete.  </p>

@author Mark Reinhold
@author JSR-51 Expert Group
@since 1.4
"
      classrelation 3300994 // <generalisation>
	relation 3300994 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3300994 // <generalisation>
	  b parent class_ref 987906 // AbstractSelectableChannel
      end

      classrelation 3301122 // <realization>
	relation 3301122 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3301122 // <realization>
	  b parent class_ref 986370 // ByteChannel
      end

      classrelation 3301250 // <realization>
	relation 3301250 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3301250 // <realization>
	  b parent class_ref 988162 // ScatteringByteChannel
      end

      classrelation 3301378 // <realization>
	relation 3301378 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3301378 // <realization>
	  b parent class_ref 988290 // GatheringByteChannel
      end

      classrelation 3301506 // <realization>
	relation 3301506 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3301506 // <realization>
	  b parent class_ref 986114 // NetworkChannel
      end

      operation 7801346 "SocketChannel"
	protected explicit_return_type ""
	nparams 1
	  param inout name "provider" type class_ref 988034 // SelectorProvider
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Initializes a new instance of this class.

@param  provider
        The provider that created this channel
"
      end

      operation 7801474 "open"
	class_operation public return_type class_ref 212482 // SocketChannel
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Opens a socket channel.

<p> The new channel is created by invoking the {@link
java.nio.channels.spi.SelectorProvider#openSocketChannel
openSocketChannel} method of the system-wide default {@link
java.nio.channels.spi.SelectorProvider} object.  </p>

@return  A new socket channel

@throws  IOException
         If an I/O error occurs
"
      end

      operation 7801602 "open"
	class_operation public return_type class_ref 212482 // SocketChannel
	nparams 1
	  param inout name "remote" type class_ref 962178 // SocketAddress
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Opens a socket channel and connects it to a remote address.

<p> This convenience method works as if by invoking the {@link #open()}
method, invoking the {@link #connect(SocketAddress) connect} method upon
the resulting socket channel, passing it <tt>remote</tt>, and then
returning that channel.  </p>

@param  remote
        The remote address to which the new channel is to be connected

@return  A new, and connected, socket channel

@throws  AsynchronousCloseException
         If another thread closes this channel
         while the connect operation is in progress

@throws  ClosedByInterruptException
         If another thread interrupts the current thread
         while the connect operation is in progress, thereby
         closing the channel and setting the current thread's
         interrupt status

@throws  UnresolvedAddressException
         If the given remote address is not fully resolved

@throws  UnsupportedAddressTypeException
         If the type of the given remote address is not supported

@throws  SecurityException
         If a security manager has been installed
         and it does not permit access to the given remote endpoint

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7801730 "validOps"
	public explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an operation set identifying this channel's supported
operations.

<p> Socket channels support connecting, reading, and writing, so this
method returns <tt>(</tt>{@link SelectionKey#OP_CONNECT}
<tt>|</tt>&nbsp;{@link SelectionKey#OP_READ} <tt>|</tt>&nbsp;{@link
SelectionKey#OP_WRITE}<tt>)</tt>.  </p>

@return  The valid-operation set
"
      end

      operation 7801858 "bind"
	abstract public return_type class_ref 212482 // SocketChannel
	nparams 1
	  param inout name "local" type class_ref 962178 // SocketAddress
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
	comment " -- Socket-specific operations --

@throws  ConnectionPendingException
         If a non-blocking connect operation is already in progress on
         this channel
@throws  AlreadyBoundException               {@inheritDoc}
@throws  UnsupportedAddressTypeException     {@inheritDoc}
@throws  ClosedChannelException              {@inheritDoc}
@throws  IOException                         {@inheritDoc}
@throws  SecurityException
         If a security manager has been installed and its
         {@link SecurityManager#checkListen checkListen} method denies
         the operation

@since 1.7
"
      end

      operation 7801986 "setOption"
	abstract public return_type class_ref 212482 // SocketChannel
	nparams 2
	  param inout name "name" type class_ref 962434 // SocketOption
	  param inout name "value" explicit_type "T"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<T> ${type} ${name}${(}${t0}<T> ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
	comment "@throws  UnsupportedOperationException           {@inheritDoc}
@throws  IllegalArgumentException                {@inheritDoc}
@throws  ClosedChannelException                  {@inheritDoc}
@throws  IOException                             {@inheritDoc}

@since 1.7
"
      end

      operation 7802114 "shutdownInput"
	abstract public return_type class_ref 212482 // SocketChannel
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Shutdown the connection for reading without closing the channel.

<p> Once shutdown for reading then further reads on the channel will
return {@code -1}, the end-of-stream indication. If the input side of the
connection is already shutdown then invoking this method has no effect.

@return  The channel

@throws  NotYetConnectedException
         If this channel is not yet connected
@throws  ClosedChannelException
         If this channel is closed
@throws  IOException
         If some other I/O error occurs

@since 1.7
"
      end

      operation 7802242 "shutdownOutput"
	abstract public return_type class_ref 212482 // SocketChannel
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Shutdown the connection for writing without closing the channel.

<p> Once shutdown for writing then further attempts to write to the
channel will throw {@link ClosedChannelException}. If the output side of
the connection is already shutdown then invoking this method has no
effect.

@return  The channel

@throws  NotYetConnectedException
         If this channel is not yet connected
@throws  ClosedChannelException
         If this channel is closed
@throws  IOException
         If some other I/O error occurs

@since 1.7
"
      end

      operation 7802370 "socket"
	abstract public return_type class_ref 209154 // Socket
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Retrieves a socket associated with this channel.

<p> The returned object will not declare any public methods that are not
declared in the {@link java.net.Socket} class.  </p>

@return  A socket associated with this channel
"
      end

      operation 7802498 "isConnected"
	abstract public explicit_return_type "boolean"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Tells whether or not this channel's network socket is connected.

@return  <tt>true</tt> if, and only if, this channel's network socket
         is {@link #isOpen open} and connected
"
      end

      operation 7802626 "isConnectionPending"
	abstract public explicit_return_type "boolean"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Tells whether or not a connection operation is in progress on this
channel.

@return  <tt>true</tt> if, and only if, a connection operation has been
         initiated on this channel but not yet completed by invoking the
         {@link #finishConnect finishConnect} method
"
      end

      operation 7802754 "connect"
	abstract public explicit_return_type "boolean"
	nparams 1
	  param inout name "remote" type class_ref 962178 // SocketAddress
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Connects this channel's socket.

<p> If this channel is in non-blocking mode then an invocation of this
method initiates a non-blocking connection operation.  If the connection
is established immediately, as can happen with a local connection, then
this method returns <tt>true</tt>.  Otherwise this method returns
<tt>false</tt> and the connection operation must later be completed by
invoking the {@link #finishConnect finishConnect} method.

<p> If this channel is in blocking mode then an invocation of this
method will block until the connection is established or an I/O error
occurs.

<p> This method performs exactly the same security checks as the {@link
java.net.Socket} class.  That is, if a security manager has been
installed then this method verifies that its {@link
java.lang.SecurityManager#checkConnect checkConnect} method permits
connecting to the address and port number of the given remote endpoint.

<p> This method may be invoked at any time.  If a read or write
operation upon this channel is invoked while an invocation of this
method is in progress then that operation will first block until this
invocation is complete.  If a connection attempt is initiated but fails,
that is, if an invocation of this method throws a checked exception,
then the channel will be closed.  </p>

@param  remote
        The remote address to which this channel is to be connected

@return  <tt>true</tt> if a connection was established,
         <tt>false</tt> if this channel is in non-blocking mode
         and the connection operation is in progress

@throws  AlreadyConnectedException
         If this channel is already connected

@throws  ConnectionPendingException
         If a non-blocking connection operation is already in progress
         on this channel

@throws  ClosedChannelException
         If this channel is closed

@throws  AsynchronousCloseException
         If another thread closes this channel
         while the connect operation is in progress

@throws  ClosedByInterruptException
         If another thread interrupts the current thread
         while the connect operation is in progress, thereby
         closing the channel and setting the current thread's
         interrupt status

@throws  UnresolvedAddressException
         If the given remote address is not fully resolved

@throws  UnsupportedAddressTypeException
         If the type of the given remote address is not supported

@throws  SecurityException
         If a security manager has been installed
         and it does not permit access to the given remote endpoint

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7802882 "finishConnect"
	abstract public explicit_return_type "boolean"
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Finishes the process of connecting a socket channel.

<p> A non-blocking connection operation is initiated by placing a socket
channel in non-blocking mode and then invoking its {@link #connect
connect} method.  Once the connection is established, or the attempt has
failed, the socket channel will become connectable and this method may
be invoked to complete the connection sequence.  If the connection
operation failed then invoking this method will cause an appropriate
{@link java.io.IOException} to be thrown.

<p> If this channel is already connected then this method will not block
and will immediately return <tt>true</tt>.  If this channel is in
non-blocking mode then this method will return <tt>false</tt> if the
connection process is not yet complete.  If this channel is in blocking
mode then this method will block until the connection either completes
or fails, and will always either return <tt>true</tt> or throw a checked
exception describing the failure.

<p> This method may be invoked at any time.  If a read or write
operation upon this channel is invoked while an invocation of this
method is in progress then that operation will first block until this
invocation is complete.  If a connection attempt fails, that is, if an
invocation of this method throws a checked exception, then the channel
will be closed.  </p>

@return  <tt>true</tt> if, and only if, this channel's socket is now
         connected

@throws  NoConnectionPendingException
         If this channel is not connected and a connection operation
         has not been initiated

@throws  ClosedChannelException
         If this channel is closed

@throws  AsynchronousCloseException
         If another thread closes this channel
         while the connect operation is in progress

@throws  ClosedByInterruptException
         If another thread interrupts the current thread
         while the connect operation is in progress, thereby
         closing the channel and setting the current thread's
         interrupt status

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7803010 "getRemoteAddress"
	abstract public return_type class_ref 962178 // SocketAddress
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the remote address to which this channel's socket is connected.

<p> Where the channel is bound and connected to an Internet Protocol
socket address then the return value from this method is of type {@link
java.net.InetSocketAddress}.

@return  The remote address; {@code null} if the channel's socket is not
         connected

@throws  ClosedChannelException
         If the channel is closed
@throws  IOException
         If an I/O error occurs

@since 1.7
"
      end

      operation 7803138 "read"
	abstract public explicit_return_type "int"
	nparams 1
	  param inout name "dst" type class_ref 149890 // ByteBuffer
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " -- ByteChannel operations --

@throws  NotYetConnectedException
         If this channel is not yet connected
"
      end

      operation 7803266 "read"
	abstract public explicit_return_type "long"
	nparams 3
	  param inout name "dsts" type class_ref 149890 // ByteBuffer
	multiplicity "[]"
	  param in name "offset" explicit_type "int"
	  param in name "length" explicit_type "int"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0}[] ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "@throws  NotYetConnectedException
         If this channel is not yet connected
"
      end

      operation 7803394 "read"
	public explicit_return_type "long"
	nparams 1
	  param inout name "dsts" type class_ref 149890 // ByteBuffer
	multiplicity "[]"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0}[] ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "@throws  NotYetConnectedException
         If this channel is not yet connected
"
      end

      operation 7803522 "write"
	abstract public explicit_return_type "int"
	nparams 1
	  param inout name "src" type class_ref 149890 // ByteBuffer
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "@throws  NotYetConnectedException
         If this channel is not yet connected
"
      end

      operation 7803650 "write"
	abstract public explicit_return_type "long"
	nparams 3
	  param inout name "srcs" type class_ref 149890 // ByteBuffer
	multiplicity "[]"
	  param in name "offset" explicit_type "int"
	  param in name "length" explicit_type "int"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0}[] ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "@throws  NotYetConnectedException
         If this channel is not yet connected
"
      end

      operation 7803778 "write"
	public explicit_return_type "long"
	nparams 1
	  param inout name "srcs" type class_ref 149890 // ByteBuffer
	multiplicity "[]"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0}[] ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "@throws  NotYetConnectedException
         If this channel is not yet connected
"
      end

      operation 7803906 "getLocalAddress"
	abstract public return_type class_ref 962178 // SocketAddress
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
	comment "{@inheritDoc}
<p>
If there is a security manager set, its {@code checkConnect} method is
called with the local address and {@code -1} as its arguments to see
if the operation is allowed. If the operation is not allowed,
a {@code SocketAddress} representing the
{@link java.net.InetAddress#getLoopbackAddress loopback} address and the
local port of the channel's socket is returned.

@return  The {@code SocketAddress} that the socket is bound to, or the
         {@code SocketAddress} representing the loopback address if
         denied by the security manager, or {@code null} if the
         channel's socket is not bound

@throws  ClosedChannelException     {@inheritDoc}
@throws  IOException                {@inheritDoc}
"
      end
    end

    class 275586 "Selector"
      abstract visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A multiplexor of {@link SelectableChannel} objects.

<p> A selector may be created by invoking the {@link #open open} method of
this class, which will use the system's default {@link
java.nio.channels.spi.SelectorProvider selector provider} to
create a new selector.  A selector may also be created by invoking the
{@link java.nio.channels.spi.SelectorProvider#openSelector openSelector}
method of a custom selector provider.  A selector remains open until it is
closed via its {@link #close close} method.

<a name=\"ks\"></a>

<p> A selectable channel's registration with a selector is represented by a
{@link SelectionKey} object.  A selector maintains three sets of selection
keys:

<ul>

  <li><p> The <i>key set</i> contains the keys representing the current
  channel registrations of this selector.  This set is returned by the
  {@link #keys() keys} method. </p></li>

  <li><p> The <i>selected-key set</i> is the set of keys such that each
  key's channel was detected to be ready for at least one of the operations
  identified in the key's interest set during a prior selection operation.
  This set is returned by the {@link #selectedKeys() selectedKeys} method.
  The selected-key set is always a subset of the key set. </p></li>

  <li><p> The <i>cancelled-key</i> set is the set of keys that have been
  cancelled but whose channels have not yet been deregistered.  This set is
  not directly accessible.  The cancelled-key set is always a subset of the
  key set. </p></li>

</ul>

<p> All three sets are empty in a newly-created selector.

<p> A key is added to a selector's key set as a side effect of registering a
channel via the channel's {@link SelectableChannel#register(Selector,int)
register} method.  Cancelled keys are removed from the key set during
selection operations.  The key set itself is not directly modifiable.

<p> A key is added to its selector's cancelled-key set when it is cancelled,
whether by closing its channel or by invoking its {@link SelectionKey#cancel
cancel} method.  Cancelling a key will cause its channel to be deregistered
during the next selection operation, at which time the key will removed from
all of the selector's key sets.

<a name=\"sks\"></a><p> Keys are added to the selected-key set by selection
operations.  A key may be removed directly from the selected-key set by
invoking the set's {@link java.util.Set#remove(java.lang.Object) remove}
method or by invoking the {@link java.util.Iterator#remove() remove} method
of an {@link java.util.Iterator iterator} obtained from the
set.  Keys are never removed from the selected-key set in any other way;
they are not, in particular, removed as a side effect of selection
operations.  Keys may not be added directly to the selected-key set. </p>


<a name=\"selop\"></a>
<h2>Selection</h2>

<p> During each selection operation, keys may be added to and removed from a
selector's selected-key set and may be removed from its key and
cancelled-key sets.  Selection is performed by the {@link #select()}, {@link
#select(long)}, and {@link #selectNow()} methods, and involves three steps:
</p>

<ol>

  <li><p> Each key in the cancelled-key set is removed from each key set of
  which it is a member, and its channel is deregistered.  This step leaves
  the cancelled-key set empty. </p></li>

  <li><p> The underlying operating system is queried for an update as to the
  readiness of each remaining channel to perform any of the operations
  identified by its key's interest set as of the moment that the selection
  operation began.  For a channel that is ready for at least one such
  operation, one of the following two actions is performed: </p>

  <ol>

    <li><p> If the channel's key is not already in the selected-key set then
    it is added to that set and its ready-operation set is modified to
    identify exactly those operations for which the channel is now reported
    to be ready.  Any readiness information previously recorded in the ready
    set is discarded.  </p></li>

    <li><p> Otherwise the channel's key is already in the selected-key set,
    so its ready-operation set is modified to identify any new operations
    for which the channel is reported to be ready.  Any readiness
    information previously recorded in the ready set is preserved; in other
    words, the ready set returned by the underlying system is
    bitwise-disjoined into the key's current ready set. </p></li>

  </ol>

  If all of the keys in the key set at the start of this step have empty
  interest sets then neither the selected-key set nor any of the keys'
  ready-operation sets will be updated.

  <li><p> If any keys were added to the cancelled-key set while step (2) was
  in progress then they are processed as in step (1). </p></li>

</ol>

<p> Whether or not a selection operation blocks to wait for one or more
channels to become ready, and if so for how long, is the only essential
difference between the three selection methods. </p>


<h2>Concurrency</h2>

<p> Selectors are themselves safe for use by multiple concurrent threads;
their key sets, however, are not.

<p> The selection operations synchronize on the selector itself, on the key
set, and on the selected-key set, in that order.  They also synchronize on
the cancelled-key set during steps (1) and (3) above.

<p> Changes made to the interest sets of a selector's keys while a
selection operation is in progress have no effect upon that operation; they
will be seen by the next selection operation.

<p> Keys may be cancelled and channels may be closed at any time.  Hence the
presence of a key in one or more of a selector's key sets does not imply
that the key is valid or that its channel is open.  Application code should
be careful to synchronize and check these conditions as necessary if there
is any possibility that another thread will cancel a key or close a channel.

<p> A thread blocked in one of the {@link #select()} or {@link
#select(long)} methods may be interrupted by some other thread in one of
three ways:

<ul>

  <li><p> By invoking the selector's {@link #wakeup wakeup} method,
  </p></li>

  <li><p> By invoking the selector's {@link #close close} method, or
  </p></li>

  <li><p> By invoking the blocked thread's {@link
  java.lang.Thread#interrupt() interrupt} method, in which case its
  interrupt status will be set and the selector's {@link #wakeup wakeup}
  method will be invoked. </p></li>

</ul>

<p> The {@link #close close} method synchronizes on the selector and all
three key sets in the same order as in a selection operation.

<a name=\"ksc\"></a>

<p> A selector's key and selected-key sets are not, in general, safe for use
by multiple concurrent threads.  If such a thread might modify one of these
sets directly then access should be controlled by synchronizing on the set
itself.  The iterators returned by these sets' {@link
java.util.Set#iterator() iterator} methods are <i>fail-fast:</i> If the set
is modified after the iterator is created, in any way except by invoking the
iterator's own {@link java.util.Iterator#remove() remove} method, then a
{@link java.util.ConcurrentModificationException} will be thrown. </p>


@author Mark Reinhold
@author JSR-51 Expert Group
@since 1.4

@see SelectableChannel
@see SelectionKey
"
      classrelation 3300482 // <realization>
	relation 3300482 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3300482 // <realization>
	  b parent class_ref 146562 // Closeable
      end

      operation 7798658 "Selector"
	protected explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Initializes a new instance of this class.
"
      end

      operation 7798786 "open"
	class_operation public return_type class_ref 275586 // Selector
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Opens a selector.

<p> The new selector is created by invoking the {@link
java.nio.channels.spi.SelectorProvider#openSelector openSelector} method
of the system-wide default {@link
java.nio.channels.spi.SelectorProvider} object.  </p>

@return  A new selector

@throws  IOException
         If an I/O error occurs
"
      end

      operation 7798914 "isOpen"
	abstract public explicit_return_type "boolean"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Tells whether or not this selector is open.

@return <tt>true</tt> if, and only if, this selector is open
"
      end

      operation 7799042 "provider"
	abstract public return_type class_ref 988034 // SelectorProvider
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the provider that created this channel.

@return  The provider that created this channel
"
      end

      operation 7799170 "keys"
	abstract public return_type class_ref 192258 // Set
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<SelectionKey> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns this selector's key set.

<p> The key set is not directly modifiable.  A key is removed only after
it has been cancelled and its channel has been deregistered.  Any
attempt to modify the key set will cause an {@link
UnsupportedOperationException} to be thrown.

<p> The key set is <a href=\"#ksc\">not thread-safe</a>. </p>

@return  This selector's key set

@throws  ClosedSelectorException
         If this selector is closed
"
      end

      operation 7799298 "selectedKeys"
	abstract public return_type class_ref 192258 // Set
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<SelectionKey> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns this selector's selected-key set.

<p> Keys may be removed from, but not directly added to, the
selected-key set.  Any attempt to add an object to the key set will
cause an {@link UnsupportedOperationException} to be thrown.

<p> The selected-key set is <a href=\"#ksc\">not thread-safe</a>. </p>

@return  This selector's selected-key set

@throws  ClosedSelectorException
         If this selector is closed
"
      end

      operation 7799426 "selectNow"
	abstract public explicit_return_type "int"
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Selects a set of keys whose corresponding channels are ready for I/O
operations.

<p> This method performs a non-blocking <a href=\"#selop\">selection
operation</a>.  If no channels have become selectable since the previous
selection operation then this method immediately returns zero.

<p> Invoking this method clears the effect of any previous invocations
of the {@link #wakeup wakeup} method.  </p>

@return  The number of keys, possibly zero, whose ready-operation sets
         were updated by the selection operation

@throws  IOException
         If an I/O error occurs

@throws  ClosedSelectorException
         If this selector is closed
"
      end

      operation 7799554 "select"
	abstract public explicit_return_type "int"
	nparams 1
	  param in name "timeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Selects a set of keys whose corresponding channels are ready for I/O
operations.

<p> This method performs a blocking <a href=\"#selop\">selection
operation</a>.  It returns only after at least one channel is selected,
this selector's {@link #wakeup wakeup} method is invoked, the current
thread is interrupted, or the given timeout period expires, whichever
comes first.

<p> This method does not offer real-time guarantees: It schedules the
timeout as if by invoking the {@link Object#wait(long)} method. </p>

@param  timeout  If positive, block for up to <tt>timeout</tt>
                 milliseconds, more or less, while waiting for a
                 channel to become ready; if zero, block indefinitely;
                 must not be negative

@return  The number of keys, possibly zero,
         whose ready-operation sets were updated

@throws  IOException
         If an I/O error occurs

@throws  ClosedSelectorException
         If this selector is closed

@throws  IllegalArgumentException
         If the value of the timeout argument is negative
"
      end

      operation 7799682 "select"
	abstract public explicit_return_type "int"
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Selects a set of keys whose corresponding channels are ready for I/O
operations.

<p> This method performs a blocking <a href=\"#selop\">selection
operation</a>.  It returns only after at least one channel is selected,
this selector's {@link #wakeup wakeup} method is invoked, or the current
thread is interrupted, whichever comes first.  </p>

@return  The number of keys, possibly zero,
         whose ready-operation sets were updated

@throws  IOException
         If an I/O error occurs

@throws  ClosedSelectorException
         If this selector is closed
"
      end

      operation 7799810 "wakeup"
	abstract public return_type class_ref 275586 // Selector
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Causes the first selection operation that has not yet returned to return
immediately.

<p> If another thread is currently blocked in an invocation of the
{@link #select()} or {@link #select(long)} methods then that invocation
will return immediately.  If no selection operation is currently in
progress then the next invocation of one of these methods will return
immediately unless the {@link #selectNow()} method is invoked in the
meantime.  In any case the value returned by that invocation may be
non-zero.  Subsequent invocations of the {@link #select()} or {@link
#select(long)} methods will block as usual unless this method is invoked
again in the meantime.

<p> Invoking this method more than once between two successive selection
operations has the same effect as invoking it just once.  </p>

@return  This selector
"
      end

      operation 7799938 "close"
	abstract public explicit_return_type "void"
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Closes this selector.

<p> If a thread is currently blocked in one of this selector's selection
methods then it is interrupted as if by invoking the selector's {@link
#wakeup wakeup} method.

<p> Any uncancelled keys still associated with this selector are
invalidated, their channels are deregistered, and any other resources
associated with this selector are released.

<p> If this selector is already closed then invoking this method has no
effect.

<p> After a selector is closed, any further attempt to use it, except by
invoking this method or the {@link #wakeup wakeup} method, will cause a
{@link ClosedSelectorException} to be thrown. </p>

@throws  IOException
         If an I/O error occurs
"
      end
    end

    class 924034 "FileChannel"
      abstract visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A channel for reading, writing, mapping, and manipulating a file.

<p> A file channel is a {@link SeekableByteChannel} that is connected to
a file. It has a current <i>position</i> within its file which can
be both {@link #position() <i>queried</i>} and {@link #position(long)
<i>modified</i>}.  The file itself contains a variable-length sequence
of bytes that can be read and written and whose current {@link #size
<i>size</i>} can be queried.  The size of the file increases
when bytes are written beyond its current size; the size of the file
decreases when it is {@link #truncate <i>truncated</i>}.  The
file may also have some associated <i>metadata</i> such as access
permissions, content type, and last-modification time; this class does not
define methods for metadata access.

<p> In addition to the familiar read, write, and close operations of byte
channels, this class defines the following file-specific operations: </p>

<ul>

  <li><p> Bytes may be {@link #read(ByteBuffer, long) read} or
  {@link #write(ByteBuffer, long) <i>written</i>} at an absolute
  position in a file in a way that does not affect the channel's current
  position.  </p></li>

  <li><p> A region of a file may be {@link #map <i>mapped</i>}
  directly into memory; for large files this is often much more efficient
  than invoking the usual <tt>read</tt> or <tt>write</tt> methods.
  </p></li>

  <li><p> Updates made to a file may be {@link #force <i>forced
  out</i>} to the underlying storage device, ensuring that data are not
  lost in the event of a system crash.  </p></li>

  <li><p> Bytes can be transferred from a file {@link #transferTo <i>to
  some other channel</i>}, and {@link #transferFrom <i>vice
  versa</i>}, in a way that can be optimized by many operating systems
  into a very fast transfer directly to or from the filesystem cache.
  </p></li>

  <li><p> A region of a file may be {@link FileLock <i>locked</i>}
  against access by other programs.  </p></li>

</ul>

<p> File channels are safe for use by multiple concurrent threads.  The
{@link Channel#close close} method may be invoked at any time, as specified
by the {@link Channel} interface.  Only one operation that involves the
channel's position or can change its file's size may be in progress at any
given time; attempts to initiate a second such operation while the first is
still in progress will block until the first operation completes.  Other
operations, in particular those that take an explicit position, may proceed
concurrently; whether they in fact do so is dependent upon the underlying
implementation and is therefore unspecified.

<p> The view of a file provided by an instance of this class is guaranteed
to be consistent with other views of the same file provided by other
instances in the same program.  The view provided by an instance of this
class may or may not, however, be consistent with the views seen by other
concurrently-running programs due to caching performed by the underlying
operating system and delays induced by network-filesystem protocols.  This
is true regardless of the language in which these other programs are
written, and whether they are running on the same machine or on some other
machine.  The exact nature of any such inconsistencies are system-dependent
and are therefore unspecified.

<p> A file channel is created by invoking one of the {@link #open open}
methods defined by this class. A file channel can also be obtained from an
existing {@link java.io.FileInputStream#getChannel FileInputStream}, {@link
java.io.FileOutputStream#getChannel FileOutputStream}, or {@link
java.io.RandomAccessFile#getChannel RandomAccessFile} object by invoking
that object's <tt>getChannel</tt> method, which returns a file channel that
is connected to the same underlying file. Where the file channel is obtained
from an existing stream or random access file then the state of the file
channel is intimately connected to that of the object whose <tt>getChannel</tt>
method returned the channel.  Changing the channel's position, whether
explicitly or by reading or writing bytes, will change the file position of
the originating object, and vice versa. Changing the file's length via the
file channel will change the length seen via the originating object, and vice
versa.  Changing the file's content by writing bytes will change the content
seen by the originating object, and vice versa.

<a name=\"open-mode\"></a> <p> At various points this class specifies that an
instance that is \"open for reading,\" \"open for writing,\" or \"open for
reading and writing\" is required.  A channel obtained via the {@link
java.io.FileInputStream#getChannel getChannel} method of a {@link
java.io.FileInputStream} instance will be open for reading.  A channel
obtained via the {@link java.io.FileOutputStream#getChannel getChannel}
method of a {@link java.io.FileOutputStream} instance will be open for
writing.  Finally, a channel obtained via the {@link
java.io.RandomAccessFile#getChannel getChannel} method of a {@link
java.io.RandomAccessFile} instance will be open for reading if the instance
was created with mode <tt>\"r\"</tt> and will be open for reading and writing
if the instance was created with mode <tt>\"rw\"</tt>.

<a name=\"append-mode\"></a><p> A file channel that is open for writing may be in
<i>append mode</i>, for example if it was obtained from a file-output stream
that was created by invoking the {@link
java.io.FileOutputStream#FileOutputStream(java.io.File,boolean)
FileOutputStream(File,boolean)} constructor and passing <tt>true</tt> for
the second parameter.  In this mode each invocation of a relative write
operation first advances the position to the end of the file and then writes
the requested data.  Whether the advancement of the position and the writing
of the data are done in a single atomic operation is system-dependent and
therefore unspecified.

@see java.io.FileInputStream#getChannel()
@see java.io.FileOutputStream#getChannel()
@see java.io.RandomAccessFile#getChannel()

@author Mark Reinhold
@author Mike McCloskey
@author JSR-51 Expert Group
@since 1.4
"
      classrelation 3296386 // <generalisation>
	relation 3296386 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3296386 // <generalisation>
	  b parent class_ref 987138 // AbstractInterruptibleChannel
      end

      classrelation 3296642 // <realization>
	relation 3296642 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3296642 // <realization>
	  b parent class_ref 988674 // SeekableByteChannel
      end

      classrelation 3296770 // <realization>
	relation 3296770 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3296770 // <realization>
	  b parent class_ref 988290 // GatheringByteChannel
      end

      classrelation 3296898 // <realization>
	relation 3296898 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3296898 // <realization>
	  b parent class_ref 988162 // ScatteringByteChannel
      end

      operation 7788418 "FileChannel"
	protected explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Initializes a new instance of this class.
"
      end

      operation 7788546 "open"
	class_operation public return_type class_ref 924034 // FileChannel
	nparams 3
	  param inout name "path" type class_ref 923650 // Path
	  param inout name "options" type class_ref 192258 // Set
	  param inout name "attrs" explicit_type "FileAttribute<?>..."
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1}<? extends OpenOption> ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Opens or creates a file, returning a file channel to access the file.

<p> The {@code options} parameter determines how the file is opened.
The {@link StandardOpenOption#READ READ} and {@link StandardOpenOption#WRITE
WRITE} options determine if the file should be opened for reading and/or
writing. If neither option (or the {@link StandardOpenOption#APPEND APPEND}
option) is contained in the array then the file is opened for reading.
By default reading or writing commences at the beginning of the file.

<p> In the addition to {@code READ} and {@code WRITE}, the following
options may be present:

<table border=1 cellpadding=5 summary=\"\">
<tr> <th>Option</th> <th>Description</th> </tr>
<tr>
  <td> {@link StandardOpenOption#APPEND APPEND} </td>
  <td> If this option is present then the file is opened for writing and
    each invocation of the channel's {@code write} method first advances
    the position to the end of the file and then writes the requested
    data. Whether the advancement of the position and the writing of the
    data are done in a single atomic operation is system-dependent and
    therefore unspecified. This option may not be used in conjunction
    with the {@code READ} or {@code TRUNCATE_EXISTING} options. </td>
</tr>
<tr>
  <td> {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} </td>
  <td> If this option is present then the existing file is truncated to
  a size of 0 bytes. This option is ignored when the file is opened only
  for reading. </td>
</tr>
<tr>
  <td> {@link StandardOpenOption#CREATE_NEW CREATE_NEW} </td>
  <td> If this option is present then a new file is created, failing if
  the file already exists. When creating a file the check for the
  existence of the file and the creation of the file if it does not exist
  is atomic with respect to other file system operations. This option is
  ignored when the file is opened only for reading. </td>
</tr>
<tr>
  <td > {@link StandardOpenOption#CREATE CREATE} </td>
  <td> If this option is present then an existing file is opened if it
  exists, otherwise a new file is created. When creating a file the check
  for the existence of the file and the creation of the file if it does
  not exist is atomic with respect to other file system operations. This
  option is ignored if the {@code CREATE_NEW} option is also present or
  the file is opened only for reading. </td>
</tr>
<tr>
  <td > {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} </td>
  <td> When this option is present then the implementation makes a
  <em>best effort</em> attempt to delete the file when closed by the
  the {@link #close close} method. If the {@code close} method is not
  invoked then a <em>best effort</em> attempt is made to delete the file
  when the Java virtual machine terminates. </td>
</tr>
<tr>
  <td>{@link StandardOpenOption#SPARSE SPARSE} </td>
  <td> When creating a new file this option is a <em>hint</em> that the
  new file will be sparse. This option is ignored when not creating
  a new file. </td>
</tr>
<tr>
  <td> {@link StandardOpenOption#SYNC SYNC} </td>
  <td> Requires that every update to the file's content or metadata be
  written synchronously to the underlying storage device. (see <a
  href=\"../file/package-summary.html#integrity\"> Synchronized I/O file
  integrity</a>). </td>
</tr>
<tr>
  <td> {@link StandardOpenOption#DSYNC DSYNC} </td>
  <td> Requires that every update to the file's content be written
  synchronously to the underlying storage device. (see <a
  href=\"../file/package-summary.html#integrity\"> Synchronized I/O file
  integrity</a>). </td>
</tr>
</table>

<p> An implementation may also support additional options.

<p> The {@code attrs} parameter is an optional array of file {@link
FileAttribute file-attributes} to set atomically when creating the file.

<p> The new channel is created by invoking the {@link
FileSystemProvider#newFileChannel newFileChannel} method on the
provider that created the {@code Path}.

@param   path
         The path of the file to open or create
@param   options
         Options specifying how the file is opened
@param   attrs
         An optional list of file attributes to set atomically when
         creating the file

@return  A new file channel

@throws  IllegalArgumentException
         If the set contains an invalid combination of options
@throws  UnsupportedOperationException
         If the {@code path} is associated with a provider that does not
         support creating file channels, or an unsupported open option is
         specified, or the array contains an attribute that cannot be set
         atomically when creating the file
@throws  IOException
         If an I/O error occurs
@throws  SecurityException
         If a security manager is installed and it denies an
         unspecified permission required by the implementation.
         In the case of the default provider, the {@link
         SecurityManager#checkRead(String)} method is invoked to check
         read access if the file is opened for reading. The {@link
         SecurityManager#checkWrite(String)} method is invoked to check
         write access if the file is opened for writing

@since   1.7
"
      end

      classrelation 3297026 // NO_ATTRIBUTES (<unidirectional association>)
	relation 3297026 --->
	  a role_name "NO_ATTRIBUTES" multiplicity "[]" init_value " new FileAttribute[0]" class_relation const_relation private
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<?>${multiplicity} ${name}${value};
"
	    java_annotation "@SuppressWarnings({\"unchecked\", \"rawtypes\"})
"
	    classrelation_ref 3297026 // NO_ATTRIBUTES (<unidirectional association>)
	  b parent class_ref 985730 // FileAttribute
      end

      operation 7788674 "open"
	class_operation public return_type class_ref 924034 // FileChannel
	nparams 2
	  param inout name "path" type class_ref 923650 // Path
	  param inout name "" explicit_type "OpenOption...options"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Opens or creates a file, returning a file channel to access the file.

<p> An invocation of this method behaves in exactly the same way as the
invocation
<pre>
    fc.{@link #open(Path,Set,FileAttribute[]) open}(file, opts, new FileAttribute&lt;?&gt;[0]);
</pre>
where {@code opts} is a set of the options specified in the {@code
options} array.

@param   path
         The path of the file to open or create
@param   options
         Options specifying how the file is opened

@return  A new file channel

@throws  IllegalArgumentException
         If the set contains an invalid combination of options
@throws  UnsupportedOperationException
         If the {@code path} is associated with a provider that does not
         support creating file channels, or an unsupported open option is
         specified
@throws  IOException
         If an I/O error occurs
@throws  SecurityException
         If a security manager is installed and it denies an
         unspecified permission required by the implementation.
         In the case of the default provider, the {@link
         SecurityManager#checkRead(String)} method is invoked to check
         read access if the file is opened for reading. The {@link
         SecurityManager#checkWrite(String)} method is invoked to check
         write access if the file is opened for writing

@since   1.7
"
      end

      operation 7788802 "read"
	abstract public explicit_return_type "int"
	nparams 1
	  param inout name "dst" type class_ref 149890 // ByteBuffer
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " -- Channel operations --

Reads a sequence of bytes from this channel into the given buffer.

<p> Bytes are read starting at this channel's current file position, and
then the file position is updated with the number of bytes actually
read.  Otherwise this method behaves exactly as specified in the {@link
ReadableByteChannel} interface. </p>
"
      end

      operation 7788930 "read"
	abstract public explicit_return_type "long"
	nparams 3
	  param inout name "dsts" type class_ref 149890 // ByteBuffer
	multiplicity "[]"
	  param in name "offset" explicit_type "int"
	  param in name "length" explicit_type "int"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0}[] ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Reads a sequence of bytes from this channel into a subsequence of the
given buffers.

<p> Bytes are read starting at this channel's current file position, and
then the file position is updated with the number of bytes actually
read.  Otherwise this method behaves exactly as specified in the {@link
ScatteringByteChannel} interface.  </p>
"
      end

      operation 7789058 "read"
	public explicit_return_type "long"
	nparams 1
	  param inout name "dsts" type class_ref 149890 // ByteBuffer
	multiplicity "[]"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0}[] ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Reads a sequence of bytes from this channel into the given buffers.

<p> Bytes are read starting at this channel's current file position, and
then the file position is updated with the number of bytes actually
read.  Otherwise this method behaves exactly as specified in the {@link
ScatteringByteChannel} interface.  </p>
"
      end

      operation 7789186 "write"
	abstract public explicit_return_type "int"
	nparams 1
	  param inout name "src" type class_ref 149890 // ByteBuffer
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Writes a sequence of bytes to this channel from the given buffer.

<p> Bytes are written starting at this channel's current file position
unless the channel is in append mode, in which case the position is
first advanced to the end of the file.  The file is grown, if necessary,
to accommodate the written bytes, and then the file position is updated
with the number of bytes actually written.  Otherwise this method
behaves exactly as specified by the {@link WritableByteChannel}
interface. </p>
"
      end

      operation 7789314 "write"
	abstract public explicit_return_type "long"
	nparams 3
	  param inout name "srcs" type class_ref 149890 // ByteBuffer
	multiplicity "[]"
	  param in name "offset" explicit_type "int"
	  param in name "length" explicit_type "int"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0}[] ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Writes a sequence of bytes to this channel from a subsequence of the
given buffers.

<p> Bytes are written starting at this channel's current file position
unless the channel is in append mode, in which case the position is
first advanced to the end of the file.  The file is grown, if necessary,
to accommodate the written bytes, and then the file position is updated
with the number of bytes actually written.  Otherwise this method
behaves exactly as specified in the {@link GatheringByteChannel}
interface.  </p>
"
      end

      operation 7789442 "write"
	public explicit_return_type "long"
	nparams 1
	  param inout name "srcs" type class_ref 149890 // ByteBuffer
	multiplicity "[]"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0}[] ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Writes a sequence of bytes to this channel from the given buffers.

<p> Bytes are written starting at this channel's current file position
unless the channel is in append mode, in which case the position is
first advanced to the end of the file.  The file is grown, if necessary,
to accommodate the written bytes, and then the file position is updated
with the number of bytes actually written.  Otherwise this method
behaves exactly as specified in the {@link GatheringByteChannel}
interface.  </p>
"
      end

      operation 7789570 "position"
	abstract public explicit_return_type "long"
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " -- Other operations --

Returns this channel's file position.

@return  This channel's file position,
         a non-negative integer counting the number of bytes
         from the beginning of the file to the current position

@throws  ClosedChannelException
         If this channel is closed

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7789698 "position"
	abstract public return_type class_ref 924034 // FileChannel
	nparams 1
	  param in name "newPosition" explicit_type "long"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sets this channel's file position.

<p> Setting the position to a value that is greater than the file's
current size is legal but does not change the size of the file.  A later
attempt to read bytes at such a position will immediately return an
end-of-file indication.  A later attempt to write bytes at such a
position will cause the file to be grown to accommodate the new bytes;
the values of any bytes between the previous end-of-file and the
newly-written bytes are unspecified.  </p>

@param  newPosition
        The new position, a non-negative integer counting
        the number of bytes from the beginning of the file

@return  This file channel

@throws  ClosedChannelException
         If this channel is closed

@throws  IllegalArgumentException
         If the new position is negative

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7789826 "size"
	abstract public explicit_return_type "long"
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the current size of this channel's file.

@return  The current size of this channel's file,
         measured in bytes

@throws  ClosedChannelException
         If this channel is closed

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7789954 "truncate"
	abstract public return_type class_ref 924034 // FileChannel
	nparams 1
	  param in name "size" explicit_type "long"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Truncates this channel's file to the given size.

<p> If the given size is less than the file's current size then the file
is truncated, discarding any bytes beyond the new end of the file.  If
the given size is greater than or equal to the file's current size then
the file is not modified.  In either case, if this channel's file
position is greater than the given size then it is set to that size.
</p>

@param  size
        The new size, a non-negative byte count

@return  This file channel

@throws  NonWritableChannelException
         If this channel was not opened for writing

@throws  ClosedChannelException
         If this channel is closed

@throws  IllegalArgumentException
         If the new size is negative

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7790082 "force"
	abstract public explicit_return_type "void"
	nparams 1
	  param inout name "metaData" explicit_type "boolean"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Forces any updates to this channel's file to be written to the storage
device that contains it.

<p> If this channel's file resides on a local storage device then when
this method returns it is guaranteed that all changes made to the file
since this channel was created, or since this method was last invoked,
will have been written to that device.  This is useful for ensuring that
critical information is not lost in the event of a system crash.

<p> If the file does not reside on a local device then no such guarantee
is made.

<p> The <tt>metaData</tt> parameter can be used to limit the number of
I/O operations that this method is required to perform.  Passing
<tt>false</tt> for this parameter indicates that only updates to the
file's content need be written to storage; passing <tt>true</tt>
indicates that updates to both the file's content and metadata must be
written, which generally requires at least one more I/O operation.
Whether this parameter actually has any effect is dependent upon the
underlying operating system and is therefore unspecified.

<p> Invoking this method may cause an I/O operation to occur even if the
channel was only opened for reading.  Some operating systems, for
example, maintain a last-access time as part of a file's metadata, and
this time is updated whenever the file is read.  Whether or not this is
actually done is system-dependent and is therefore unspecified.

<p> This method is only guaranteed to force changes that were made to
this channel's file via the methods defined in this class.  It may or
may not force changes that were made by modifying the content of a
{@link MappedByteBuffer <i>mapped byte buffer</i>} obtained by
invoking the {@link #map map} method.  Invoking the {@link
MappedByteBuffer#force force} method of the mapped byte buffer will
force changes made to the buffer's content to be written.  </p>

@param   metaData
         If <tt>true</tt> then this method is required to force changes
         to both the file's content and metadata to be written to
         storage; otherwise, it need only force content changes to be
         written

@throws  ClosedChannelException
         If this channel is closed

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7790210 "transferTo"
	abstract public explicit_return_type "long"
	nparams 3
	  param in name "position" explicit_type "long"
	  param in name "count" explicit_type "long"
	  param inout name "target" type class_ref 986626 // WritableByteChannel
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Transfers bytes from this channel's file to the given writable byte
channel.

<p> An attempt is made to read up to <tt>count</tt> bytes starting at
the given <tt>position</tt> in this channel's file and write them to the
target channel.  An invocation of this method may or may not transfer
all of the requested bytes; whether or not it does so depends upon the
natures and states of the channels.  Fewer than the requested number of
bytes are transferred if this channel's file contains fewer than
<tt>count</tt> bytes starting at the given <tt>position</tt>, or if the
target channel is non-blocking and it has fewer than <tt>count</tt>
bytes free in its output buffer.

<p> This method does not modify this channel's position.  If the given
position is greater than the file's current size then no bytes are
transferred.  If the target channel has a position then bytes are
written starting at that position and then the position is incremented
by the number of bytes written.

<p> This method is potentially much more efficient than a simple loop
that reads from this channel and writes to the target channel.  Many
operating systems can transfer bytes directly from the filesystem cache
to the target channel without actually copying them.  </p>

@param  position
        The position within the file at which the transfer is to begin;
        must be non-negative

@param  count
        The maximum number of bytes to be transferred; must be
        non-negative

@param  target
        The target channel

@return  The number of bytes, possibly zero,
         that were actually transferred

@throws IllegalArgumentException
        If the preconditions on the parameters do not hold

@throws  NonReadableChannelException
         If this channel was not opened for reading

@throws  NonWritableChannelException
         If the target channel was not opened for writing

@throws  ClosedChannelException
         If either this channel or the target channel is closed

@throws  AsynchronousCloseException
         If another thread closes either channel
         while the transfer is in progress

@throws  ClosedByInterruptException
         If another thread interrupts the current thread while the
         transfer is in progress, thereby closing both channels and
         setting the current thread's interrupt status

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7790338 "transferFrom"
	abstract public explicit_return_type "long"
	nparams 3
	  param inout name "src" type class_ref 986498 // ReadableByteChannel
	  param in name "position" explicit_type "long"
	  param in name "count" explicit_type "long"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Transfers bytes into this channel's file from the given readable byte
channel.

<p> An attempt is made to read up to <tt>count</tt> bytes from the
source channel and write them to this channel's file starting at the
given <tt>position</tt>.  An invocation of this method may or may not
transfer all of the requested bytes; whether or not it does so depends
upon the natures and states of the channels.  Fewer than the requested
number of bytes will be transferred if the source channel has fewer than
<tt>count</tt> bytes remaining, or if the source channel is non-blocking
and has fewer than <tt>count</tt> bytes immediately available in its
input buffer.

<p> This method does not modify this channel's position.  If the given
position is greater than the file's current size then no bytes are
transferred.  If the source channel has a position then bytes are read
starting at that position and then the position is incremented by the
number of bytes read.

<p> This method is potentially much more efficient than a simple loop
that reads from the source channel and writes to this channel.  Many
operating systems can transfer bytes directly from the source channel
into the filesystem cache without actually copying them.  </p>

@param  src
        The source channel

@param  position
        The position within the file at which the transfer is to begin;
        must be non-negative

@param  count
        The maximum number of bytes to be transferred; must be
        non-negative

@return  The number of bytes, possibly zero,
         that were actually transferred

@throws IllegalArgumentException
        If the preconditions on the parameters do not hold

@throws  NonReadableChannelException
         If the source channel was not opened for reading

@throws  NonWritableChannelException
         If this channel was not opened for writing

@throws  ClosedChannelException
         If either this channel or the source channel is closed

@throws  AsynchronousCloseException
         If another thread closes either channel
         while the transfer is in progress

@throws  ClosedByInterruptException
         If another thread interrupts the current thread while the
         transfer is in progress, thereby closing both channels and
         setting the current thread's interrupt status

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7790466 "read"
	abstract public explicit_return_type "int"
	nparams 2
	  param inout name "dst" type class_ref 149890 // ByteBuffer
	  param in name "position" explicit_type "long"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Reads a sequence of bytes from this channel into the given buffer,
starting at the given file position.

<p> This method works in the same manner as the {@link
#read(ByteBuffer)} method, except that bytes are read starting at the
given file position rather than at the channel's current position.  This
method does not modify this channel's position.  If the given position
is greater than the file's current size then no bytes are read.  </p>

@param  dst
        The buffer into which bytes are to be transferred

@param  position
        The file position at which the transfer is to begin;
        must be non-negative

@return  The number of bytes read, possibly zero, or <tt>-1</tt> if the
         given position is greater than or equal to the file's current
         size

@throws  IllegalArgumentException
         If the position is negative

@throws  NonReadableChannelException
         If this channel was not opened for reading

@throws  ClosedChannelException
         If this channel is closed

@throws  AsynchronousCloseException
         If another thread closes this channel
         while the read operation is in progress

@throws  ClosedByInterruptException
         If another thread interrupts the current thread
         while the read operation is in progress, thereby
         closing the channel and setting the current thread's
         interrupt status

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7790594 "write"
	abstract public explicit_return_type "int"
	nparams 2
	  param inout name "src" type class_ref 149890 // ByteBuffer
	  param in name "position" explicit_type "long"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Writes a sequence of bytes to this channel from the given buffer,
starting at the given file position.

<p> This method works in the same manner as the {@link
#write(ByteBuffer)} method, except that bytes are written starting at
the given file position rather than at the channel's current position.
This method does not modify this channel's position.  If the given
position is greater than the file's current size then the file will be
grown to accommodate the new bytes; the values of any bytes between the
previous end-of-file and the newly-written bytes are unspecified.  </p>

@param  src
        The buffer from which bytes are to be transferred

@param  position
        The file position at which the transfer is to begin;
        must be non-negative

@return  The number of bytes written, possibly zero

@throws  IllegalArgumentException
         If the position is negative

@throws  NonWritableChannelException
         If this channel was not opened for writing

@throws  ClosedChannelException
         If this channel is closed

@throws  AsynchronousCloseException
         If another thread closes this channel
         while the write operation is in progress

@throws  ClosedByInterruptException
         If another thread interrupts the current thread
         while the write operation is in progress, thereby
         closing the channel and setting the current thread's
         interrupt status

@throws  IOException
         If some other I/O error occurs
"
      end

      class 988802 "MapMode"
	visibility public 
	cpp_decl ""
	static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3297154 // READ_ONLY (<unidirectional association>)
	  relation 3297154 --->
	    a role_name "READ_ONLY" init_value " new MapMode(\"READ_ONLY\")" class_relation const_relation public
	      comment "
Mode for a read-only mapping.

"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3297154 // READ_ONLY (<unidirectional association>)
	    b parent class_ref 988802 // MapMode
	end

	classrelation 3297282 // READ_WRITE (<unidirectional association>)
	  relation 3297282 --->
	    a role_name "READ_WRITE" init_value " new MapMode(\"READ_WRITE\")" class_relation const_relation public
	      comment "
Mode for a read/write mapping.

"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3297282 // READ_WRITE (<unidirectional association>)
	    b parent class_ref 988802 // MapMode
	end

	classrelation 3297410 // PRIVATE (<unidirectional association>)
	  relation 3297410 --->
	    a role_name "PRIVATE" init_value " new MapMode(\"PRIVATE\")" class_relation const_relation public
	      comment "
Mode for a private (copy-on-write) mapping.

"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3297410 // PRIVATE (<unidirectional association>)
	    b parent class_ref 988802 // MapMode
	end

	classrelation 3297538 // name (<unidirectional association>)
	  relation 3297538 --->
	    a role_name "name" const_relation private
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3297538 // name (<unidirectional association>)
	    b parent class_ref 128130 // String
	end

	operation 7790722 "MapMode"
	  private explicit_return_type ""
	  nparams 1
	    param inout name "name" type class_ref 128130 // String
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7790850 "toString"
	  public return_type class_ref 128130 // String
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns a string describing this file-mapping mode.

@return  A descriptive string
"
	end
      end

      operation 7790978 "map"
	abstract public return_type class_ref 978178 // MappedByteBuffer
	nparams 3
	  param inout name "mode" type class_ref 988802 // MapMode
	  param in name "position" explicit_type "long"
	  param in name "size" explicit_type "long"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Maps a region of this channel's file directly into memory.

<p> A region of a file may be mapped into memory in one of three modes:
</p>

<ul>

  <li><p> <i>Read-only:</i> Any attempt to modify the resulting buffer
  will cause a {@link java.nio.ReadOnlyBufferException} to be thrown.
  ({@link MapMode#READ_ONLY MapMode.READ_ONLY}) </p></li>

  <li><p> <i>Read/write:</i> Changes made to the resulting buffer will
  eventually be propagated to the file; they may or may not be made
  visible to other programs that have mapped the same file.  ({@link
  MapMode#READ_WRITE MapMode.READ_WRITE}) </p></li>

  <li><p> <i>Private:</i> Changes made to the resulting buffer will not
  be propagated to the file and will not be visible to other programs
  that have mapped the same file; instead, they will cause private
  copies of the modified portions of the buffer to be created.  ({@link
  MapMode#PRIVATE MapMode.PRIVATE}) </p></li>

</ul>

<p> For a read-only mapping, this channel must have been opened for
reading; for a read/write or private mapping, this channel must have
been opened for both reading and writing.

<p> The {@link MappedByteBuffer <i>mapped byte buffer</i>}
returned by this method will have a position of zero and a limit and
capacity of <tt>size</tt>; its mark will be undefined.  The buffer and
the mapping that it represents will remain valid until the buffer itself
is garbage-collected.

<p> A mapping, once established, is not dependent upon the file channel
that was used to create it.  Closing the channel, in particular, has no
effect upon the validity of the mapping.

<p> Many of the details of memory-mapped files are inherently dependent
upon the underlying operating system and are therefore unspecified.  The
behavior of this method when the requested region is not completely
contained within this channel's file is unspecified.  Whether changes
made to the content or size of the underlying file, by this program or
another, are propagated to the buffer is unspecified.  The rate at which
changes to the buffer are propagated to the file is unspecified.

<p> For most operating systems, mapping a file into memory is more
expensive than reading or writing a few tens of kilobytes of data via
the usual {@link #read read} and {@link #write write} methods.  From the
standpoint of performance it is generally only worth mapping relatively
large files into memory.  </p>

@param  mode
        One of the constants {@link MapMode#READ_ONLY READ_ONLY}, {@link
        MapMode#READ_WRITE READ_WRITE}, or {@link MapMode#PRIVATE
        PRIVATE} defined in the {@link MapMode} class, according to
        whether the file is to be mapped read-only, read/write, or
        privately (copy-on-write), respectively

@param  position
        The position within the file at which the mapped region
        is to start; must be non-negative

@param  size
        The size of the region to be mapped; must be non-negative and
        no greater than {@link java.lang.Integer#MAX_VALUE}

@return  The mapped byte buffer

@throws NonReadableChannelException
        If the <tt>mode</tt> is {@link MapMode#READ_ONLY READ_ONLY} but
        this channel was not opened for reading

@throws NonWritableChannelException
        If the <tt>mode</tt> is {@link MapMode#READ_WRITE READ_WRITE} or
        {@link MapMode#PRIVATE PRIVATE} but this channel was not opened
        for both reading and writing

@throws IllegalArgumentException
        If the preconditions on the parameters do not hold

@throws IOException
        If some other I/O error occurs

@see java.nio.channels.FileChannel.MapMode
@see java.nio.MappedByteBuffer
"
      end

      operation 7791106 "lock"
	abstract public return_type class_ref 985858 // FileLock
	nparams 3
	  param in name "position" explicit_type "long"
	  param in name "size" explicit_type "long"
	  param inout name "shared" explicit_type "boolean"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " -- Locks --

Acquires a lock on the given region of this channel's file.

<p> An invocation of this method will block until the region can be
locked, this channel is closed, or the invoking thread is interrupted,
whichever comes first.

<p> If this channel is closed by another thread during an invocation of
this method then an {@link AsynchronousCloseException} will be thrown.

<p> If the invoking thread is interrupted while waiting to acquire the
lock then its interrupt status will be set and a {@link
FileLockInterruptionException} will be thrown.  If the invoker's
interrupt status is set when this method is invoked then that exception
will be thrown immediately; the thread's interrupt status will not be
changed.

<p> The region specified by the <tt>position</tt> and <tt>size</tt>
parameters need not be contained within, or even overlap, the actual
underlying file.  Lock regions are fixed in size; if a locked region
initially contains the end of the file and the file grows beyond the
region then the new portion of the file will not be covered by the lock.
If a file is expected to grow in size and a lock on the entire file is
required then a region starting at zero, and no smaller than the
expected maximum size of the file, should be locked.  The zero-argument
{@link #lock()} method simply locks a region of size {@link
Long#MAX_VALUE}.

<p> Some operating systems do not support shared locks, in which case a
request for a shared lock is automatically converted into a request for
an exclusive lock.  Whether the newly-acquired lock is shared or
exclusive may be tested by invoking the resulting lock object's {@link
FileLock#isShared() isShared} method.

<p> File locks are held on behalf of the entire Java virtual machine.
They are not suitable for controlling access to a file by multiple
threads within the same virtual machine.  </p>

@param  position
        The position at which the locked region is to start; must be
        non-negative

@param  size
        The size of the locked region; must be non-negative, and the sum
        <tt>position</tt>&nbsp;+&nbsp;<tt>size</tt> must be non-negative

@param  shared
        <tt>true</tt> to request a shared lock, in which case this
        channel must be open for reading (and possibly writing);
        <tt>false</tt> to request an exclusive lock, in which case this
        channel must be open for writing (and possibly reading)

@return  A lock object representing the newly-acquired lock

@throws  IllegalArgumentException
         If the preconditions on the parameters do not hold

@throws  ClosedChannelException
         If this channel is closed

@throws  AsynchronousCloseException
         If another thread closes this channel while the invoking
         thread is blocked in this method

@throws  FileLockInterruptionException
         If the invoking thread is interrupted while blocked in this
         method

@throws  OverlappingFileLockException
         If a lock that overlaps the requested region is already held by
         this Java virtual machine, or if another thread is already
         blocked in this method and is attempting to lock an overlapping
         region

@throws  NonReadableChannelException
         If <tt>shared</tt> is <tt>true</tt> this channel was not
         opened for reading

@throws  NonWritableChannelException
         If <tt>shared</tt> is <tt>false</tt> but this channel was not
         opened for writing

@throws  IOException
         If some other I/O error occurs

@see     #lock()
@see     #tryLock()
@see     #tryLock(long,long,boolean)
"
      end

      operation 7791234 "lock"
	public return_type class_ref 985858 // FileLock
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires an exclusive lock on this channel's file.

<p> An invocation of this method of the form <tt>fc.lock()</tt> behaves
in exactly the same way as the invocation

<pre>
    fc.{@link #lock(long,long,boolean) lock}(0L, Long.MAX_VALUE, false) </pre>

@return  A lock object representing the newly-acquired lock

@throws  ClosedChannelException
         If this channel is closed

@throws  AsynchronousCloseException
         If another thread closes this channel while the invoking
         thread is blocked in this method

@throws  FileLockInterruptionException
         If the invoking thread is interrupted while blocked in this
         method

@throws  OverlappingFileLockException
         If a lock that overlaps the requested region is already held by
         this Java virtual machine, or if another thread is already
         blocked in this method and is attempting to lock an overlapping
         region of the same file

@throws  NonWritableChannelException
         If this channel was not opened for writing

@throws  IOException
         If some other I/O error occurs

@see     #lock(long,long,boolean)
@see     #tryLock()
@see     #tryLock(long,long,boolean)
"
      end

      operation 7791362 "tryLock"
	abstract public return_type class_ref 985858 // FileLock
	nparams 3
	  param in name "position" explicit_type "long"
	  param in name "size" explicit_type "long"
	  param inout name "shared" explicit_type "boolean"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to acquire a lock on the given region of this channel's file.

<p> This method does not block.  An invocation always returns
immediately, either having acquired a lock on the requested region or
having failed to do so.  If it fails to acquire a lock because an
overlapping lock is held by another program then it returns
<tt>null</tt>.  If it fails to acquire a lock for any other reason then
an appropriate exception is thrown.

<p> The region specified by the <tt>position</tt> and <tt>size</tt>
parameters need not be contained within, or even overlap, the actual
underlying file.  Lock regions are fixed in size; if a locked region
initially contains the end of the file and the file grows beyond the
region then the new portion of the file will not be covered by the lock.
If a file is expected to grow in size and a lock on the entire file is
required then a region starting at zero, and no smaller than the
expected maximum size of the file, should be locked.  The zero-argument
{@link #tryLock()} method simply locks a region of size {@link
Long#MAX_VALUE}.

<p> Some operating systems do not support shared locks, in which case a
request for a shared lock is automatically converted into a request for
an exclusive lock.  Whether the newly-acquired lock is shared or
exclusive may be tested by invoking the resulting lock object's {@link
FileLock#isShared() isShared} method.

<p> File locks are held on behalf of the entire Java virtual machine.
They are not suitable for controlling access to a file by multiple
threads within the same virtual machine.  </p>

@param  position
        The position at which the locked region is to start; must be
        non-negative

@param  size
        The size of the locked region; must be non-negative, and the sum
        <tt>position</tt>&nbsp;+&nbsp;<tt>size</tt> must be non-negative

@param  shared
        <tt>true</tt> to request a shared lock,
        <tt>false</tt> to request an exclusive lock

@return  A lock object representing the newly-acquired lock,
         or <tt>null</tt> if the lock could not be acquired
         because another program holds an overlapping lock

@throws  IllegalArgumentException
         If the preconditions on the parameters do not hold

@throws  ClosedChannelException
         If this channel is closed

@throws  OverlappingFileLockException
         If a lock that overlaps the requested region is already held by
         this Java virtual machine, or if another thread is already
         blocked in this method and is attempting to lock an overlapping
         region of the same file

@throws  IOException
         If some other I/O error occurs

@see     #lock()
@see     #lock(long,long,boolean)
@see     #tryLock()
"
      end

      operation 7791490 "tryLock"
	public return_type class_ref 985858 // FileLock
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to acquire an exclusive lock on this channel's file.

<p> An invocation of this method of the form <tt>fc.tryLock()</tt>
behaves in exactly the same way as the invocation

<pre>
    fc.{@link #tryLock(long,long,boolean) tryLock}(0L, Long.MAX_VALUE, false) </pre>

@return  A lock object representing the newly-acquired lock,
         or <tt>null</tt> if the lock could not be acquired
         because another program holds an overlapping lock

@throws  ClosedChannelException
         If this channel is closed

@throws  OverlappingFileLockException
         If a lock that overlaps the requested region is already held by
         this Java virtual machine, or if another thread is already
         blocked in this method and is attempting to lock an overlapping
         region

@throws  IOException
         If some other I/O error occurs

@see     #lock()
@see     #lock(long,long,boolean)
@see     #tryLock(long,long,boolean)
"
      end
    end

    class 940034 "Channel"
      visibility public stereotype "interface"
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A nexus for I/O operations.

<p> A channel represents an open connection to an entity such as a hardware
device, a file, a network socket, or a program component that is capable of
performing one or more distinct I/O operations, for example reading or
writing.

<p> A channel is either open or closed.  A channel is open upon creation,
and once closed it remains closed.  Once a channel is closed, any attempt to
invoke an I/O operation upon it will cause a {@link ClosedChannelException}
to be thrown.  Whether or not a channel is open may be tested by invoking
its {@link #isOpen isOpen} method.

<p> Channels are, in general, intended to be safe for multithreaded access
as described in the specifications of the interfaces and classes that extend
and implement this interface.


@author Mark Reinhold
@author JSR-51 Expert Group
@since 1.4
"
      classrelation 3289858 // <generalisation>
	relation 3289858 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3289858 // <generalisation>
	  b parent class_ref 146562 // Closeable
      end

      operation 7767426 "isOpen"
	public explicit_return_type "boolean"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Tells whether or not this channel is open.

@return <tt>true</tt> if, and only if, this channel is open
"
      end

      operation 7767554 "close"
	public explicit_return_type "void"
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Closes this channel.

<p> After a channel is closed, any further attempt to invoke I/O
operations upon it will cause a {@link ClosedChannelException} to be
thrown.

<p> If this channel is already closed then invoking this method has no
effect.

<p> This method may be invoked at any time.  If some other thread has
already invoked it, however, then another invocation will block until
the first invocation is complete, after which it will return without
effect. </p>

@throws  IOException  If an I/O error occurs
"
      end
    end

    class 964994 "DatagramChannel"
      abstract visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A selectable channel for datagram-oriented sockets.

<p> A datagram channel is created by invoking one of the {@link #open open} methods
of this class. It is not possible to create a channel for an arbitrary,
pre-existing datagram socket. A newly-created datagram channel is open but not
connected. A datagram channel need not be connected in order for the {@link #send
send} and {@link #receive receive} methods to be used.  A datagram channel may be
connected, by invoking its {@link #connect connect} method, in order to
avoid the overhead of the security checks are otherwise performed as part of
every send and receive operation.  A datagram channel must be connected in
order to use the {@link #read(java.nio.ByteBuffer) read} and {@link
#write(java.nio.ByteBuffer) write} methods, since those methods do not
accept or return socket addresses.

<p> Once connected, a datagram channel remains connected until it is
disconnected or closed.  Whether or not a datagram channel is connected may
be determined by invoking its {@link #isConnected isConnected} method.

<p> Socket options are configured using the {@link #setOption(SocketOption,Object)
setOption} method. A datagram channel to an Internet Protocol socket supports
the following options:
<blockquote>
<table border summary=\"Socket options\">
  <tr>
    <th>Option Name</th>
    <th>Description</th>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#SO_SNDBUF SO_SNDBUF} </td>
    <td> The size of the socket send buffer </td>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} </td>
    <td> The size of the socket receive buffer </td>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR} </td>
    <td> Re-use address </td>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#SO_BROADCAST SO_BROADCAST} </td>
    <td> Allow transmission of broadcast datagrams </td>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#IP_TOS IP_TOS} </td>
    <td> The Type of Service (ToS) octet in the Internet Protocol (IP) header </td>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#IP_MULTICAST_IF IP_MULTICAST_IF} </td>
    <td> The network interface for Internet Protocol (IP) multicast datagrams </td>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#IP_MULTICAST_TTL
      IP_MULTICAST_TTL} </td>
    <td> The <em>time-to-live</em> for Internet Protocol (IP) multicast
      datagrams </td>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#IP_MULTICAST_LOOP
      IP_MULTICAST_LOOP} </td>
    <td> Loopback for Internet Protocol (IP) multicast datagrams </td>
  </tr>
</table>
</blockquote>
Additional (implementation specific) options may also be supported.

<p> Datagram channels are safe for use by multiple concurrent threads.  They
support concurrent reading and writing, though at most one thread may be
reading and at most one thread may be writing at any given time.  </p>

@author Mark Reinhold
@author JSR-51 Expert Group
@since 1.4
"
      classrelation 3295362 // <generalisation>
	relation 3295362 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3295362 // <generalisation>
	  b parent class_ref 987906 // AbstractSelectableChannel
      end

      classrelation 3295490 // <realization>
	relation 3295490 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3295490 // <realization>
	  b parent class_ref 986370 // ByteChannel
      end

      classrelation 3295746 // <realization>
	relation 3295746 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3295746 // <realization>
	  b parent class_ref 988162 // ScatteringByteChannel
      end

      classrelation 3296002 // <realization>
	relation 3296002 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3296002 // <realization>
	  b parent class_ref 988290 // GatheringByteChannel
      end

      classrelation 3296258 // <realization>
	relation 3296258 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3296258 // <realization>
	  b parent class_ref 988418 // MulticastChannel
      end

      operation 7785090 "DatagramChannel"
	protected explicit_return_type ""
	nparams 1
	  param inout name "provider" type class_ref 988034 // SelectorProvider
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Initializes a new instance of this class.

@param  provider
        The provider that created this channel
"
      end

      operation 7785218 "open"
	class_operation public return_type class_ref 964994 // DatagramChannel
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Opens a datagram channel.

<p> The new channel is created by invoking the {@link
java.nio.channels.spi.SelectorProvider#openDatagramChannel()
openDatagramChannel} method of the system-wide default {@link
java.nio.channels.spi.SelectorProvider} object.  The channel will not be
connected.

<p> The {@link ProtocolFamily ProtocolFamily} of the channel's socket
is platform (and possibly configuration) dependent and therefore unspecified.
The {@link #open(ProtocolFamily) open} allows the protocol family to be
selected when opening a datagram channel, and should be used to open
datagram channels that are intended for Internet Protocol multicasting.

@return  A new datagram channel

@throws  IOException
         If an I/O error occurs
"
      end

      operation 7785346 "open"
	class_operation public return_type class_ref 964994 // DatagramChannel
	nparams 1
	  param inout name "family" type class_ref 969986 // ProtocolFamily
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Opens a datagram channel.

<p> The {@code family} parameter is used to specify the {@link
ProtocolFamily}. If the datagram channel is to be used for IP multicasting
then this should correspond to the address type of the multicast groups
that this channel will join.

<p> The new channel is created by invoking the {@link
java.nio.channels.spi.SelectorProvider#openDatagramChannel(ProtocolFamily)
openDatagramChannel} method of the system-wide default {@link
java.nio.channels.spi.SelectorProvider} object.  The channel will not be
connected.

@param   family
         The protocol family

@return  A new datagram channel

@throws  UnsupportedOperationException
         If the specified protocol family is not supported. For example,
         suppose the parameter is specified as {@link
         java.net.StandardProtocolFamily#INET6 StandardProtocolFamily.INET6}
         but IPv6 is not enabled on the platform.
@throws  IOException
         If an I/O error occurs

@since   1.7
"
      end

      operation 7785474 "validOps"
	public explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an operation set identifying this channel's supported
operations.

<p> Datagram channels support reading and writing, so this method
returns <tt>(</tt>{@link SelectionKey#OP_READ} <tt>|</tt>&nbsp;{@link
SelectionKey#OP_WRITE}<tt>)</tt>.  </p>

@return  The valid-operation set
"
      end

      operation 7785602 "bind"
	abstract public return_type class_ref 964994 // DatagramChannel
	nparams 1
	  param inout name "local" type class_ref 962178 // SocketAddress
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " -- Socket-specific operations --

@throws  AlreadyBoundException               {@inheritDoc}
@throws  UnsupportedAddressTypeException     {@inheritDoc}
@throws  ClosedChannelException              {@inheritDoc}
@throws  IOException                         {@inheritDoc}
@throws  SecurityException
         If a security manager has been installed and its {@link
         SecurityManager#checkListen checkListen} method denies the
         operation

@since 1.7
"
      end

      operation 7785730 "setOption"
	abstract public return_type class_ref 964994 // DatagramChannel
	nparams 2
	  param inout name "name" type class_ref 962434 // SocketOption
	  param inout name "value" explicit_type "T"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<T> ${type} ${name}${(}${t0}<T> ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "@throws  UnsupportedOperationException           {@inheritDoc}
@throws  IllegalArgumentException                {@inheritDoc}
@throws  ClosedChannelException                  {@inheritDoc}
@throws  IOException                             {@inheritDoc}

@since 1.7
"
      end

      operation 7785858 "socket"
	abstract public return_type class_ref 527234 // DatagramSocket
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Retrieves a datagram socket associated with this channel.

<p> The returned object will not declare any public methods that are not
declared in the {@link java.net.DatagramSocket} class.  </p>

@return  A datagram socket associated with this channel
"
      end

      operation 7785986 "isConnected"
	abstract public explicit_return_type "boolean"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Tells whether or not this channel's socket is connected.

@return  {@code true} if, and only if, this channel's socket
         is {@link #isOpen open} and connected
"
      end

      operation 7786114 "connect"
	abstract public return_type class_ref 964994 // DatagramChannel
	nparams 1
	  param inout name "remote" type class_ref 962178 // SocketAddress
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Connects this channel's socket.

<p> The channel's socket is configured so that it only receives
datagrams from, and sends datagrams to, the given remote <i>peer</i>
address.  Once connected, datagrams may not be received from or sent to
any other address.  A datagram socket remains connected until it is
explicitly disconnected or until it is closed.

<p> This method performs exactly the same security checks as the {@link
java.net.DatagramSocket#connect connect} method of the {@link
java.net.DatagramSocket} class.  That is, if a security manager has been
installed then this method verifies that its {@link
java.lang.SecurityManager#checkAccept checkAccept} and {@link
java.lang.SecurityManager#checkConnect checkConnect} methods permit
datagrams to be received from and sent to, respectively, the given
remote address.

<p> This method may be invoked at any time.  It will not have any effect
on read or write operations that are already in progress at the moment
that it is invoked. If this channel's socket is not bound then this method
will first cause the socket to be bound to an address that is assigned
automatically, as if invoking the {@link #bind bind} method with a
parameter of {@code null}. </p>

@param  remote
        The remote address to which this channel is to be connected

@return  This datagram channel

@throws  ClosedChannelException
         If this channel is closed

@throws  AsynchronousCloseException
         If another thread closes this channel
         while the connect operation is in progress

@throws  ClosedByInterruptException
         If another thread interrupts the current thread
         while the connect operation is in progress, thereby
         closing the channel and setting the current thread's
         interrupt status

@throws  SecurityException
         If a security manager has been installed
         and it does not permit access to the given remote address

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7786242 "disconnect"
	abstract public return_type class_ref 964994 // DatagramChannel
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Disconnects this channel's socket.

<p> The channel's socket is configured so that it can receive datagrams
from, and sends datagrams to, any remote address so long as the security
manager, if installed, permits it.

<p> This method may be invoked at any time.  It will not have any effect
on read or write operations that are already in progress at the moment
that it is invoked.

<p> If this channel's socket is not connected, or if the channel is
closed, then invoking this method has no effect.  </p>

@return  This datagram channel

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7786370 "getRemoteAddress"
	abstract public return_type class_ref 962178 // SocketAddress
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the remote address to which this channel's socket is connected.

@return  The remote address; {@code null} if the channel's socket is not
         connected

@throws  ClosedChannelException
         If the channel is closed
@throws  IOException
         If an I/O error occurs

@since 1.7
"
      end

      operation 7786498 "receive"
	abstract public return_type class_ref 962178 // SocketAddress
	nparams 1
	  param inout name "dst" type class_ref 149890 // ByteBuffer
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Receives a datagram via this channel.

<p> If a datagram is immediately available, or if this channel is in
blocking mode and one eventually becomes available, then the datagram is
copied into the given byte buffer and its source address is returned.
If this channel is in non-blocking mode and a datagram is not
immediately available then this method immediately returns
<tt>null</tt>.

<p> The datagram is transferred into the given byte buffer starting at
its current position, as if by a regular {@link
ReadableByteChannel#read(java.nio.ByteBuffer) read} operation.  If there
are fewer bytes remaining in the buffer than are required to hold the
datagram then the remainder of the datagram is silently discarded.

<p> This method performs exactly the same security checks as the {@link
java.net.DatagramSocket#receive receive} method of the {@link
java.net.DatagramSocket} class.  That is, if the socket is not connected
to a specific remote address and a security manager has been installed
then for each datagram received this method verifies that the source's
address and port number are permitted by the security manager's {@link
java.lang.SecurityManager#checkAccept checkAccept} method.  The overhead
of this security check can be avoided by first connecting the socket via
the {@link #connect connect} method.

<p> This method may be invoked at any time.  If another thread has
already initiated a read operation upon this channel, however, then an
invocation of this method will block until the first operation is
complete. If this channel's socket is not bound then this method will
first cause the socket to be bound to an address that is assigned
automatically, as if invoking the {@link #bind bind} method with a
parameter of {@code null}. </p>

@param  dst
        The buffer into which the datagram is to be transferred

@return  The datagram's source address,
         or <tt>null</tt> if this channel is in non-blocking mode
         and no datagram was immediately available

@throws  ClosedChannelException
         If this channel is closed

@throws  AsynchronousCloseException
         If another thread closes this channel
         while the read operation is in progress

@throws  ClosedByInterruptException
         If another thread interrupts the current thread
         while the read operation is in progress, thereby
         closing the channel and setting the current thread's
         interrupt status

@throws  SecurityException
         If a security manager has been installed
         and it does not permit datagrams to be accepted
         from the datagram's sender

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7786626 "send"
	abstract public explicit_return_type "int"
	nparams 2
	  param inout name "src" type class_ref 149890 // ByteBuffer
	  param inout name "target" type class_ref 962178 // SocketAddress
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sends a datagram via this channel.

<p> If this channel is in non-blocking mode and there is sufficient room
in the underlying output buffer, or if this channel is in blocking mode
and sufficient room becomes available, then the remaining bytes in the
given buffer are transmitted as a single datagram to the given target
address.

<p> The datagram is transferred from the byte buffer as if by a regular
{@link WritableByteChannel#write(java.nio.ByteBuffer) write} operation.

<p> This method performs exactly the same security checks as the {@link
java.net.DatagramSocket#send send} method of the {@link
java.net.DatagramSocket} class.  That is, if the socket is not connected
to a specific remote address and a security manager has been installed
then for each datagram sent this method verifies that the target address
and port number are permitted by the security manager's {@link
java.lang.SecurityManager#checkConnect checkConnect} method.  The
overhead of this security check can be avoided by first connecting the
socket via the {@link #connect connect} method.

<p> This method may be invoked at any time.  If another thread has
already initiated a write operation upon this channel, however, then an
invocation of this method will block until the first operation is
complete. If this channel's socket is not bound then this method will
first cause the socket to be bound to an address that is assigned
automatically, as if by invoking the {@link #bind bind} method with a
parameter of {@code null}. </p>

@param  src
        The buffer containing the datagram to be sent

@param  target
        The address to which the datagram is to be sent

@return   The number of bytes sent, which will be either the number
          of bytes that were remaining in the source buffer when this
          method was invoked or, if this channel is non-blocking, may be
          zero if there was insufficient room for the datagram in the
          underlying output buffer

@throws  ClosedChannelException
         If this channel is closed

@throws  AsynchronousCloseException
         If another thread closes this channel
         while the read operation is in progress

@throws  ClosedByInterruptException
         If another thread interrupts the current thread
         while the read operation is in progress, thereby
         closing the channel and setting the current thread's
         interrupt status

@throws  SecurityException
         If a security manager has been installed
         and it does not permit datagrams to be sent
         to the given address

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7786754 "read"
	abstract public explicit_return_type "int"
	nparams 1
	  param inout name "dst" type class_ref 149890 // ByteBuffer
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " -- ByteChannel operations --

Reads a datagram from this channel.

<p> This method may only be invoked if this channel's socket is
connected, and it only accepts datagrams from the socket's peer.  If
there are more bytes in the datagram than remain in the given buffer
then the remainder of the datagram is silently discarded.  Otherwise
this method behaves exactly as specified in the {@link
ReadableByteChannel} interface.  </p>

@throws  NotYetConnectedException
         If this channel's socket is not connected
"
      end

      operation 7786882 "read"
	abstract public explicit_return_type "long"
	nparams 3
	  param inout name "dsts" type class_ref 149890 // ByteBuffer
	multiplicity "[]"
	  param in name "offset" explicit_type "int"
	  param in name "length" explicit_type "int"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0}[] ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Reads a datagram from this channel.

<p> This method may only be invoked if this channel's socket is
connected, and it only accepts datagrams from the socket's peer.  If
there are more bytes in the datagram than remain in the given buffers
then the remainder of the datagram is silently discarded.  Otherwise
this method behaves exactly as specified in the {@link
ScatteringByteChannel} interface.  </p>

@throws  NotYetConnectedException
         If this channel's socket is not connected
"
      end

      operation 7787010 "read"
	public explicit_return_type "long"
	nparams 1
	  param inout name "dsts" type class_ref 149890 // ByteBuffer
	multiplicity "[]"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0}[] ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Reads a datagram from this channel.

<p> This method may only be invoked if this channel's socket is
connected, and it only accepts datagrams from the socket's peer.  If
there are more bytes in the datagram than remain in the given buffers
then the remainder of the datagram is silently discarded.  Otherwise
this method behaves exactly as specified in the {@link
ScatteringByteChannel} interface.  </p>

@throws  NotYetConnectedException
         If this channel's socket is not connected
"
      end

      operation 7787138 "write"
	abstract public explicit_return_type "int"
	nparams 1
	  param inout name "src" type class_ref 149890 // ByteBuffer
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Writes a datagram to this channel.

<p> This method may only be invoked if this channel's socket is
connected, in which case it sends datagrams directly to the socket's
peer.  Otherwise it behaves exactly as specified in the {@link
WritableByteChannel} interface.  </p>

@throws  NotYetConnectedException
         If this channel's socket is not connected
"
      end

      operation 7787266 "write"
	abstract public explicit_return_type "long"
	nparams 3
	  param inout name "srcs" type class_ref 149890 // ByteBuffer
	multiplicity "[]"
	  param in name "offset" explicit_type "int"
	  param in name "length" explicit_type "int"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0}[] ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Writes a datagram to this channel.

<p> This method may only be invoked if this channel's socket is
connected, in which case it sends datagrams directly to the socket's
peer.  Otherwise it behaves exactly as specified in the {@link
GatheringByteChannel} interface.  </p>

@return   The number of bytes sent, which will be either the number
          of bytes that were remaining in the source buffer when this
          method was invoked or, if this channel is non-blocking, may be
          zero if there was insufficient room for the datagram in the
          underlying output buffer

@throws  NotYetConnectedException
         If this channel's socket is not connected
"
      end

      operation 7787394 "write"
	public explicit_return_type "long"
	nparams 1
	  param inout name "srcs" type class_ref 149890 // ByteBuffer
	multiplicity "[]"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0}[] ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Writes a datagram to this channel.

<p> This method may only be invoked if this channel's socket is
connected, in which case it sends datagrams directly to the socket's
peer.  Otherwise it behaves exactly as specified in the {@link
GatheringByteChannel} interface.  </p>

@return   The number of bytes sent, which will be either the number
          of bytes that were remaining in the source buffer when this
          method was invoked or, if this channel is non-blocking, may be
          zero if there was insufficient room for the datagram in the
          underlying output buffer

@throws  NotYetConnectedException
         If this channel's socket is not connected
"
      end

      operation 7787522 "getLocalAddress"
	abstract public return_type class_ref 962178 // SocketAddress
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
	comment "{@inheritDoc}
<p>
If there is a security manager set, its {@code checkConnect} method is
called with the local address and {@code -1} as its arguments to see
if the operation is allowed. If the operation is not allowed,
a {@code SocketAddress} representing the
{@link java.net.InetAddress#getLoopbackAddress loopback} address and the
local port of the channel's socket is returned.

@return  The {@code SocketAddress} that the socket is bound to, or the
         {@code SocketAddress} representing the loopback address if
         denied by the security manager, or {@code null} if the
         channel's socket is not bound

@throws  ClosedChannelException     {@inheritDoc}
@throws  IOException                {@inheritDoc}
"
      end
    end

    class 983938 "AcceptPendingException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when an attempt is made to initiate an accept
operation on a channel and a previous accept operation has not completed.

@since 1.7
"
      classrelation 3289474 // <generalisation>
	relation 3289474 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3289474 // <generalisation>
	  b parent class_ref 254850 // IllegalStateException
      end

      attribute 1807618 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 2721339977965416421L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7767042 "AcceptPendingException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 984066 "AlreadyBoundException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when an attempt is made to bind the socket a
network oriented channel that is already bound.

@since 1.7
"
      classrelation 3289602 // <generalisation>
	relation 3289602 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3289602 // <generalisation>
	  b parent class_ref 254850 // IllegalStateException
      end

      attribute 1807746 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 6796072983322737592L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7767170 "AlreadyBoundException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 984194 "AlreadyConnectedException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when an attempt is made to connect a {@link
SocketChannel} that is already connected.

@since 1.4
"
      classrelation 3289730 // <generalisation>
	relation 3289730 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3289730 // <generalisation>
	  b parent class_ref 254850 // IllegalStateException
      end

      attribute 1807874 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " -7331895245053773357L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7767298 "AlreadyConnectedException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 984322 "AsynchronousByteChannel"
      visibility public stereotype "interface"
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "An asynchronous channel that can read and write bytes.

<p> Some channels may not allow more than one read or write to be outstanding
at any given time. If a thread invokes a read method before a previous read
operation has completed then a {@link ReadPendingException} will be thrown.
Similarly, if a write method is invoked before a previous write has completed
then {@link WritePendingException} is thrown. Whether or not other kinds of
I/O operations may proceed concurrently with a read operation depends upon
the type of the channel.

<p> Note that {@link java.nio.ByteBuffer ByteBuffers} are not safe for use by
multiple concurrent threads. When a read or write operation is initiated then
care must be taken to ensure that the buffer is not accessed until the
operation completes.

@see Channels#newInputStream(AsynchronousByteChannel)
@see Channels#newOutputStream(AsynchronousByteChannel)

@since 1.7
"
      classrelation 3290114 // <generalisation>
	relation 3290114 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3290114 // <generalisation>
	  b parent class_ref 984450 // AsynchronousChannel
      end

      operation 7767810 "read"
	public explicit_return_type "void"
	nparams 3
	  param inout name "dst" type class_ref 149890 // ByteBuffer
	  param inout name "attachment" explicit_type "A"
	  param inout name "handler" type class_ref 984578 // CompletionHandler
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<A> ${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2}<Integer,? super A> ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Reads a sequence of bytes from this channel into the given buffer.

<p> This method initiates an asynchronous read operation to read a
sequence of bytes from this channel into the given buffer. The {@code
handler} parameter is a completion handler that is invoked when the read
operation completes (or fails). The result passed to the completion
handler is the number of bytes read or {@code -1} if no bytes could be
read because the channel has reached end-of-stream.

<p> The read operation may read up to <i>r</i> bytes from the channel,
where <i>r</i> is the number of bytes remaining in the buffer, that is,
{@code dst.remaining()} at the time that the read is attempted. Where
<i>r</i> is 0, the read operation completes immediately with a result of
{@code 0} without initiating an I/O operation.

<p> Suppose that a byte sequence of length <i>n</i> is read, where
<tt>0</tt>&nbsp;<tt>&lt;</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
This byte sequence will be transferred into the buffer so that the first
byte in the sequence is at index <i>p</i> and the last byte is at index
<i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i>&nbsp;<tt>-</tt>&nbsp;<tt>1</tt>,
where <i>p</i> is the buffer's position at the moment the read is
performed. Upon completion the buffer's position will be equal to
<i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i>; its limit will not have changed.

<p> Buffers are not safe for use by multiple concurrent threads so care
should be taken to not access the buffer until the operation has
completed.

<p> This method may be invoked at any time. Some channel types may not
allow more than one read to be outstanding at any given time. If a thread
initiates a read operation before a previous read operation has
completed then a {@link ReadPendingException} will be thrown.

@param   <A>
         The type of the attachment
@param   dst
         The buffer into which bytes are to be transferred
@param   attachment
         The object to attach to the I/O operation; can be {@code null}
@param   handler
         The completion handler

@throws  IllegalArgumentException
         If the buffer is read-only
@throws  ReadPendingException
         If the channel does not allow more than one read to be outstanding
         and a previous read has not completed
@throws  ShutdownChannelGroupException
         If the channel is associated with a {@link AsynchronousChannelGroup
         group} that has terminated
"
      end

      operation 7767938 "read"
	public return_type class_ref 984706 // Future
	nparams 1
	  param inout name "dst" type class_ref 149890 // ByteBuffer
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Integer> ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Reads a sequence of bytes from this channel into the given buffer.

<p> This method initiates an asynchronous read operation to read a
sequence of bytes from this channel into the given buffer. The method
behaves in exactly the same manner as the {@link
#read(ByteBuffer,Object,CompletionHandler)
read(ByteBuffer,Object,CompletionHandler)} method except that instead
of specifying a completion handler, this method returns a {@code Future}
representing the pending result. The {@code Future}'s {@link Future#get()
get} method returns the number of bytes read or {@code -1} if no bytes
could be read because the channel has reached end-of-stream.

@param   dst
         The buffer into which bytes are to be transferred

@return  A Future representing the result of the operation

@throws  IllegalArgumentException
         If the buffer is read-only
@throws  ReadPendingException
         If the channel does not allow more than one read to be outstanding
         and a previous read has not completed
"
      end

      operation 7768066 "write"
	public explicit_return_type "void"
	nparams 3
	  param inout name "src" type class_ref 149890 // ByteBuffer
	  param inout name "attachment" explicit_type "A"
	  param inout name "handler" type class_ref 984578 // CompletionHandler
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<A> ${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2}<Integer,? super A> ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Writes a sequence of bytes to this channel from the given buffer.

<p> This method initiates an asynchronous write operation to write a
sequence of bytes to this channel from the given buffer. The {@code
handler} parameter is a completion handler that is invoked when the write
operation completes (or fails). The result passed to the completion
handler is the number of bytes written.

<p> The write operation may write up to <i>r</i> bytes to the channel,
where <i>r</i> is the number of bytes remaining in the buffer, that is,
{@code src.remaining()} at the time that the write is attempted. Where
<i>r</i> is 0, the write operation completes immediately with a result of
{@code 0} without initiating an I/O operation.

<p> Suppose that a byte sequence of length <i>n</i> is written, where
<tt>0</tt>&nbsp;<tt>&lt;</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
This byte sequence will be transferred from the buffer starting at index
<i>p</i>, where <i>p</i> is the buffer's position at the moment the
write is performed; the index of the last byte written will be
<i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i>&nbsp;<tt>-</tt>&nbsp;<tt>1</tt>.
Upon completion the buffer's position will be equal to
<i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i>; its limit will not have changed.

<p> Buffers are not safe for use by multiple concurrent threads so care
should be taken to not access the buffer until the operation has
completed.

<p> This method may be invoked at any time. Some channel types may not
allow more than one write to be outstanding at any given time. If a thread
initiates a write operation before a previous write operation has
completed then a {@link WritePendingException} will be thrown.

@param   <A>
         The type of the attachment
@param   src
         The buffer from which bytes are to be retrieved
@param   attachment
         The object to attach to the I/O operation; can be {@code null}
@param   handler
         The completion handler object

@throws  WritePendingException
         If the channel does not allow more than one write to be outstanding
         and a previous write has not completed
@throws  ShutdownChannelGroupException
         If the channel is associated with a {@link AsynchronousChannelGroup
         group} that has terminated
"
      end

      operation 7768194 "write"
	public return_type class_ref 984706 // Future
	nparams 1
	  param inout name "src" type class_ref 149890 // ByteBuffer
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Integer> ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Writes a sequence of bytes to this channel from the given buffer.

<p> This method initiates an asynchronous write operation to write a
sequence of bytes to this channel from the given buffer. The method
behaves in exactly the same manner as the {@link
#write(ByteBuffer,Object,CompletionHandler)
write(ByteBuffer,Object,CompletionHandler)} method except that instead
of specifying a completion handler, this method returns a {@code Future}
representing the pending result. The {@code Future}'s {@link Future#get()
get} method returns the number of bytes written.

@param   src
         The buffer from which bytes are to be retrieved

@return A Future representing the result of the operation

@throws  WritePendingException
         If the channel does not allow more than one write to be outstanding
         and a previous write has not completed
"
      end
    end

    class 984450 "AsynchronousChannel"
      visibility public stereotype "interface"
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A channel that supports asynchronous I/O operations. Asynchronous I/O
operations will usually take one of two forms:

<ol>
<li><pre>{@link Future}&lt;V&gt; <em>operation</em>(<em>...</em>)</pre></li>
<li><pre>void <em>operation</em>(<em>...</em> A attachment, {@link
  CompletionHandler}&lt;V,? super A&gt; handler)</pre></li>
</ol>

where <i>operation</i> is the name of the I/O operation (read or write for
example), <i>V</i> is the result type of the I/O operation, and <i>A</i> is
the type of an object attached to the I/O operation to provide context when
consuming the result. The attachment is important for cases where a
<em>state-less</em> {@code CompletionHandler} is used to consume the result
of many I/O operations.

<p> In the first form, the methods defined by the {@link Future Future}
interface may be used to check if the operation has completed, wait for its
completion, and to retrieve the result. In the second form, a {@link
CompletionHandler} is invoked to consume the result of the I/O operation when
it completes or fails.

<p> A channel that implements this interface is <em>asynchronously
closeable</em>: If an I/O operation is outstanding on the channel and the
channel's {@link #close close} method is invoked, then the I/O operation
fails with the exception {@link AsynchronousCloseException}.

<p> Asynchronous channels are safe for use by multiple concurrent threads.
Some channel implementations may support concurrent reading and writing, but
may not allow more than one read and one write operation to be outstanding at
any given time.

<h2>Cancellation</h2>

<p> The {@code Future} interface defines the {@link Future#cancel cancel}
method to cancel execution. This causes all threads waiting on the result of
the I/O operation to throw {@link java.util.concurrent.CancellationException}.
Whether the underlying I/O operation can be cancelled is highly implementation
specific and therefore not specified. Where cancellation leaves the channel,
or the entity to which it is connected, in an inconsistent state, then the
channel is put into an implementation specific <em>error state</em> that
prevents further attempts to initiate I/O operations that are <i>similar</i>
to the operation that was cancelled. For example, if a read operation is
cancelled but the implementation cannot guarantee that bytes have not been
read from the channel then it puts the channel into an error state; further
attempts to initiate a {@code read} operation cause an unspecified runtime
exception to be thrown. Similarly, if a write operation is cancelled but the
implementation cannot guarantee that bytes have not been written to the
channel then subsequent attempts to initiate a {@code write} will fail with
an unspecified runtime exception.

<p> Where the {@link Future#cancel cancel} method is invoked with the {@code
mayInterruptIfRunning} parameter set to {@code true} then the I/O operation
may be interrupted by closing the channel. In that case all threads waiting
on the result of the I/O operation throw {@code CancellationException} and
any other I/O operations outstanding on the channel complete with the
exception {@link AsynchronousCloseException}.

<p> Where the {@code cancel} method is invoked to cancel read or write
operations then it is recommended that all buffers used in the I/O operations
be discarded or care taken to ensure that the buffers are not accessed while
the channel remains open.

 @since 1.7
"
      classrelation 3289986 // <generalisation>
	relation 3289986 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3289986 // <generalisation>
	  b parent class_ref 940034 // Channel
      end

      operation 7767682 "close"
	public explicit_return_type "void"
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
	comment "Closes this channel.

<p> Any outstanding asynchronous operations upon this channel will
complete with the exception {@link AsynchronousCloseException}. After a
channel is closed, further attempts to initiate asynchronous I/O
operations complete immediately with cause {@link ClosedChannelException}.

<p>  This method otherwise behaves exactly as specified by the {@link
Channel} interface.

@throws  IOException
         If an I/O error occurs
"
      end
    end

    class 984578 "CompletionHandler"
      visibility public stereotype "interface"
      nformals 2
      formal name "V" type "" explicit_default_value ""
        explicit_extends ""
      formal name "A" type "" explicit_default_value ""
        explicit_extends ""
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A handler for consuming the result of an asynchronous I/O operation.

<p> The asynchronous channels defined in this package allow a completion
handler to be specified to consume the result of an asynchronous operation.
The {@link #completed completed} method is invoked when the I/O operation
completes successfully. The {@link #failed failed} method is invoked if the
I/O operations fails. The implementations of these methods should complete
in a timely manner so as to avoid keeping the invoking thread from dispatching
to other completion handlers.

@param   <V>     The result type of the I/O operation
@param   <A>     The type of the object attached to the I/O operation

@since 1.7
"
      operation 7780610 "completed"
	cpp_inline public explicit_return_type "void"
	nparams 2
	  param inout name "result" explicit_type "V"
	  param inout name "attachment" explicit_type "A"
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Invoked when an operation has completed.

@param   result
         The result of the I/O operation.
@param   attachment
         The object attached to the I/O operation when it was initiated.
"
      end

      operation 7780738 "failed"
	cpp_inline public explicit_return_type "void"
	nparams 2
	  param inout name "exc" type class_ref 129922 // Throwable
	  param inout name "attachment" explicit_type "A"
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Invoked when an operation fails.

@param   exc
         The exception to indicate why the I/O operation failed
@param   attachment
         The object attached to the I/O operation when it was initiated.
"
      end
    end

    class 984834 "AsynchronousChannelGroup"
      abstract visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A grouping of asynchronous channels for the purpose of resource sharing.

<p> An asynchronous channel group encapsulates the mechanics required to
handle the completion of I/O operations initiated by {@link AsynchronousChannel
asynchronous channels} that are bound to the group. A group has an associated
thread pool to which tasks are submitted to handle I/O events and dispatch to
{@link CompletionHandler completion-handlers} that consume the result of
asynchronous operations performed on channels in the group. In addition to
handling I/O events, the pooled threads may also execute other tasks required
to support the execution of asynchronous I/O operations.

<p> An asynchronous channel group is created by invoking the {@link
#withFixedThreadPool withFixedThreadPool} or {@link #withCachedThreadPool
withCachedThreadPool} methods defined here. Channels are bound to a group by
specifying the group when constructing the channel. The associated thread
pool is <em>owned</em> by the group; termination of the group results in the
shutdown of the associated thread pool.

<p> In addition to groups created explicitly, the Java virtual machine
maintains a system-wide <em>default group</em> that is constructed
automatically. Asynchronous channels that do not specify a group at
construction time are bound to the default group. The default group has an
associated thread pool that creates new threads as needed. The default group
may be configured by means of system properties defined in the table below.
Where the {@link java.util.concurrent.ThreadFactory ThreadFactory} for the
default group is not configured then the pooled threads of the default group
are {@link Thread#isDaemon daemon} threads.

<table border summary=\"System properties\">
  <tr>
    <th>System property</th>
    <th>Description</th>
  </tr>
  <tr>
    <td> {@code java.nio.channels.DefaultThreadPool.threadFactory} </td>
    <td> The value of this property is taken to be the fully-qualified name
    of a concrete {@link java.util.concurrent.ThreadFactory ThreadFactory}
    class. The class is loaded using the system class loader and instantiated.
    The factory's {@link java.util.concurrent.ThreadFactory#newThread
    newThread} method is invoked to create each thread for the default
    group's thread pool. If the process to load and instantiate the value
    of the property fails then an unspecified error is thrown during the
    construction of the default group. </td>
  </tr>
  <tr>
    <td> {@code java.nio.channels.DefaultThreadPool.initialSize} </td>
    <td> The value of the {@code initialSize} parameter for the default
    group (see {@link #withCachedThreadPool withCachedThreadPool}).
    The value of the property is taken to be the {@code String}
    representation of an {@code Integer} that is the initial size parameter.
    If the value cannot be parsed as an {@code Integer} it causes an
    unspecified error to be thrown during the construction of the default
    group. </td>
  </tr>
</table>

<a name=\"threading\"></a><h2>Threading</h2>

<p> The completion handler for an I/O operation initiated on a channel bound
to a group is guaranteed to be invoked by one of the pooled threads in the
group. This ensures that the completion handler is run by a thread with the
expected <em>identity</em>.

<p> Where an I/O operation completes immediately, and the initiating thread
is one of the pooled threads in the group then the completion handler may
be invoked directly by the initiating thread. To avoid stack overflow, an
implementation may impose a limit as to the number of activations on the
thread stack. Some I/O operations may prohibit invoking the completion
handler directly by the initiating thread (see {@link
AsynchronousServerSocketChannel#accept(Object,CompletionHandler) accept}).

<a name=\"shutdown\"></a><h2>Shutdown and Termination</h2>

<p> The {@link #shutdown() shutdown} method is used to initiate an <em>orderly
shutdown</em> of a group. An orderly shutdown marks the group as shutdown;
further attempts to construct a channel that binds to the group will throw
{@link ShutdownChannelGroupException}. Whether or not a group is shutdown can
be tested using the {@link #isShutdown() isShutdown} method. Once shutdown,
the group <em>terminates</em> when all asynchronous channels that are bound to
the group are closed, all actively executing completion handlers have run to
completion, and resources used by the group are released. No attempt is made
to stop or interrupt threads that are executing completion handlers. The
{@link #isTerminated() isTerminated} method is used to test if the group has
terminated, and the {@link #awaitTermination awaitTermination} method can be
used to block until the group has terminated.

<p> The {@link #shutdownNow() shutdownNow} method can be used to initiate a
<em>forceful shutdown</em> of the group. In addition to the actions performed
by an orderly shutdown, the {@code shutdownNow} method closes all open channels
in the group as if by invoking the {@link AsynchronousChannel#close close}
method.

@since 1.7

@see AsynchronousSocketChannel#open(AsynchronousChannelGroup)
@see AsynchronousServerSocketChannel#open(AsynchronousChannelGroup)
"
      classrelation 3290242 // provider (<unidirectional association>)
	relation 3290242 --->
	  a role_name "provider" const_relation private
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 3290242 // provider (<unidirectional association>)
	  b parent class_ref 984962 // AsynchronousChannelProvider
      end

      operation 7768322 "AsynchronousChannelGroup"
	protected explicit_return_type ""
	nparams 1
	  param inout name "provider" type class_ref 984962 // AsynchronousChannelProvider
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Initialize a new instance of this class.

@param   provider
         The asynchronous channel provider for this group
"
      end

      operation 7768450 "provider"
	public return_type class_ref 984962 // AsynchronousChannelProvider
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the provider that created this channel group.

@return  The provider that created this channel group
"
      end

      operation 7768578 "withFixedThreadPool"
	class_operation public return_type class_ref 984834 // AsynchronousChannelGroup
	nparams 2
	  param in name "nThreads" explicit_type "int"
	  param inout name "threadFactory" type class_ref 985090 // ThreadFactory
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates an asynchronous channel group with a fixed thread pool.

<p> The resulting asynchronous channel group reuses a fixed number of
threads. At any point, at most {@code nThreads} threads will be active
processing tasks that are submitted to handle I/O events and dispatch
completion results for operations initiated on asynchronous channels in
the group.

<p> The group is created by invoking the {@link
AsynchronousChannelProvider#openAsynchronousChannelGroup(int,ThreadFactory)
openAsynchronousChannelGroup(int,ThreadFactory)} method of the system-wide
default {@link AsynchronousChannelProvider} object.

@param   nThreads
         The number of threads in the pool
@param   threadFactory
         The factory to use when creating new threads

@return  A new asynchronous channel group

@throws  IllegalArgumentException
         If {@code nThreads <= 0}
@throws  IOException
         If an I/O error occurs
"
      end

      operation 7768706 "withCachedThreadPool"
	class_operation public return_type class_ref 984834 // AsynchronousChannelGroup
	nparams 2
	  param inout name "executor" type class_ref 985218 // ExecutorService
	  param in name "initialSize" explicit_type "int"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates an asynchronous channel group with a given thread pool that
creates new threads as needed.

<p> The {@code executor} parameter is an {@code ExecutorService} that
creates new threads as needed to execute tasks that are submitted to
handle I/O events and dispatch completion results for operations initiated
on asynchronous channels in the group. It may reuse previously constructed
threads when they are available.

<p> The {@code initialSize} parameter may be used by the implementation
as a <em>hint</em> as to the initial number of tasks it may submit. For
example, it may be used to indicate the initial number of threads that
wait on I/O events.

<p> The executor is intended to be used exclusively by the resulting
asynchronous channel group. Termination of the group results in the
orderly  {@link ExecutorService#shutdown shutdown} of the executor
service. Shutting down the executor service by other means results in
unspecified behavior.

<p> The group is created by invoking the {@link
AsynchronousChannelProvider#openAsynchronousChannelGroup(ExecutorService,int)
openAsynchronousChannelGroup(ExecutorService,int)} method of the system-wide
default {@link AsynchronousChannelProvider} object.

@param   executor
         The thread pool for the resulting group
@param   initialSize
         A value {@code >=0} or a negative value for implementation
         specific default

@return  A new asynchronous channel group

@throws  IOException
         If an I/O error occurs

@see java.util.concurrent.Executors#newCachedThreadPool
"
      end

      operation 7768834 "withThreadPool"
	class_operation public return_type class_ref 984834 // AsynchronousChannelGroup
	nparams 1
	  param inout name "executor" type class_ref 985218 // ExecutorService
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates an asynchronous channel group with a given thread pool.

<p> The {@code executor} parameter is an {@code ExecutorService} that
executes tasks submitted to dispatch completion results for operations
initiated on asynchronous channels in the group.

<p> Care should be taken when configuring the executor service. It
should support <em>direct handoff</em> or <em>unbounded queuing</em> of
submitted tasks, and the thread that invokes the {@link
ExecutorService#execute execute} method should never invoke the task
directly. An implementation may mandate additional constraints.

<p> The executor is intended to be used exclusively by the resulting
asynchronous channel group. Termination of the group results in the
orderly  {@link ExecutorService#shutdown shutdown} of the executor
service. Shutting down the executor service by other means results in
unspecified behavior.

<p> The group is created by invoking the {@link
AsynchronousChannelProvider#openAsynchronousChannelGroup(ExecutorService,int)
openAsynchronousChannelGroup(ExecutorService,int)} method of the system-wide
default {@link AsynchronousChannelProvider} object with an {@code
initialSize} of {@code 0}.

@param   executor
         The thread pool for the resulting group

@return  A new asynchronous channel group

@throws  IOException
         If an I/O error occurs
"
      end

      operation 7768962 "isShutdown"
	abstract public explicit_return_type "boolean"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Tells whether or not this asynchronous channel group is shutdown.

@return  {@code true} if this asynchronous channel group is shutdown or
         has been marked for shutdown.
"
      end

      operation 7769090 "isTerminated"
	abstract public explicit_return_type "boolean"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Tells whether or not this group has terminated.

<p> Where this method returns {@code true}, then the associated thread
pool has also {@link ExecutorService#isTerminated terminated}.

@return  {@code true} if this group has terminated
"
      end

      operation 7769218 "shutdown"
	abstract public explicit_return_type "void"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Initiates an orderly shutdown of the group.

<p> This method marks the group as shutdown. Further attempts to construct
channel that binds to this group will throw {@link ShutdownChannelGroupException}.
The group terminates when all asynchronous channels in the group are
closed, all actively executing completion handlers have run to completion,
and all resources have been released. This method has no effect if the
group is already shutdown.
"
      end

      operation 7769346 "shutdownNow"
	abstract public explicit_return_type "void"
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Shuts down the group and closes all open channels in the group.

<p> In addition to the actions performed by the {@link #shutdown() shutdown}
method, this method invokes the {@link AsynchronousChannel#close close}
method on all open channels in the group. This method does not attempt to
stop or interrupt threads that are executing completion handlers. The
group terminates when all actively executing completion handlers have run
to completion and all resources have been released. This method may be
invoked at any time. If some other thread has already invoked it, then
another invocation will block until the first invocation is complete,
after which it will return without effect.

@throws  IOException
         If an I/O error occurs
"
      end

      operation 7769474 "awaitTermination"
	abstract public explicit_return_type "boolean"
	nparams 2
	  param in name "timeout" explicit_type "long"
	  param inout name "unit" type class_ref 935938 // TimeUnit
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Awaits termination of the group.

<p> This method blocks until the group has terminated, or the timeout
occurs, or the current thread is interrupted, whichever happens first.

@param   timeout
         The maximum time to wait, or zero or less to not wait
@param   unit
         The time unit of the timeout argument

@return  {@code true} if the group has terminated; {@code false} if the
         timeout elapsed before termination

@throws  InterruptedException
         If interrupted while waiting
"
      end
    end

    class 985346 "AsynchronousCloseException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Checked exception received by a thread when another thread closes the
channel or the part of the channel upon which it is blocked in an I/O
operation.

@since 1.4
"
      classrelation 3290498 // <generalisation>
	relation 3290498 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3290498 // <generalisation>
	  b parent class_ref 985474 // ClosedChannelException
      end

      attribute 1808130 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 6891178312432313966L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7769730 "AsynchronousCloseException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 985474 "ClosedChannelException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Checked exception thrown when an attempt is made to invoke or complete an
I/O operation upon channel that is closed, or at least closed to that
operation.  That this exception is thrown does not necessarily imply that
the channel is completely closed.  A socket channel whose write half has
been shut down, for example, may still be open for reading.

@since 1.4
"
      classrelation 3290370 // <generalisation>
	relation 3290370 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3290370 // <generalisation>
	  b parent class_ref 146818 // IOException
      end

      attribute 1808002 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 882777185433553857L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7769602 "ClosedChannelException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 985602 "AsynchronousFileChannel"
      abstract visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "An asynchronous channel for reading, writing, and manipulating a file.

<p> An asynchronous file channel is created when a file is opened by invoking
one of the {@link #open open} methods defined by this class. The file contains
a variable-length sequence of bytes that can be read and written and whose
current size can be {@link #size() queried}. The size of the file increases
when bytes are written beyond its  current size; the size of the file decreases
when it is {@link #truncate truncated}.

<p> An asynchronous file channel does not have a <i>current position</i>
within the file. Instead, the file position is specified to each read and
write method that initiates asynchronous operations. A {@link CompletionHandler}
is specified as a parameter and is invoked to consume the result of the I/O
operation. This class also defines read and write methods that initiate
asynchronous operations, returning a {@link Future} to represent the pending
result of the operation. The {@code Future} may be used to check if the
operation has completed, wait for its completion, and retrieve the result.

<p> In addition to read and write operations, this class defines the
following operations: </p>

<ul>

  <li><p> Updates made to a file may be {@link #force <i>forced
  out</i>} to the underlying storage device, ensuring that data are not
  lost in the event of a system crash.  </p></li>

  <li><p> A region of a file may be {@link #lock <i>locked</i>} against
  access by other programs.  </p></li>

</ul>

<p> An {@code AsynchronousFileChannel} is associated with a thread pool to
which tasks are submitted to handle I/O events and dispatch to completion
handlers that consume the results of I/O operations on the channel. The
completion handler for an I/O operation initiated on a channel is guaranteed
to be invoked by one of the threads in the thread pool (This ensures that the
completion handler is run by a thread with the expected <em>identity</em>).
Where an I/O operation completes immediately, and the initiating thread is
itself a thread in the thread pool, then the completion handler may be invoked
directly by the initiating thread. When an {@code AsynchronousFileChannel} is
created without specifying a thread pool then the channel is associated with
a system-dependent default thread pool that may be shared with other
channels. The default thread pool is configured by the system properties
defined by the {@link AsynchronousChannelGroup} class.

<p> Channels of this type are safe for use by multiple concurrent threads. The
{@link Channel#close close} method may be invoked at any time, as specified
by the {@link Channel} interface. This causes all outstanding asynchronous
operations on the channel to complete with the exception {@link
AsynchronousCloseException}. Multiple read and write operations may be
outstanding at the same time. When multiple read and write operations are
outstanding then the ordering of the I/O operations, and the order that the
completion handlers are invoked, is not specified; they are not, in particular,
guaranteed to execute in the order that the operations were initiated. The
{@link java.nio.ByteBuffer ByteBuffers} used when reading or writing are not
safe for use by multiple concurrent I/O operations. Furthermore, after an I/O
operation is initiated then care should be taken to ensure that the buffer is
not accessed until after the operation has completed.

<p> As with {@link FileChannel}, the view of a file provided by an instance of
this class is guaranteed to be consistent with other views of the same file
provided by other instances in the same program.  The view provided by an
instance of this class may or may not, however, be consistent with the views
seen by other concurrently-running programs due to caching performed by the
underlying operating system and delays induced by network-filesystem protocols.
This is true regardless of the language in which these other programs are
written, and whether they are running on the same machine or on some other
machine.  The exact nature of any such inconsistencies are system-dependent
and are therefore unspecified.

@since 1.7
"
      classrelation 3290626 // <realization>
	relation 3290626 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3290626 // <realization>
	  b parent class_ref 984450 // AsynchronousChannel
      end

      operation 7769858 "AsynchronousFileChannel"
	protected explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Initializes a new instance of this class.
"
      end

      operation 7769986 "open"
	class_operation public return_type class_ref 985602 // AsynchronousFileChannel
	nparams 4
	  param inout name "file" type class_ref 923650 // Path
	  param inout name "options" type class_ref 192258 // Set
	  param inout name "executor" type class_ref 985218 // ExecutorService
	  param inout name "attrs" explicit_type "FileAttribute<?>..."
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1}<? extends OpenOption> ${p1}, ${t2} ${p2}, ${t3} ${p3}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Opens or creates a file for reading and/or writing, returning an
asynchronous file channel to access the file.

<p> The {@code options} parameter determines how the file is opened.
The {@link StandardOpenOption#READ READ} and {@link StandardOpenOption#WRITE
WRITE} options determines if the file should be opened for reading and/or
writing. If neither option is contained in the array then an existing file
is opened for  reading.

<p> In addition to {@code READ} and {@code WRITE}, the following options
may be present:

<table border=1 cellpadding=5 summary=\"\">
<tr> <th>Option</th> <th>Description</th> </tr>
<tr>
  <td> {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} </td>
  <td> When opening an existing file, the file is first truncated to a
  size of 0 bytes. This option is ignored when the file is opened only
  for reading.</td>
</tr>
<tr>
  <td> {@link StandardOpenOption#CREATE_NEW CREATE_NEW} </td>
  <td> If this option is present then a new file is created, failing if
  the file already exists. When creating a file the check for the
  existence of the file and the creation of the file if it does not exist
  is atomic with respect to other file system operations. This option is
  ignored when the file is opened only for reading. </td>
</tr>
<tr>
  <td > {@link StandardOpenOption#CREATE CREATE} </td>
  <td> If this option is present then an existing file is opened if it
  exists, otherwise a new file is created. When creating a file the check
  for the existence of the file and the creation of the file if it does
  not exist is atomic with respect to other file system operations. This
  option is ignored if the {@code CREATE_NEW} option is also present or
  the file is opened only for reading. </td>
</tr>
<tr>
  <td > {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} </td>
  <td> When this option is present then the implementation makes a
  <em>best effort</em> attempt to delete the file when closed by the
  the {@link #close close} method. If the {@code close} method is not
  invoked then a <em>best effort</em> attempt is made to delete the file
  when the Java virtual machine terminates. </td>
</tr>
<tr>
  <td>{@link StandardOpenOption#SPARSE SPARSE} </td>
  <td> When creating a new file this option is a <em>hint</em> that the
  new file will be sparse. This option is ignored when not creating
  a new file. </td>
</tr>
<tr>
  <td> {@link StandardOpenOption#SYNC SYNC} </td>
  <td> Requires that every update to the file's content or metadata be
  written synchronously to the underlying storage device. (see <a
  href=\"../file/package-summary.html#integrity\"> Synchronized I/O file
  integrity</a>). </td>
</tr>
<tr>
  <td> {@link StandardOpenOption#DSYNC DSYNC} </td>
  <td> Requires that every update to the file's content be written
  synchronously to the underlying storage device. (see <a
  href=\"../file/package-summary.html#integrity\"> Synchronized I/O file
  integrity</a>). </td>
</tr>
</table>

<p> An implementation may also support additional options.

<p> The {@code executor} parameter is the {@link ExecutorService} to
which tasks are submitted to handle I/O events and dispatch completion
results for operations initiated on resulting channel.
The nature of these tasks is highly implementation specific and so care
should be taken when configuring the {@code Executor}. Minimally it
should support an unbounded work queue and should not run tasks on the
caller thread of the {@link ExecutorService#execute execute} method.
Shutting down the executor service while the channel is open results in
unspecified behavior.

<p> The {@code attrs} parameter is an optional array of file {@link
FileAttribute file-attributes} to set atomically when creating the file.

<p> The new channel is created by invoking the {@link
FileSystemProvider#newFileChannel newFileChannel} method on the
provider that created the {@code Path}.

@param   file
         The path of the file to open or create
@param   options
         Options specifying how the file is opened
@param   executor
         The thread pool or {@code null} to associate the channel with
         the default thread pool
@param   attrs
         An optional list of file attributes to set atomically when
         creating the file

@return  A new asynchronous file channel

@throws  IllegalArgumentException
         If the set contains an invalid combination of options
@throws  UnsupportedOperationException
         If the {@code file} is associated with a provider that does not
         support creating asynchronous file channels, or an unsupported
         open option is specified, or the array contains an attribute that
         cannot be set atomically when creating the file
@throws  IOException
         If an I/O error occurs
@throws  SecurityException
         If a security manager is installed and it denies an
         unspecified permission required by the implementation.
         In the case of the default provider, the {@link
         SecurityManager#checkRead(String)} method is invoked to check
         read access if the file is opened for reading. The {@link
         SecurityManager#checkWrite(String)} method is invoked to check
         write access if the file is opened for writing
"
      end

      classrelation 3290754 // NO_ATTRIBUTES (<unidirectional association>)
	relation 3290754 --->
	  a role_name "NO_ATTRIBUTES" multiplicity "[]" init_value " new FileAttribute[0]" class_relation const_relation private
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}<?>${multiplicity} ${name}${value};
"
	    java_annotation "@SuppressWarnings({\"unchecked\", \"rawtypes\"})
"
	    classrelation_ref 3290754 // NO_ATTRIBUTES (<unidirectional association>)
	  b parent class_ref 985730 // FileAttribute
      end

      operation 7770114 "open"
	class_operation public return_type class_ref 985602 // AsynchronousFileChannel
	nparams 2
	  param inout name "file" type class_ref 923650 // Path
	  param inout name "" explicit_type "OpenOption...options"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Opens or creates a file for reading and/or writing, returning an
asynchronous file channel to access the file.

<p> An invocation of this method behaves in exactly the same way as the
invocation
<pre>
    ch.{@link #open(Path,Set,ExecutorService,FileAttribute[])
      open}(file, opts, null, new FileAttribute&lt;?&gt;[0]);
</pre>
where {@code opts} is a {@code Set} containing the options specified to
this method.

<p> The resulting channel is associated with default thread pool to which
tasks are submitted to handle I/O events and dispatch to completion
handlers that consume the result of asynchronous operations performed on
the resulting channel.

@param   file
         The path of the file to open or create
@param   options
         Options specifying how the file is opened

@return  A new asynchronous file channel

@throws  IllegalArgumentException
         If the set contains an invalid combination of options
@throws  UnsupportedOperationException
         If the {@code file} is associated with a provider that does not
         support creating file channels, or an unsupported open option is
         specified
@throws  IOException
         If an I/O error occurs
@throws  SecurityException
         If a security manager is installed and it denies an
         unspecified permission required by the implementation.
         In the case of the default provider, the {@link
         SecurityManager#checkRead(String)} method is invoked to check
         read access if the file is opened for reading. The {@link
         SecurityManager#checkWrite(String)} method is invoked to check
         write access if the file is opened for writing
"
      end

      operation 7770242 "size"
	abstract public explicit_return_type "long"
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the current size of this channel's file.

@return  The current size of this channel's file, measured in bytes

@throws  ClosedChannelException
         If this channel is closed
@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7770370 "truncate"
	abstract public return_type class_ref 985602 // AsynchronousFileChannel
	nparams 1
	  param in name "size" explicit_type "long"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Truncates this channel's file to the given size.

<p> If the given size is less than the file's current size then the file
is truncated, discarding any bytes beyond the new end of the file.  If
the given size is greater than or equal to the file's current size then
the file is not modified. </p>

@param  size
        The new size, a non-negative byte count

@return  This file channel

@throws  NonWritableChannelException
         If this channel was not opened for writing

@throws  ClosedChannelException
         If this channel is closed

@throws  IllegalArgumentException
         If the new size is negative

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7770498 "force"
	abstract public explicit_return_type "void"
	nparams 1
	  param inout name "metaData" explicit_type "boolean"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Forces any updates to this channel's file to be written to the storage
device that contains it.

<p> If this channel's file resides on a local storage device then when
this method returns it is guaranteed that all changes made to the file
since this channel was created, or since this method was last invoked,
will have been written to that device.  This is useful for ensuring that
critical information is not lost in the event of a system crash.

<p> If the file does not reside on a local device then no such guarantee
is made.

<p> The {@code metaData} parameter can be used to limit the number of
I/O operations that this method is required to perform.  Passing
{@code false} for this parameter indicates that only updates to the
file's content need be written to storage; passing {@code true}
indicates that updates to both the file's content and metadata must be
written, which generally requires at least one more I/O operation.
Whether this parameter actually has any effect is dependent upon the
underlying operating system and is therefore unspecified.

<p> Invoking this method may cause an I/O operation to occur even if the
channel was only opened for reading.  Some operating systems, for
example, maintain a last-access time as part of a file's metadata, and
this time is updated whenever the file is read.  Whether or not this is
actually done is system-dependent and is therefore unspecified.

<p> This method is only guaranteed to force changes that were made to
this channel's file via the methods defined in this class.

@param   metaData
         If {@code true} then this method is required to force changes
         to both the file's content and metadata to be written to
         storage; otherwise, it need only force content changes to be
         written

@throws  ClosedChannelException
         If this channel is closed

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7770626 "lock"
	abstract public explicit_return_type "void"
	nparams 5
	  param in name "position" explicit_type "long"
	  param in name "size" explicit_type "long"
	  param inout name "shared" explicit_type "boolean"
	  param inout name "attachment" explicit_type "A"
	  param inout name "handler" type class_ref 984578 // CompletionHandler
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<A> ${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4}<FileLock,? super A> ${p4}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires a lock on the given region of this channel's file.

<p> This method initiates an operation to acquire a lock on the given
region of this channel's file. The {@code handler} parameter is a
completion handler that is invoked when the lock is acquired (or the
operation fails). The result passed to the completion handler is the
resulting {@code FileLock}.

<p> The region specified by the {@code position} and {@code size}
parameters need not be contained within, or even overlap, the actual
underlying file.  Lock regions are fixed in size; if a locked region
initially contains the end of the file and the file grows beyond the
region then the new portion of the file will not be covered by the lock.
If a file is expected to grow in size and a lock on the entire file is
required then a region starting at zero, and no smaller than the
expected maximum size of the file, should be locked.  The two-argument
{@link #lock(Object,CompletionHandler)} method simply locks a region
of size {@link Long#MAX_VALUE}. If a lock that overlaps the requested
region is already held by this Java virtual machine, or this method has
been invoked to lock an overlapping region and that operation has not
completed, then this method throws {@link OverlappingFileLockException}.

<p> Some operating systems do not support a mechanism to acquire a file
lock in an asynchronous manner. Consequently an implementation may
acquire the file lock in a background thread or from a task executed by
a thread in the associated thread pool. If there are many lock operations
outstanding then it may consume threads in the Java virtual machine for
indefinite periods.

<p> Some operating systems do not support shared locks, in which case a
request for a shared lock is automatically converted into a request for
an exclusive lock.  Whether the newly-acquired lock is shared or
exclusive may be tested by invoking the resulting lock object's {@link
FileLock#isShared() isShared} method.

<p> File locks are held on behalf of the entire Java virtual machine.
They are not suitable for controlling access to a file by multiple
threads within the same virtual machine.

@param   <A>
         The type of the attachment
@param   position
         The position at which the locked region is to start; must be
         non-negative
@param   size
         The size of the locked region; must be non-negative, and the sum
         {@code position}&nbsp;+&nbsp;{@code size} must be non-negative
@param   shared
         {@code true} to request a shared lock, in which case this
         channel must be open for reading (and possibly writing);
         {@code false} to request an exclusive lock, in which case this
         channel must be open for writing (and possibly reading)
@param   attachment
         The object to attach to the I/O operation; can be {@code null}
@param   handler
         The handler for consuming the result

@throws  OverlappingFileLockException
         If a lock that overlaps the requested region is already held by
         this Java virtual machine, or there is already a pending attempt
         to lock an overlapping region
@throws  IllegalArgumentException
         If the preconditions on the parameters do not hold
@throws  NonReadableChannelException
         If {@code shared} is true but this channel was not opened for reading
@throws  NonWritableChannelException
         If {@code shared} is false but this channel was not opened for writing
"
      end

      operation 7770754 "lock"
	public explicit_return_type "void"
	nparams 2
	  param inout name "attachment" explicit_type "A"
	  param inout name "handler" type class_ref 984578 // CompletionHandler
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<A> ${type} ${name}${(}${t0} ${p0}, ${t1}<FileLock,? super A> ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires an exclusive lock on this channel's file.

<p> This method initiates an operation to acquire a lock on the given
region of this channel's file. The {@code handler} parameter is a
completion handler that is invoked when the lock is acquired (or the
operation fails). The result passed to the completion handler is the
resulting {@code FileLock}.

<p> An invocation of this method of the form {@code ch.lock(att,handler)}
behaves in exactly the same way as the invocation
<pre>
    ch.{@link #lock(long,long,boolean,Object,CompletionHandler) lock}(0L, Long.MAX_VALUE, false, att, handler)
</pre>

@param   <A>
         The type of the attachment
@param   attachment
         The object to attach to the I/O operation; can be {@code null}
@param   handler
         The handler for consuming the result

@throws  OverlappingFileLockException
         If a lock is already held by this Java virtual machine, or there
         is already a pending attempt to lock a region
@throws  NonWritableChannelException
         If this channel was not opened for writing
"
      end

      operation 7770882 "lock"
	abstract public return_type class_ref 984706 // Future
	nparams 3
	  param in name "position" explicit_type "long"
	  param in name "size" explicit_type "long"
	  param inout name "shared" explicit_type "boolean"
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<FileLock> ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires a lock on the given region of this channel's file.

<p> This method initiates an operation to acquire a lock on the given
region of this channel's file.  The method behaves in exactly the same
manner as the {@link #lock(long, long, boolean, Object, CompletionHandler)}
method except that instead of specifying a completion handler, this
method returns a {@code Future} representing the pending result. The
{@code Future}'s {@link Future#get() get} method returns the {@link
FileLock} on successful completion.

@param   position
         The position at which the locked region is to start; must be
         non-negative
@param   size
         The size of the locked region; must be non-negative, and the sum
         {@code position}&nbsp;+&nbsp;{@code size} must be non-negative
@param   shared
         {@code true} to request a shared lock, in which case this
         channel must be open for reading (and possibly writing);
         {@code false} to request an exclusive lock, in which case this
         channel must be open for writing (and possibly reading)

@return  a {@code Future} object representing the pending result

@throws  OverlappingFileLockException
         If a lock is already held by this Java virtual machine, or there
         is already a pending attempt to lock a region
@throws  IllegalArgumentException
         If the preconditions on the parameters do not hold
@throws  NonReadableChannelException
         If {@code shared} is true but this channel was not opened for reading
@throws  NonWritableChannelException
         If {@code shared} is false but this channel was not opened for writing
"
      end

      operation 7771010 "lock"
	public return_type class_ref 984706 // Future
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<FileLock> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires an exclusive lock on this channel's file.

<p> This method initiates an operation to acquire an exclusive lock on this
channel's file. The method returns a {@code Future} representing the
pending result of the operation. The {@code Future}'s {@link Future#get()
get} method returns the {@link FileLock} on successful completion.

<p> An invocation of this method behaves in exactly the same way as the
invocation
<pre>
    ch.{@link #lock(long,long,boolean) lock}(0L, Long.MAX_VALUE, false)
</pre>

@return  a {@code Future} object representing the pending result

@throws  OverlappingFileLockException
         If a lock is already held by this Java virtual machine, or there
         is already a pending attempt to lock a region
@throws  NonWritableChannelException
         If this channel was not opened for writing
"
      end

      operation 7771138 "tryLock"
	abstract public return_type class_ref 985858 // FileLock
	nparams 3
	  param in name "position" explicit_type "long"
	  param in name "size" explicit_type "long"
	  param inout name "shared" explicit_type "boolean"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to acquire a lock on the given region of this channel's file.

<p> This method does not block. An invocation always returns immediately,
either having acquired a lock on the requested region or having failed to
do so.  If it fails to acquire a lock because an overlapping lock is held
by another program then it returns {@code null}.  If it fails to acquire
a lock for any other reason then an appropriate exception is thrown.

@param  position
        The position at which the locked region is to start; must be
        non-negative

@param  size
        The size of the locked region; must be non-negative, and the sum
        {@code position}&nbsp;+&nbsp;{@code size} must be non-negative

@param  shared
        {@code true} to request a shared lock,
        {@code false} to request an exclusive lock

@return  A lock object representing the newly-acquired lock,
         or {@code null} if the lock could not be acquired
         because another program holds an overlapping lock

@throws  IllegalArgumentException
         If the preconditions on the parameters do not hold
@throws  ClosedChannelException
         If this channel is closed
@throws  OverlappingFileLockException
         If a lock that overlaps the requested region is already held by
         this Java virtual machine, or if another thread is already
         blocked in this method and is attempting to lock an overlapping
         region of the same file
@throws  NonReadableChannelException
         If {@code shared} is true but this channel was not opened for reading
@throws  NonWritableChannelException
         If {@code shared} is false but this channel was not opened for writing

@throws  IOException
         If some other I/O error occurs

@see     #lock(Object,CompletionHandler)
@see     #lock(long,long,boolean,Object,CompletionHandler)
@see     #tryLock()
"
      end

      operation 7771266 "tryLock"
	public return_type class_ref 985858 // FileLock
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to acquire an exclusive lock on this channel's file.

<p> An invocation of this method of the form {@code ch.tryLock()}
behaves in exactly the same way as the invocation

<pre>
    ch.{@link #tryLock(long,long,boolean) tryLock}(0L, Long.MAX_VALUE, false) </pre>

@return  A lock object representing the newly-acquired lock,
         or {@code null} if the lock could not be acquired
         because another program holds an overlapping lock

@throws  ClosedChannelException
         If this channel is closed
@throws  OverlappingFileLockException
         If a lock that overlaps the requested region is already held by
         this Java virtual machine, or if another thread is already
         blocked in this method and is attempting to lock an overlapping
         region
@throws  NonWritableChannelException
         If {@code shared} is false but this channel was not opened for writing

@throws  IOException
         If some other I/O error occurs

@see     #lock(Object,CompletionHandler)
@see     #lock(long,long,boolean,Object,CompletionHandler)
@see     #tryLock(long,long,boolean)
"
      end

      operation 7771394 "read"
	abstract public explicit_return_type "void"
	nparams 4
	  param inout name "dst" type class_ref 149890 // ByteBuffer
	  param in name "position" explicit_type "long"
	  param inout name "attachment" explicit_type "A"
	  param inout name "handler" type class_ref 984578 // CompletionHandler
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<A> ${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3}<Integer,? super A> ${p3}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Reads a sequence of bytes from this channel into the given buffer,
starting at the given file position.

<p> This method initiates the reading of a sequence of bytes from this
channel into the given buffer, starting at the given file position. The
result of the read is the number of bytes read or {@code -1} if the given
position is greater than or equal to the file's size at the time that the
read is attempted.

<p> This method works in the same manner as the {@link
AsynchronousByteChannel#read(ByteBuffer,Object,CompletionHandler)}
method, except that bytes are read starting at the given file position.
If the given file position is greater than the file's size at the time
that the read is attempted then no bytes are read.

@param   <A>
         The type of the attachment
@param   dst
         The buffer into which bytes are to be transferred
@param   position
         The file position at which the transfer is to begin;
         must be non-negative
@param   attachment
         The object to attach to the I/O operation; can be {@code null}
@param   handler
         The handler for consuming the result

@throws  IllegalArgumentException
         If the position is negative or the buffer is read-only
@throws  NonReadableChannelException
         If this channel was not opened for reading
"
      end

      operation 7771522 "read"
	abstract public return_type class_ref 984706 // Future
	nparams 2
	  param inout name "dst" type class_ref 149890 // ByteBuffer
	  param in name "position" explicit_type "long"
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Integer> ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Reads a sequence of bytes from this channel into the given buffer,
starting at the given file position.

<p> This method initiates the reading of a sequence of bytes from this
channel into the given buffer, starting at the given file position. This
method returns a {@code Future} representing the pending result of the
operation. The {@code Future}'s {@link Future#get() get} method returns
the number of bytes read or {@code -1} if the given position is greater
than or equal to the file's size at the time that the read is attempted.

<p> This method works in the same manner as the {@link
AsynchronousByteChannel#read(ByteBuffer)} method, except that bytes are
read starting at the given file position. If the given file position is
greater than the file's size at the time that the read is attempted then
no bytes are read.

@param   dst
         The buffer into which bytes are to be transferred
@param   position
         The file position at which the transfer is to begin;
         must be non-negative

@return  A {@code Future} object representing the pending result

@throws  IllegalArgumentException
         If the position is negative or the buffer is read-only
@throws  NonReadableChannelException
         If this channel was not opened for reading
"
      end

      operation 7771650 "write"
	abstract public explicit_return_type "void"
	nparams 4
	  param inout name "src" type class_ref 149890 // ByteBuffer
	  param in name "position" explicit_type "long"
	  param inout name "attachment" explicit_type "A"
	  param inout name "handler" type class_ref 984578 // CompletionHandler
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<A> ${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3}<Integer,? super A> ${p3}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Writes a sequence of bytes to this channel from the given buffer, starting
at the given file position.

<p> This method works in the same manner as the {@link
AsynchronousByteChannel#write(ByteBuffer,Object,CompletionHandler)}
method, except that bytes are written starting at the given file position.
If the given position is greater than the file's size, at the time that
the write is attempted, then the file will be grown to accommodate the new
bytes; the values of any bytes between the previous end-of-file and the
newly-written bytes are unspecified.

@param   <A>
         The type of the attachment
@param   src
         The buffer from which bytes are to be transferred
@param   position
         The file position at which the transfer is to begin;
         must be non-negative
@param   attachment
         The object to attach to the I/O operation; can be {@code null}
@param   handler
         The handler for consuming the result

@throws  IllegalArgumentException
         If the position is negative
@throws  NonWritableChannelException
         If this channel was not opened for writing
"
      end

      operation 7771778 "write"
	abstract public return_type class_ref 984706 // Future
	nparams 2
	  param inout name "src" type class_ref 149890 // ByteBuffer
	  param in name "position" explicit_type "long"
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Integer> ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Writes a sequence of bytes to this channel from the given buffer, starting
at the given file position.

<p> This method initiates the writing of a sequence of bytes to this
channel from the given buffer, starting at the given file position. The
method returns a {@code Future} representing the pending result of the
write operation. The {@code Future}'s {@link Future#get() get} method
returns the number of bytes written.

<p> This method works in the same manner as the {@link
AsynchronousByteChannel#write(ByteBuffer)} method, except that bytes are
written starting at the given file position. If the given position is
greater than the file's size, at the time that the write is attempted,
then the file will be grown to accommodate the new bytes; the values of
any bytes between the previous end-of-file and the newly-written bytes
are unspecified.

@param   src
         The buffer from which bytes are to be transferred
@param   position
         The file position at which the transfer is to begin;
         must be non-negative

@return  A {@code Future} object representing the pending result

@throws  IllegalArgumentException
         If the position is negative
@throws  NonWritableChannelException
         If this channel was not opened for writing
"
      end
    end

    class 985858 "FileLock"
      abstract visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A token representing a lock on a region of a file.

<p> A file-lock object is created each time a lock is acquired on a file via
one of the {@link FileChannel#lock(long,long,boolean) lock} or {@link
FileChannel#tryLock(long,long,boolean) tryLock} methods of the
{@link FileChannel} class, or the {@link
AsynchronousFileChannel#lock(long,long,boolean,Object,CompletionHandler) lock}
or {@link AsynchronousFileChannel#tryLock(long,long,boolean) tryLock}
methods of the {@link AsynchronousFileChannel} class.

<p> A file-lock object is initially valid.  It remains valid until the lock
is released by invoking the {@link #release release} method, by closing the
channel that was used to acquire it, or by the termination of the Java
virtual machine, whichever comes first.  The validity of a lock may be
tested by invoking its {@link #isValid isValid} method.

<p> A file lock is either <i>exclusive</i> or <i>shared</i>.  A shared lock
prevents other concurrently-running programs from acquiring an overlapping
exclusive lock, but does allow them to acquire overlapping shared locks.  An
exclusive lock prevents other programs from acquiring an overlapping lock of
either type.  Once it is released, a lock has no further effect on the locks
that may be acquired by other programs.

<p> Whether a lock is exclusive or shared may be determined by invoking its
{@link #isShared isShared} method.  Some platforms do not support shared
locks, in which case a request for a shared lock is automatically converted
into a request for an exclusive lock.

<p> The locks held on a particular file by a single Java virtual machine do
not overlap.  The {@link #overlaps overlaps} method may be used to test
whether a candidate lock range overlaps an existing lock.

<p> A file-lock object records the file channel upon whose file the lock is
held, the type and validity of the lock, and the position and size of the
locked region.  Only the validity of a lock is subject to change over time;
all other aspects of a lock's state are immutable.

<p> File locks are held on behalf of the entire Java virtual machine.
They are not suitable for controlling access to a file by multiple
threads within the same virtual machine.

<p> File-lock objects are safe for use by multiple concurrent threads.


<a name=\"pdep\"></a><h2> Platform dependencies </h2>

<p> This file-locking API is intended to map directly to the native locking
facility of the underlying operating system.  Thus the locks held on a file
should be visible to all programs that have access to the file, regardless
of the language in which those programs are written.

<p> Whether or not a lock actually prevents another program from accessing
the content of the locked region is system-dependent and therefore
unspecified.  The native file-locking facilities of some systems are merely
<i>advisory</i>, meaning that programs must cooperatively observe a known
locking protocol in order to guarantee data integrity.  On other systems
native file locks are <i>mandatory</i>, meaning that if one program locks a
region of a file then other programs are actually prevented from accessing
that region in a way that would violate the lock.  On yet other systems,
whether native file locks are advisory or mandatory is configurable on a
per-file basis.  To ensure consistent and correct behavior across platforms,
it is strongly recommended that the locks provided by this API be used as if
they were advisory locks.

<p> On some systems, acquiring a mandatory lock on a region of a file
prevents that region from being {@link java.nio.channels.FileChannel#map
<i>mapped into memory</i>}, and vice versa.  Programs that combine
locking and mapping should be prepared for this combination to fail.

<p> On some systems, closing a channel releases all locks held by the Java
virtual machine on the underlying file regardless of whether the locks were
acquired via that channel or via another channel open on the same file.  It
is strongly recommended that, within a program, a unique channel be used to
acquire all locks on any given file.

<p> Some network filesystems permit file locking to be used with
memory-mapped files only when the locked regions are page-aligned and a
whole multiple of the underlying hardware's page size.  Some network
filesystems do not implement file locks on regions that extend past a
certain position, often 2<sup>30</sup> or 2<sup>31</sup>.  In general, great
care should be taken when locking files that reside on network filesystems.


@author Mark Reinhold
@author JSR-51 Expert Group
@since 1.4
"
      classrelation 3297666 // <realization>
	relation 3297666 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3297666 // <realization>
	  b parent class_ref 146690 // AutoCloseable
      end

      classrelation 3297794 // channel (<unidirectional association>)
	relation 3297794 --->
	  a role_name "channel" const_relation private
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 3297794 // channel (<unidirectional association>)
	  b parent class_ref 940034 // Channel
      end

      attribute 1810050 "position"
	const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 1810178 "size"
	const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 1810306 "shared"
	const_attribute private explicit_type "boolean"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7791618 "FileLock"
	protected explicit_return_type ""
	nparams 4
	  param inout name "channel" type class_ref 924034 // FileChannel
	  param in name "position" explicit_type "long"
	  param in name "size" explicit_type "long"
	  param inout name "shared" explicit_type "boolean"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Initializes a new instance of this class.

@param  channel
        The file channel upon whose file this lock is held

@param  position
        The position within the file at which the locked region starts;
        must be non-negative

@param  size
        The size of the locked region; must be non-negative, and the sum
        <tt>position</tt>&nbsp;+&nbsp;<tt>size</tt> must be non-negative

@param  shared
        <tt>true</tt> if this lock is shared,
        <tt>false</tt> if it is exclusive

@throws IllegalArgumentException
        If the preconditions on the parameters do not hold
"
      end

      operation 7791746 "FileLock"
	protected explicit_return_type ""
	nparams 4
	  param inout name "channel" type class_ref 985602 // AsynchronousFileChannel
	  param in name "position" explicit_type "long"
	  param in name "size" explicit_type "long"
	  param inout name "shared" explicit_type "boolean"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Initializes a new instance of this class.

@param  channel
        The channel upon whose file this lock is held

@param  position
        The position within the file at which the locked region starts;
        must be non-negative

@param  size
        The size of the locked region; must be non-negative, and the sum
        <tt>position</tt>&nbsp;+&nbsp;<tt>size</tt> must be non-negative

@param  shared
        <tt>true</tt> if this lock is shared,
        <tt>false</tt> if it is exclusive

@throws IllegalArgumentException
        If the preconditions on the parameters do not hold

@since 1.7
"
      end

      operation 7791874 "channel"
	public return_type class_ref 924034 // FileChannel
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the file channel upon whose file this lock was acquired.

<p> This method has been superseded by the {@link #acquiredBy acquiredBy}
method.

@return  The file channel, or {@code null} if the file lock was not
         acquired by a file channel.
"
      end

      operation 7792002 "acquiredBy"
	public return_type class_ref 940034 // Channel
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the channel upon whose file this lock was acquired.

@return  The channel upon whose file this lock was acquired.

@since 1.7
"
      end

      operation 7792130 "position"
	public explicit_return_type "long"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the position within the file of the first byte of the locked
region.

<p> A locked region need not be contained within, or even overlap, the
actual underlying file, so the value returned by this method may exceed
the file's current size.  </p>

@return  The position
"
      end

      operation 7792258 "size"
	public explicit_return_type "long"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the size of the locked region in bytes.

<p> A locked region need not be contained within, or even overlap, the
actual underlying file, so the value returned by this method may exceed
the file's current size.  </p>

@return  The size of the locked region
"
      end

      operation 7792386 "isShared"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Tells whether this lock is shared.

@return <tt>true</tt> if lock is shared,
        <tt>false</tt> if it is exclusive
"
      end

      operation 7792514 "overlaps"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "position" explicit_type "long"
	  param in name "size" explicit_type "long"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Tells whether or not this lock overlaps the given lock range.

@param   position
         The starting position of the lock range
@param   size
         The size of the lock range

@return  <tt>true</tt> if, and only if, this lock and the given lock
         range overlap by at least one byte
"
      end

      operation 7792642 "isValid"
	abstract public explicit_return_type "boolean"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Tells whether or not this lock is valid.

<p> A lock object remains valid until it is released or the associated
file channel is closed, whichever comes first.  </p>

@return  <tt>true</tt> if, and only if, this lock is valid
"
      end

      operation 7792770 "release"
	abstract public explicit_return_type "void"
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Releases this lock.

<p> If this lock object is valid then invoking this method releases the
lock and renders the object invalid.  If this lock object is invalid
then invoking this method has no effect.  </p>

@throws  ClosedChannelException
         If the channel that was used to acquire this lock
         is no longer open

@throws  IOException
         If an I/O error occurs
"
      end

      operation 7792898 "close"
	public explicit_return_type "void"
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "This method invokes the {@link #release} method. It was added
to the class so that it could be used in conjunction with the
automatic resource management block construct.

@since 1.7
"
      end

      operation 7793026 "toString"
	public return_type class_ref 128130 // String
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a string describing the range, type, and validity of this lock.

@return  A descriptive string
"
      end
    end

    class 985986 "AsynchronousServerSocketChannel"
      abstract visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "An asynchronous channel for stream-oriented listening sockets.

<p> An asynchronous server-socket channel is created by invoking the
{@link #open open} method of this class.
A newly-created asynchronous server-socket channel is open but not yet bound.
It can be bound to a local address and configured to listen for connections
by invoking the {@link #bind(SocketAddress,int) bind} method. Once bound,
the {@link #accept(Object,CompletionHandler) accept} method
is used to initiate the accepting of connections to the channel's socket.
An attempt to invoke the <tt>accept</tt> method on an unbound channel will
cause a {@link NotYetBoundException} to be thrown.

<p> Channels of this type are safe for use by multiple concurrent threads
though at most one accept operation can be outstanding at any time.
If a thread initiates an accept operation before a previous accept operation
has completed then an {@link AcceptPendingException} will be thrown.

<p> Socket options are configured using the {@link #setOption(SocketOption,Object)
setOption} method. Channels of this type support the following options:
<blockquote>
<table border summary=\"Socket options\">
  <tr>
    <th>Option Name</th>
    <th>Description</th>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} </td>
    <td> The size of the socket receive buffer </td>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR} </td>
    <td> Re-use address </td>
  </tr>
</table>
</blockquote>
Additional (implementation specific) options may also be supported.

<p> <b>Usage Example:</b>
<pre>
 final AsynchronousServerSocketChannel listener =
     AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(5000));

 listener.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel,Void&gt;() {
     public void completed(AsynchronousSocketChannel ch, Void att) {
         // accept the next connection
         listener.accept(null, this);

         // handle this connection
         handle(ch);
     }
     public void failed(Throwable exc, Void att) {
         ...
     }
 });
</pre>

@since 1.7
"
      classrelation 3290882 // <realization>
	relation 3290882 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3290882 // <realization>
	  b parent class_ref 984450 // AsynchronousChannel
      end

      classrelation 3291138 // <realization>
	relation 3291138 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3291138 // <realization>
	  b parent class_ref 986114 // NetworkChannel
      end

      classrelation 3291266 // provider (<unidirectional association>)
	relation 3291266 --->
	  a role_name "provider" const_relation private
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 3291266 // provider (<unidirectional association>)
	  b parent class_ref 984962 // AsynchronousChannelProvider
      end

      operation 7772546 "AsynchronousServerSocketChannel"
	protected explicit_return_type ""
	nparams 1
	  param inout name "provider" type class_ref 984962 // AsynchronousChannelProvider
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Initializes a new instance of this class.

@param  provider
        The provider that created this channel
"
      end

      operation 7772674 "provider"
	public return_type class_ref 984962 // AsynchronousChannelProvider
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the provider that created this channel.

@return  The provider that created this channel
"
      end

      operation 7772802 "open"
	class_operation public return_type class_ref 985986 // AsynchronousServerSocketChannel
	nparams 1
	  param inout name "group" type class_ref 984834 // AsynchronousChannelGroup
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Opens an asynchronous server-socket channel.

<p> The new channel is created by invoking the {@link
java.nio.channels.spi.AsynchronousChannelProvider#openAsynchronousServerSocketChannel
openAsynchronousServerSocketChannel} method on the {@link
java.nio.channels.spi.AsynchronousChannelProvider} object that created
the given group. If the group parameter is <tt>null</tt> then the
resulting channel is created by the system-wide default provider, and
bound to the <em>default group</em>.

@param   group
         The group to which the newly constructed channel should be bound,
         or <tt>null</tt> for the default group

@return  A new asynchronous server socket channel

@throws  ShutdownChannelGroupException
         If the channel group is shutdown
@throws  IOException
         If an I/O error occurs
"
      end

      operation 7772930 "open"
	class_operation public return_type class_ref 985986 // AsynchronousServerSocketChannel
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Opens an asynchronous server-socket channel.

<p> This method returns an asynchronous server socket channel that is
bound to the <em>default group</em>. This method is equivalent to evaluating
the expression:
<blockquote><pre>
open((AsynchronousChannelGroup)null);
</pre></blockquote>

@return  A new asynchronous server socket channel

@throws  IOException
         If an I/O error occurs
"
      end

      operation 7773058 "bind"
	public return_type class_ref 985986 // AsynchronousServerSocketChannel
	nparams 1
	  param inout name "local" type class_ref 962178 // SocketAddress
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Binds the channel's socket to a local address and configures the socket to
listen for connections.

<p> An invocation of this method is equivalent to the following:
<blockquote><pre>
bind(local, 0);
</pre></blockquote>

@param   local
         The local address to bind the socket, or <tt>null</tt> to bind
         to an automatically assigned socket address

@return  This channel

@throws  AlreadyBoundException               {@inheritDoc}
@throws  UnsupportedAddressTypeException     {@inheritDoc}
@throws  SecurityException                   {@inheritDoc}
@throws  ClosedChannelException              {@inheritDoc}
@throws  IOException                         {@inheritDoc}
"
      end

      operation 7773186 "bind"
	abstract public return_type class_ref 985986 // AsynchronousServerSocketChannel
	nparams 2
	  param inout name "local" type class_ref 962178 // SocketAddress
	  param in name "backlog" explicit_type "int"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Binds the channel's socket to a local address and configures the socket to
listen for connections.

<p> This method is used to establish an association between the socket and
a local address. Once an association is established then the socket remains
bound until the associated channel is closed.

<p> The {@code backlog} parameter is the maximum number of pending
connections on the socket. Its exact semantics are implementation specific.
In particular, an implementation may impose a maximum length or may choose
to ignore the parameter altogther. If the {@code backlog} parameter has
the value {@code 0}, or a negative value, then an implementation specific
default is used.

@param   local
         The local address to bind the socket, or {@code null} to bind
         to an automatically assigned socket address
@param   backlog
         The maximum number of pending connections

@return  This channel

@throws  AlreadyBoundException
         If the socket is already bound
@throws  UnsupportedAddressTypeException
         If the type of the given address is not supported
@throws  SecurityException
         If a security manager has been installed and its {@link
         SecurityManager#checkListen checkListen} method denies the operation
@throws  ClosedChannelException
         If the channel is closed
@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7773314 "setOption"
	abstract public return_type class_ref 985986 // AsynchronousServerSocketChannel
	nparams 2
	  param inout name "name" type class_ref 962434 // SocketOption
	  param inout name "value" explicit_type "T"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<T> ${type} ${name}${(}${t0}<T> ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "@throws  IllegalArgumentException                {@inheritDoc}
@throws  ClosedChannelException                  {@inheritDoc}
@throws  IOException                             {@inheritDoc}
"
      end

      operation 7773442 "accept"
	abstract public explicit_return_type "void"
	nparams 2
	  param inout name "attachment" explicit_type "A"
	  param inout name "handler" type class_ref 984578 // CompletionHandler
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<A> ${type} ${name}${(}${t0} ${p0}, ${t1}<AsynchronousSocketChannel,? super A> ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Accepts a connection.

<p> This method initiates an asynchronous operation to accept a
connection made to this channel's socket. The {@code handler} parameter is
a completion handler that is invoked when a connection is accepted (or
the operation fails). The result passed to the completion handler is
the {@link AsynchronousSocketChannel} to the new connection.

<p> When a new connection is accepted then the resulting {@code
AsynchronousSocketChannel} will be bound to the same {@link
AsynchronousChannelGroup} as this channel. If the group is {@link
AsynchronousChannelGroup#isShutdown shutdown} and a connection is accepted,
then the connection is closed, and the operation completes with an {@code
IOException} and cause {@link ShutdownChannelGroupException}.

<p> To allow for concurrent handling of new connections, the completion
handler is not invoked directly by the initiating thread when a new
connection is accepted immediately (see <a
href=\"AsynchronousChannelGroup.html#threading\">Threading</a>).

<p> If a security manager has been installed then it verifies that the
address and port number of the connection's remote endpoint are permitted
by the security manager's {@link SecurityManager#checkAccept checkAccept}
method. The permission check is performed with privileges that are restricted
by the calling context of this method. If the permission check fails then
the connection is closed and the operation completes with a {@link
SecurityException}.

@param   <A>
         The type of the attachment
@param   attachment
         The object to attach to the I/O operation; can be {@code null}
@param   handler
         The handler for consuming the result

@throws  AcceptPendingException
         If an accept operation is already in progress on this channel
@throws  NotYetBoundException
         If this channel's socket has not yet been bound
@throws  ShutdownChannelGroupException
         If the channel group has terminated
"
      end

      operation 7773570 "accept"
	abstract public return_type class_ref 984706 // Future
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<AsynchronousSocketChannel> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Accepts a connection.

<p> This method initiates an asynchronous operation to accept a
connection made to this channel's socket. The method behaves in exactly
the same manner as the {@link #accept(Object, CompletionHandler)} method
except that instead of specifying a completion handler, this method
returns a {@code Future} representing the pending result. The {@code
Future}'s {@link Future#get() get} method returns the {@link
AsynchronousSocketChannel} to the new connection on successful completion.

@return  a {@code Future} object representing the pending result

@throws  AcceptPendingException
         If an accept operation is already in progress on this channel
@throws  NotYetBoundException
         If this channel's socket has not yet been bound
"
      end

      operation 7773698 "getLocalAddress"
	abstract public return_type class_ref 962178 // SocketAddress
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
	comment "{@inheritDoc}
<p>
If there is a security manager set, its {@code checkConnect} method is
called with the local address and {@code -1} as its arguments to see
if the operation is allowed. If the operation is not allowed,
a {@code SocketAddress} representing the
{@link java.net.InetAddress#getLoopbackAddress loopback} address and the
local port of the channel's socket is returned.

@return  The {@code SocketAddress} that the socket is bound to, or the
         {@code SocketAddress} representing the loopback address if
         denied by the security manager, or {@code null} if the
         channel's socket is not bound

@throws  ClosedChannelException     {@inheritDoc}
@throws  IOException                {@inheritDoc}
"
      end
    end

    class 986114 "NetworkChannel"
      visibility public stereotype "interface"
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A channel to a network socket.

<p> A channel that implements this interface is a channel to a network
socket. The {@link #bind(SocketAddress) bind} method is used to bind the
socket to a local {@link SocketAddress address}, the {@link #getLocalAddress()
getLocalAddress} method returns the address that the socket is bound to, and
the {@link #setOption(SocketOption,Object) setOption} and {@link
#getOption(SocketOption) getOption} methods are used to set and query socket
options.  An implementation of this interface should specify the socket options
that it supports.

<p> The {@link #bind bind} and {@link #setOption setOption} methods that do
not otherwise have a value to return are specified to return the network
channel upon which they are invoked. This allows method invocations to be
chained. Implementations of this interface should specialize the return type
so that method invocations on the implementation class can be chained.

@since 1.7
"
      classrelation 3291010 // <generalisation>
	relation 3291010 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3291010 // <generalisation>
	  b parent class_ref 940034 // Channel
      end

      operation 7771906 "bind"
	public return_type class_ref 986114 // NetworkChannel
	nparams 1
	  param inout name "local" type class_ref 962178 // SocketAddress
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Binds the channel's socket to a local address.

<p> This method is used to establish an association between the socket and
a local address. Once an association is established then the socket remains
bound until the channel is closed. If the {@code local} parameter has the
value {@code null} then the socket will be bound to an address that is
assigned automatically.

@param   local
         The address to bind the socket, or {@code null} to bind the socket
         to an automatically assigned socket address

@return  This channel

@throws  AlreadyBoundException
         If the socket is already bound
@throws  UnsupportedAddressTypeException
         If the type of the given address is not supported
@throws  ClosedChannelException
         If the channel is closed
@throws  IOException
         If some other I/O error occurs
@throws  SecurityException
         If a security manager is installed and it denies an unspecified
         permission. An implementation of this interface should specify
         any required permissions.

@see #getLocalAddress
"
      end

      operation 7772034 "getLocalAddress"
	public return_type class_ref 962178 // SocketAddress
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the socket address that this channel's socket is bound to.

<p> Where the channel is {@link #bind bound} to an Internet Protocol
socket address then the return value from this method is of type {@link
java.net.InetSocketAddress}.

@return  The socket address that the socket is bound to, or {@code null}
         if the channel's socket is not bound

@throws  ClosedChannelException
         If the channel is closed
@throws  IOException
         If an I/O error occurs
"
      end

      operation 7772162 "setOption"
	public return_type class_ref 986114 // NetworkChannel
	nparams 2
	  param inout name "name" type class_ref 962434 // SocketOption
	  param inout name "value" explicit_type "T"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<T> ${type} ${name}${(}${t0}<T> ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sets the value of a socket option.

@param   <T>
         The type of the socket option value
@param   name
         The socket option
@param   value
         The value of the socket option. A value of {@code null} may be
         a valid value for some socket options.

@return  This channel

@throws  UnsupportedOperationException
         If the socket option is not supported by this channel
@throws  IllegalArgumentException
         If the value is not a valid value for this socket option
@throws  ClosedChannelException
         If this channel is closed
@throws  IOException
         If an I/O error occurs

@see java.net.StandardSocketOptions
"
      end

      operation 7772290 "getOption"
	public explicit_return_type "T"
	nparams 1
	  param inout name "name" type class_ref 962434 // SocketOption
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<T> ${type} ${name}${(}${t0}<T> ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the value of a socket option.

@param   <T>
         The type of the socket option value
@param   name
         The socket option

@return  The value of the socket option. A value of {@code null} may be
         a valid value for some socket options.

@throws  UnsupportedOperationException
         If the socket option is not supported by this channel
@throws  ClosedChannelException
         If this channel is closed
@throws  IOException
         If an I/O error occurs

@see java.net.StandardSocketOptions
"
      end

      operation 7772418 "supportedOptions"
	public return_type class_ref 192258 // Set
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<SocketOption<?>> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a set of the socket options supported by this channel.

<p> This method will continue to return the set of options even after the
channel has been closed.

@return  A set of the socket options supported by this channel
"
      end
    end

    class 986242 "AsynchronousSocketChannel"
      abstract visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "An asynchronous channel for stream-oriented connecting sockets.

<p> Asynchronous socket channels are created in one of two ways. A newly-created
{@code AsynchronousSocketChannel} is created by invoking one of the {@link
#open open} methods defined by this class. A newly-created channel is open but
not yet connected. A connected {@code AsynchronousSocketChannel} is created
when a connection is made to the socket of an {@link AsynchronousServerSocketChannel}.
It is not possible to create an asynchronous socket channel for an arbitrary,
pre-existing {@link java.net.Socket socket}.

<p> A newly-created channel is connected by invoking its {@link #connect connect}
method; once connected, a channel remains connected until it is closed.  Whether
or not a socket channel is connected may be determined by invoking its {@link
#getRemoteAddress getRemoteAddress} method. An attempt to invoke an I/O
operation upon an unconnected channel will cause a {@link NotYetConnectedException}
to be thrown.

<p> Channels of this type are safe for use by multiple concurrent threads.
They support concurrent reading and writing, though at most one read operation
and one write operation can be outstanding at any time.
If a thread initiates a read operation before a previous read operation has
completed then a {@link ReadPendingException} will be thrown. Similarly, an
attempt to initiate a write operation before a previous write has completed
will throw a {@link WritePendingException}.

<p> Socket options are configured using the {@link #setOption(SocketOption,Object)
setOption} method. Asynchronous socket channels support the following options:
<blockquote>
<table border summary=\"Socket options\">
  <tr>
    <th>Option Name</th>
    <th>Description</th>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#SO_SNDBUF SO_SNDBUF} </td>
    <td> The size of the socket send buffer </td>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#SO_RCVBUF SO_RCVBUF} </td>
    <td> The size of the socket receive buffer </td>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#SO_KEEPALIVE SO_KEEPALIVE} </td>
    <td> Keep connection alive </td>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR} </td>
    <td> Re-use address </td>
  </tr>
  <tr>
    <td> {@link java.net.StandardSocketOptions#TCP_NODELAY TCP_NODELAY} </td>
    <td> Disable the Nagle algorithm </td>
  </tr>
</table>
</blockquote>
Additional (implementation specific) options may also be supported.

<h2>Timeouts</h2>

<p> The {@link #read(ByteBuffer,long,TimeUnit,Object,CompletionHandler) read}
and {@link #write(ByteBuffer,long,TimeUnit,Object,CompletionHandler) write}
methods defined by this class allow a timeout to be specified when initiating
a read or write operation. If the timeout elapses before an operation completes
then the operation completes with the exception {@link
InterruptedByTimeoutException}. A timeout may leave the channel, or the
underlying connection, in an inconsistent state. Where the implementation
cannot guarantee that bytes have not been read from the channel then it puts
the channel into an implementation specific <em>error state</em>. A subsequent
attempt to initiate a {@code read} operation causes an unspecified runtime
exception to be thrown. Similarly if a {@code write} operation times out and
the implementation cannot guarantee bytes have not been written to the
channel then further attempts to {@code write} to the channel cause an
unspecified runtime exception to be thrown. When a timeout elapses then the
state of the {@link ByteBuffer}, or the sequence of buffers, for the I/O
operation is not defined. Buffers should be discarded or at least care must
be taken to ensure that the buffers are not accessed while the channel remains
open. All methods that accept timeout parameters treat values less than or
equal to zero to mean that the I/O operation does not timeout.

@since 1.7
"
      classrelation 3291394 // <realization>
	relation 3291394 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3291394 // <realization>
	  b parent class_ref 984322 // AsynchronousByteChannel
      end

      classrelation 3291522 // <realization>
	relation 3291522 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3291522 // <realization>
	  b parent class_ref 986114 // NetworkChannel
      end

      classrelation 3291650 // provider (<unidirectional association>)
	relation 3291650 --->
	  a role_name "provider" const_relation private
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 3291650 // provider (<unidirectional association>)
	  b parent class_ref 984962 // AsynchronousChannelProvider
      end

      operation 7773826 "AsynchronousSocketChannel"
	protected explicit_return_type ""
	nparams 1
	  param inout name "provider" type class_ref 984962 // AsynchronousChannelProvider
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Initializes a new instance of this class.

@param  provider
        The provider that created this channel
"
      end

      operation 7773954 "provider"
	public return_type class_ref 984962 // AsynchronousChannelProvider
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the provider that created this channel.

@return  The provider that created this channel
"
      end

      operation 7774082 "open"
	class_operation public return_type class_ref 986242 // AsynchronousSocketChannel
	nparams 1
	  param inout name "group" type class_ref 984834 // AsynchronousChannelGroup
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Opens an asynchronous socket channel.

<p> The new channel is created by invoking the {@link
AsynchronousChannelProvider#openAsynchronousSocketChannel
openAsynchronousSocketChannel} method on the {@link
AsynchronousChannelProvider} that created the group. If the group parameter
is {@code null} then the resulting channel is created by the system-wide
default provider, and bound to the <em>default group</em>.

@param   group
         The group to which the newly constructed channel should be bound,
         or {@code null} for the default group

@return  A new asynchronous socket channel

@throws  ShutdownChannelGroupException
         If the channel group is shutdown
@throws  IOException
         If an I/O error occurs
"
      end

      operation 7774210 "open"
	class_operation public return_type class_ref 986242 // AsynchronousSocketChannel
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Opens an asynchronous socket channel.

<p> This method returns an asynchronous socket channel that is bound to
the <em>default group</em>.This method is equivalent to evaluating the
expression:
<blockquote><pre>
open((AsynchronousChannelGroup)null);
</pre></blockquote>

@return  A new asynchronous socket channel

@throws  IOException
         If an I/O error occurs
"
      end

      operation 7774338 "bind"
	abstract public return_type class_ref 986242 // AsynchronousSocketChannel
	nparams 1
	  param inout name "local" type class_ref 962178 // SocketAddress
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
	comment " -- socket options and related --

@throws  ConnectionPendingException
         If a connection operation is already in progress on this channel
@throws  AlreadyBoundException               {@inheritDoc}
@throws  UnsupportedAddressTypeException     {@inheritDoc}
@throws  ClosedChannelException              {@inheritDoc}
@throws  IOException                         {@inheritDoc}
@throws  SecurityException
         If a security manager has been installed and its
         {@link SecurityManager#checkListen checkListen} method denies
         the operation
"
      end

      operation 7774466 "setOption"
	abstract public return_type class_ref 986242 // AsynchronousSocketChannel
	nparams 2
	  param inout name "name" type class_ref 962434 // SocketOption
	  param inout name "value" explicit_type "T"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<T> ${type} ${name}${(}${t0}<T> ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
	comment "@throws  IllegalArgumentException                {@inheritDoc}
@throws  ClosedChannelException                  {@inheritDoc}
@throws  IOException                             {@inheritDoc}
"
      end

      operation 7774594 "shutdownInput"
	abstract public return_type class_ref 986242 // AsynchronousSocketChannel
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Shutdown the connection for reading without closing the channel.

<p> Once shutdown for reading then further reads on the channel will
return {@code -1}, the end-of-stream indication. If the input side of the
connection is already shutdown then invoking this method has no effect.
The effect on an outstanding read operation is system dependent and
therefore not specified. The effect, if any, when there is data in the
socket receive buffer that has not been read, or data arrives subsequently,
is also system dependent.

@return  The channel

@throws  NotYetConnectedException
         If this channel is not yet connected
@throws  ClosedChannelException
         If this channel is closed
@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7774722 "shutdownOutput"
	abstract public return_type class_ref 986242 // AsynchronousSocketChannel
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Shutdown the connection for writing without closing the channel.

<p> Once shutdown for writing then further attempts to write to the
channel will throw {@link ClosedChannelException}. If the output side of
the connection is already shutdown then invoking this method has no
effect. The effect on an outstanding write operation is system dependent
and therefore not specified.

@return  The channel

@throws  NotYetConnectedException
         If this channel is not yet connected
@throws  ClosedChannelException
         If this channel is closed
@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7774850 "getRemoteAddress"
	abstract public return_type class_ref 962178 // SocketAddress
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " -- state --

Returns the remote address to which this channel's socket is connected.

<p> Where the channel is bound and connected to an Internet Protocol
socket address then the return value from this method is of type {@link
java.net.InetSocketAddress}.

@return  The remote address; {@code null} if the channel's socket is not
         connected

@throws  ClosedChannelException
         If the channel is closed
@throws  IOException
         If an I/O error occurs
"
      end

      operation 7774978 "connect"
	abstract public explicit_return_type "void"
	nparams 3
	  param inout name "remote" type class_ref 962178 // SocketAddress
	  param inout name "attachment" explicit_type "A"
	  param inout name "handler" type class_ref 984578 // CompletionHandler
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<A> ${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2}<Void,? super A> ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " -- asynchronous operations --

Connects this channel.

<p> This method initiates an operation to connect this channel. The
{@code handler} parameter is a completion handler that is invoked when
the connection is successfully established or connection cannot be
established. If the connection cannot be established then the channel is
closed.

<p> This method performs exactly the same security checks as the {@link
java.net.Socket} class.  That is, if a security manager has been
installed then this method verifies that its {@link
java.lang.SecurityManager#checkConnect checkConnect} method permits
connecting to the address and port number of the given remote endpoint.

@param   <A>
         The type of the attachment
@param   remote
         The remote address to which this channel is to be connected
@param   attachment
         The object to attach to the I/O operation; can be {@code null}
@param   handler
         The handler for consuming the result

@throws  UnresolvedAddressException
         If the given remote address is not fully resolved
@throws  UnsupportedAddressTypeException
         If the type of the given remote address is not supported
@throws  AlreadyConnectedException
         If this channel is already connected
@throws  ConnectionPendingException
         If a connection operation is already in progress on this channel
@throws  ShutdownChannelGroupException
         If the channel group has terminated
@throws  SecurityException
         If a security manager has been installed
         and it does not permit access to the given remote endpoint

@see #getRemoteAddress
"
      end

      operation 7775106 "connect"
	abstract public return_type class_ref 984706 // Future
	nparams 1
	  param inout name "remote" type class_ref 962178 // SocketAddress
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Void> ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Connects this channel.

<p> This method initiates an operation to connect this channel. This
method behaves in exactly the same manner as the {@link
#connect(SocketAddress, Object, CompletionHandler)} method except that
instead of specifying a completion handler, this method returns a {@code
Future} representing the pending result. The {@code Future}'s {@link
Future#get() get} method returns {@code null} on successful completion.

@param   remote
         The remote address to which this channel is to be connected

@return  A {@code Future} object representing the pending result

@throws  UnresolvedAddressException
         If the given remote address is not fully resolved
@throws  UnsupportedAddressTypeException
         If the type of the given remote address is not supported
@throws  AlreadyConnectedException
         If this channel is already connected
@throws  ConnectionPendingException
         If a connection operation is already in progress on this channel
@throws  SecurityException
         If a security manager has been installed
         and it does not permit access to the given remote endpoint
"
      end

      operation 7775234 "read"
	abstract public explicit_return_type "void"
	nparams 5
	  param inout name "dst" type class_ref 149890 // ByteBuffer
	  param in name "timeout" explicit_type "long"
	  param inout name "unit" type class_ref 935938 // TimeUnit
	  param inout name "attachment" explicit_type "A"
	  param inout name "handler" type class_ref 984578 // CompletionHandler
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<A> ${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4}<Integer,? super A> ${p4}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Reads a sequence of bytes from this channel into the given buffer.

<p> This method initiates an asynchronous read operation to read a
sequence of bytes from this channel into the given buffer. The {@code
handler} parameter is a completion handler that is invoked when the read
operation completes (or fails). The result passed to the completion
handler is the number of bytes read or {@code -1} if no bytes could be
read because the channel has reached end-of-stream.

<p> If a timeout is specified and the timeout elapses before the operation
completes then the operation completes with the exception {@link
InterruptedByTimeoutException}. Where a timeout occurs, and the
implementation cannot guarantee that bytes have not been read, or will not
be read from the channel into the given buffer, then further attempts to
read from the channel will cause an unspecific runtime exception to be
thrown.

<p> Otherwise this method works in the same manner as the {@link
AsynchronousByteChannel#read(ByteBuffer,Object,CompletionHandler)}
method.

@param   <A>
         The type of the attachment
@param   dst
         The buffer into which bytes are to be transferred
@param   timeout
         The maximum time for the I/O operation to complete
@param   unit
         The time unit of the {@code timeout} argument
@param   attachment
         The object to attach to the I/O operation; can be {@code null}
@param   handler
         The handler for consuming the result

@throws  IllegalArgumentException
         If the buffer is read-only
@throws  ReadPendingException
         If a read operation is already in progress on this channel
@throws  NotYetConnectedException
         If this channel is not yet connected
@throws  ShutdownChannelGroupException
         If the channel group has terminated
"
      end

      operation 7775362 "read"
	public explicit_return_type "void"
	nparams 3
	  param inout name "dst" type class_ref 149890 // ByteBuffer
	  param inout name "attachment" explicit_type "A"
	  param inout name "handler" type class_ref 984578 // CompletionHandler
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<A> ${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2}<Integer,? super A> ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
	comment "@throws  IllegalArgumentException        {@inheritDoc}
@throws  ReadPendingException            {@inheritDoc}
@throws  NotYetConnectedException
         If this channel is not yet connected
@throws  ShutdownChannelGroupException
         If the channel group has terminated
"
      end

      operation 7775490 "read"
	abstract public return_type class_ref 984706 // Future
	nparams 1
	  param inout name "dst" type class_ref 149890 // ByteBuffer
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Integer> ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
	comment "@throws  IllegalArgumentException        {@inheritDoc}
@throws  ReadPendingException            {@inheritDoc}
@throws  NotYetConnectedException
         If this channel is not yet connected
"
      end

      operation 7775618 "read"
	abstract public explicit_return_type "void"
	nparams 7
	  param inout name "dsts" type class_ref 149890 // ByteBuffer
	multiplicity "[]"
	  param in name "offset" explicit_type "int"
	  param in name "length" explicit_type "int"
	  param in name "timeout" explicit_type "long"
	  param inout name "unit" type class_ref 935938 // TimeUnit
	  param inout name "attachment" explicit_type "A"
	  param inout name "handler" type class_ref 984578 // CompletionHandler
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<A> ${type} ${name}${(}${t0}[] ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4} ${p4}, ${t5} ${p5}, ${t6}<Long,? super A> ${p6}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Reads a sequence of bytes from this channel into a subsequence of the
given buffers. This operation, sometimes called a <em>scattering read</em>,
is often useful when implementing network protocols that group data into
segments consisting of one or more fixed-length headers followed by a
variable-length body. The {@code handler} parameter is a completion
handler that is invoked when the read operation completes (or fails). The
result passed to the completion handler is the number of bytes read or
{@code -1} if no bytes could be read because the channel has reached
end-of-stream.

<p> This method initiates a read of up to <i>r</i> bytes from this channel,
where <i>r</i> is the total number of bytes remaining in the specified
subsequence of the given buffer array, that is,

<blockquote><pre>
dsts[offset].remaining()
    + dsts[offset+1].remaining()
    + ... + dsts[offset+length-1].remaining()</pre></blockquote>

at the moment that the read is attempted.

<p> Suppose that a byte sequence of length <i>n</i> is read, where
<tt>0</tt>&nbsp;<tt>&lt;</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
Up to the first <tt>dsts[offset].remaining()</tt> bytes of this sequence
are transferred into buffer <tt>dsts[offset]</tt>, up to the next
<tt>dsts[offset+1].remaining()</tt> bytes are transferred into buffer
<tt>dsts[offset+1]</tt>, and so forth, until the entire byte sequence
is transferred into the given buffers.  As many bytes as possible are
transferred into each buffer, hence the final position of each updated
buffer, except the last updated buffer, is guaranteed to be equal to
that buffer's limit. The underlying operating system may impose a limit
on the number of buffers that may be used in an I/O operation. Where the
number of buffers (with bytes remaining), exceeds this limit, then the
I/O operation is performed with the maximum number of buffers allowed by
the operating system.

<p> If a timeout is specified and the timeout elapses before the operation
completes then it completes with the exception {@link
InterruptedByTimeoutException}. Where a timeout occurs, and the
implementation cannot guarantee that bytes have not been read, or will not
be read from the channel into the given buffers, then further attempts to
read from the channel will cause an unspecific runtime exception to be
thrown.

@param   <A>
         The type of the attachment
@param   dsts
         The buffers into which bytes are to be transferred
@param   offset
         The offset within the buffer array of the first buffer into which
         bytes are to be transferred; must be non-negative and no larger than
         {@code dsts.length}
@param   length
         The maximum number of buffers to be accessed; must be non-negative
         and no larger than {@code dsts.length - offset}
@param   timeout
         The maximum time for the I/O operation to complete
@param   unit
         The time unit of the {@code timeout} argument
@param   attachment
         The object to attach to the I/O operation; can be {@code null}
@param   handler
         The handler for consuming the result

@throws  IndexOutOfBoundsException
         If the pre-conditions for the {@code offset}  and {@code length}
         parameter aren't met
@throws  IllegalArgumentException
         If the buffer is read-only
@throws  ReadPendingException
         If a read operation is already in progress on this channel
@throws  NotYetConnectedException
         If this channel is not yet connected
@throws  ShutdownChannelGroupException
         If the channel group has terminated
"
      end

      operation 7775746 "write"
	abstract public explicit_return_type "void"
	nparams 5
	  param inout name "src" type class_ref 149890 // ByteBuffer
	  param in name "timeout" explicit_type "long"
	  param inout name "unit" type class_ref 935938 // TimeUnit
	  param inout name "attachment" explicit_type "A"
	  param inout name "handler" type class_ref 984578 // CompletionHandler
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<A> ${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4}<Integer,? super A> ${p4}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Writes a sequence of bytes to this channel from the given buffer.

<p> This method initiates an asynchronous write operation to write a
sequence of bytes to this channel from the given buffer. The {@code
handler} parameter is a completion handler that is invoked when the write
operation completes (or fails). The result passed to the completion
handler is the number of bytes written.

<p> If a timeout is specified and the timeout elapses before the operation
completes then it completes with the exception {@link
InterruptedByTimeoutException}. Where a timeout occurs, and the
implementation cannot guarantee that bytes have not been written, or will
not be written to the channel from the given buffer, then further attempts
to write to the channel will cause an unspecific runtime exception to be
thrown.

<p> Otherwise this method works in the same manner as the {@link
AsynchronousByteChannel#write(ByteBuffer,Object,CompletionHandler)}
method.

@param   <A>
         The type of the attachment
@param   src
         The buffer from which bytes are to be retrieved
@param   timeout
         The maximum time for the I/O operation to complete
@param   unit
         The time unit of the {@code timeout} argument
@param   attachment
         The object to attach to the I/O operation; can be {@code null}
@param   handler
         The handler for consuming the result

@throws  WritePendingException
         If a write operation is already in progress on this channel
@throws  NotYetConnectedException
         If this channel is not yet connected
@throws  ShutdownChannelGroupException
         If the channel group has terminated
"
      end

      operation 7775874 "write"
	public explicit_return_type "void"
	nparams 3
	  param inout name "src" type class_ref 149890 // ByteBuffer
	  param inout name "attachment" explicit_type "A"
	  param inout name "handler" type class_ref 984578 // CompletionHandler
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<A> ${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2}<Integer,? super A> ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
	comment "@throws  WritePendingException          {@inheritDoc}
@throws  NotYetConnectedException
         If this channel is not yet connected
@throws  ShutdownChannelGroupException
         If the channel group has terminated
"
      end

      operation 7776002 "write"
	abstract public return_type class_ref 984706 // Future
	nparams 1
	  param inout name "src" type class_ref 149890 // ByteBuffer
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Integer> ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
	comment "@throws  WritePendingException       {@inheritDoc}
@throws  NotYetConnectedException
         If this channel is not yet connected
"
      end

      operation 7776130 "write"
	abstract public explicit_return_type "void"
	nparams 7
	  param inout name "srcs" type class_ref 149890 // ByteBuffer
	multiplicity "[]"
	  param in name "offset" explicit_type "int"
	  param in name "length" explicit_type "int"
	  param in name "timeout" explicit_type "long"
	  param inout name "unit" type class_ref 935938 // TimeUnit
	  param inout name "attachment" explicit_type "A"
	  param inout name "handler" type class_ref 984578 // CompletionHandler
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}<A> ${type} ${name}${(}${t0}[] ${p0}, ${t1} ${p1}, ${t2} ${p2}, ${t3} ${p3}, ${t4} ${p4}, ${t5} ${p5}, ${t6}<Long,? super A> ${p6}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Writes a sequence of bytes to this channel from a subsequence of the given
buffers. This operation, sometimes called a <em>gathering write</em>, is
often useful when implementing network protocols that group data into
segments consisting of one or more fixed-length headers followed by a
variable-length body. The {@code handler} parameter is a completion
handler that is invoked when the write operation completes (or fails).
The result passed to the completion handler is the number of bytes written.

<p> This method initiates a write of up to <i>r</i> bytes to this channel,
where <i>r</i> is the total number of bytes remaining in the specified
subsequence of the given buffer array, that is,

<blockquote><pre>
srcs[offset].remaining()
    + srcs[offset+1].remaining()
    + ... + srcs[offset+length-1].remaining()</pre></blockquote>

at the moment that the write is attempted.

<p> Suppose that a byte sequence of length <i>n</i> is written, where
<tt>0</tt>&nbsp;<tt>&lt;</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
Up to the first <tt>srcs[offset].remaining()</tt> bytes of this sequence
are written from buffer <tt>srcs[offset]</tt>, up to the next
<tt>srcs[offset+1].remaining()</tt> bytes are written from buffer
<tt>srcs[offset+1]</tt>, and so forth, until the entire byte sequence is
written.  As many bytes as possible are written from each buffer, hence
the final position of each updated buffer, except the last updated
buffer, is guaranteed to be equal to that buffer's limit. The underlying
operating system may impose a limit on the number of buffers that may be
used in an I/O operation. Where the number of buffers (with bytes
remaining), exceeds this limit, then the I/O operation is performed with
the maximum number of buffers allowed by the operating system.

<p> If a timeout is specified and the timeout elapses before the operation
completes then it completes with the exception {@link
InterruptedByTimeoutException}. Where a timeout occurs, and the
implementation cannot guarantee that bytes have not been written, or will
not be written to the channel from the given buffers, then further attempts
to write to the channel will cause an unspecific runtime exception to be
thrown.

@param   <A>
         The type of the attachment
@param   srcs
         The buffers from which bytes are to be retrieved
@param   offset
         The offset within the buffer array of the first buffer from which
         bytes are to be retrieved; must be non-negative and no larger
         than {@code srcs.length}
@param   length
         The maximum number of buffers to be accessed; must be non-negative
         and no larger than {@code srcs.length - offset}
@param   timeout
         The maximum time for the I/O operation to complete
@param   unit
         The time unit of the {@code timeout} argument
@param   attachment
         The object to attach to the I/O operation; can be {@code null}
@param   handler
         The handler for consuming the result

@throws  IndexOutOfBoundsException
         If the pre-conditions for the {@code offset}  and {@code length}
         parameter aren't met
@throws  WritePendingException
         If a write operation is already in progress on this channel
@throws  NotYetConnectedException
         If this channel is not yet connected
@throws  ShutdownChannelGroupException
         If the channel group has terminated
"
      end

      operation 7776258 "getLocalAddress"
	abstract public return_type class_ref 962178 // SocketAddress
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "{@inheritDoc}
<p>
If there is a security manager set, its {@code checkConnect} method is
called with the local address and {@code -1} as its arguments to see
if the operation is allowed. If the operation is not allowed,
a {@code SocketAddress} representing the
{@link java.net.InetAddress#getLoopbackAddress loopback} address and the
local port of the channel's socket is returned.

@return  The {@code SocketAddress} that the socket is bound to, or the
         {@code SocketAddress} representing the loopback address if
         denied by the security manager, or {@code null} if the
         channel's socket is not bound

@throws  ClosedChannelException     {@inheritDoc}
@throws  IOException                {@inheritDoc}
"
      end
    end

    class 986370 "ByteChannel"
      visibility public stereotype "interface"
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A channel that can read and write bytes.  This interface simply unifies
{@link ReadableByteChannel} and {@link WritableByteChannel}; it does not
specify any new operations.

@author Mark Reinhold
@author JSR-51 Expert Group
@since 1.4
"
      classrelation 3291906 // <generalisation>
	relation 3291906 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3291906 // <generalisation>
	  b parent class_ref 986498 // ReadableByteChannel
      end

      classrelation 3292162 // <generalisation>
	relation 3292162 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3292162 // <generalisation>
	  b parent class_ref 986626 // WritableByteChannel
      end
    end

    class 986498 "ReadableByteChannel"
      visibility public stereotype "interface"
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A channel that can read bytes.

<p> Only one read operation upon a readable channel may be in progress at
any given time.  If one thread initiates a read operation upon a channel
then any other thread that attempts to initiate another read operation will
block until the first operation is complete.  Whether or not other kinds of
I/O operations may proceed concurrently with a read operation depends upon
the type of the channel. </p>


@author Mark Reinhold
@author JSR-51 Expert Group
@since 1.4
"
      classrelation 3291778 // <generalisation>
	relation 3291778 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3291778 // <generalisation>
	  b parent class_ref 940034 // Channel
      end

      operation 7776386 "read"
	public explicit_return_type "int"
	nparams 1
	  param inout name "dst" type class_ref 149890 // ByteBuffer
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Reads a sequence of bytes from this channel into the given buffer.

<p> An attempt is made to read up to <i>r</i> bytes from the channel,
where <i>r</i> is the number of bytes remaining in the buffer, that is,
<tt>dst.remaining()</tt>, at the moment this method is invoked.

<p> Suppose that a byte sequence of length <i>n</i> is read, where
<tt>0</tt>&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
This byte sequence will be transferred into the buffer so that the first
byte in the sequence is at index <i>p</i> and the last byte is at index
<i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i>&nbsp;<tt>-</tt>&nbsp;<tt>1</tt>,
where <i>p</i> is the buffer's position at the moment this method is
invoked.  Upon return the buffer's position will be equal to
<i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i>; its limit will not have changed.

<p> A read operation might not fill the buffer, and in fact it might not
read any bytes at all.  Whether or not it does so depends upon the
nature and state of the channel.  A socket channel in non-blocking mode,
for example, cannot read any more bytes than are immediately available
from the socket's input buffer; similarly, a file channel cannot read
any more bytes than remain in the file.  It is guaranteed, however, that
if a channel is in blocking mode and there is at least one byte
remaining in the buffer then this method will block until at least one
byte is read.

<p> This method may be invoked at any time.  If another thread has
already initiated a read operation upon this channel, however, then an
invocation of this method will block until the first operation is
complete. </p>

@param  dst
        The buffer into which bytes are to be transferred

@return  The number of bytes read, possibly zero, or <tt>-1</tt> if the
         channel has reached end-of-stream

@throws  NonReadableChannelException
         If this channel was not opened for reading

@throws  ClosedChannelException
         If this channel is closed

@throws  AsynchronousCloseException
         If another thread closes this channel
         while the read operation is in progress

@throws  ClosedByInterruptException
         If another thread interrupts the current thread
         while the read operation is in progress, thereby
         closing the channel and setting the current thread's
         interrupt status

@throws  IOException
         If some other I/O error occurs
"
      end
    end

    class 986626 "WritableByteChannel"
      visibility public stereotype "interface"
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A channel that can write bytes.

<p> Only one write operation upon a writable channel may be in progress at
any given time.  If one thread initiates a write operation upon a channel
then any other thread that attempts to initiate another write operation will
block until the first operation is complete.  Whether or not other kinds of
I/O operations may proceed concurrently with a write operation depends upon
the type of the channel. </p>


@author Mark Reinhold
@author JSR-51 Expert Group
@since 1.4
"
      classrelation 3292034 // <generalisation>
	relation 3292034 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3292034 // <generalisation>
	  b parent class_ref 940034 // Channel
      end

      operation 7776514 "write"
	public explicit_return_type "int"
	nparams 1
	  param inout name "src" type class_ref 149890 // ByteBuffer
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Writes a sequence of bytes to this channel from the given buffer.

<p> An attempt is made to write up to <i>r</i> bytes to the channel,
where <i>r</i> is the number of bytes remaining in the buffer, that is,
<tt>src.remaining()</tt>, at the moment this method is invoked.

<p> Suppose that a byte sequence of length <i>n</i> is written, where
<tt>0</tt>&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
This byte sequence will be transferred from the buffer starting at index
<i>p</i>, where <i>p</i> is the buffer's position at the moment this
method is invoked; the index of the last byte written will be
<i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i>&nbsp;<tt>-</tt>&nbsp;<tt>1</tt>.
Upon return the buffer's position will be equal to
<i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i>; its limit will not have changed.

<p> Unless otherwise specified, a write operation will return only after
writing all of the <i>r</i> requested bytes.  Some types of channels,
depending upon their state, may write only some of the bytes or possibly
none at all.  A socket channel in non-blocking mode, for example, cannot
write any more bytes than are free in the socket's output buffer.

<p> This method may be invoked at any time.  If another thread has
already initiated a write operation upon this channel, however, then an
invocation of this method will block until the first operation is
complete. </p>

@param  src
        The buffer from which bytes are to be retrieved

@return The number of bytes written, possibly zero

@throws  NonWritableChannelException
         If this channel was not opened for writing

@throws  ClosedChannelException
         If this channel is closed

@throws  AsynchronousCloseException
         If another thread closes this channel
         while the write operation is in progress

@throws  ClosedByInterruptException
         If another thread interrupts the current thread
         while the write operation is in progress, thereby
         closing the channel and setting the current thread's
         interrupt status

@throws  IOException
         If some other I/O error occurs
"
      end
    end

    class 986754 "CancelledKeyException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when an attempt is made to use
a selection key that is no longer valid.

@since 1.4
"
      classrelation 3292290 // <generalisation>
	relation 3292290 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3292290 // <generalisation>
	  b parent class_ref 254850 // IllegalStateException
      end

      attribute 1808258 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " -8438032138028814268L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7776642 "CancelledKeyException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 986882 "Channels"
      visibility public 
      cpp_decl ""
      final java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Utility methods for channels and streams.

<p> This class defines static methods that support the interoperation of the
stream classes of the <tt>{@link java.io}</tt> package with the channel
classes of this package.  </p>


@author Mark Reinhold
@author Mike McCloskey
@author JSR-51 Expert Group
@since 1.4
"
      operation 7776770 "Channels"
	private explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 7776898 "checkNotNull"
	class_operation private explicit_return_type "void"
	nparams 2
	  param inout name "o" type class_ref 129538 // Object
	  param inout name "name" type class_ref 128130 // String
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " No instantiation"
      end

      operation 7777026 "writeFullyImpl"
	class_operation private explicit_return_type "void"
	nparams 2
	  param inout name "ch" type class_ref 986626 // WritableByteChannel
	  param inout name "bb" type class_ref 149890 // ByteBuffer
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Write all remaining bytes in buffer to the given channel.
If the channel is selectable then it must be configured blocking.
"
      end

      operation 7777154 "writeFully"
	class_operation private explicit_return_type "void"
	nparams 2
	  param inout name "ch" type class_ref 986626 // WritableByteChannel
	  param inout name "bb" type class_ref 149890 // ByteBuffer
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Write all remaining bytes in buffer to the given channel.

@throws  IllegalBlockingModeException
         If the channel is selectable and configured non-blocking.
"
      end

      operation 7777282 "newInputStream"
	class_operation public return_type class_ref 146434 // InputStream
	nparams 1
	  param inout name "ch" type class_ref 986498 // ReadableByteChannel
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " -- Byte streams from channels --

Constructs a stream that reads bytes from the given channel.

<p> The <tt>read</tt> methods of the resulting stream will throw an
{@link IllegalBlockingModeException} if invoked while the underlying
channel is in non-blocking mode.  The stream will not be buffered, and
it will not support the {@link InputStream#mark mark} or {@link
InputStream#reset reset} methods.  The stream will be safe for access by
multiple concurrent threads.  Closing the stream will in turn cause the
channel to be closed.  </p>

@param  ch
        The channel from which bytes will be read

@return  A new input stream
"
      end

      operation 7777410 "newOutputStream"
	class_operation public return_type class_ref 151298 // OutputStream
	nparams 1
	  param in name "ch" type class_ref 986626 // WritableByteChannel
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}final ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs a stream that writes bytes to the given channel.

<p> The <tt>write</tt> methods of the resulting stream will throw an
{@link IllegalBlockingModeException} if invoked while the underlying
channel is in non-blocking mode.  The stream will not be buffered.  The
stream will be safe for access by multiple concurrent threads.  Closing
the stream will in turn cause the channel to be closed.  </p>

@param  ch
        The channel to which bytes will be written

@return  A new output stream
"
      end

      operation 7777538 "newInputStream"
	class_operation public return_type class_ref 146434 // InputStream
	nparams 1
	  param in name "ch" type class_ref 984322 // AsynchronousByteChannel
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}final ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs a stream that reads bytes from the given channel.

<p> The stream will not be buffered, and it will not support the {@link
InputStream#mark mark} or {@link InputStream#reset reset} methods.  The
stream will be safe for access by multiple concurrent threads.  Closing
the stream will in turn cause the channel to be closed.  </p>

@param  ch
        The channel from which bytes will be read

@return  A new input stream

@since 1.7
"
      end

      operation 7777666 "newOutputStream"
	class_operation public return_type class_ref 151298 // OutputStream
	nparams 1
	  param in name "ch" type class_ref 984322 // AsynchronousByteChannel
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}final ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs a stream that writes bytes to the given channel.

<p> The stream will not be buffered. The stream will be safe for access
by multiple concurrent threads.  Closing the stream will in turn cause
the channel to be closed.  </p>

@param  ch
        The channel to which bytes will be written

@return  A new output stream

@since 1.7
"
      end

      operation 7777794 "newChannel"
	class_operation public return_type class_ref 986498 // ReadableByteChannel
	nparams 1
	  param in name "in" type class_ref 146434 // InputStream
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}final ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " -- Channels from streams --

Constructs a channel that reads bytes from the given stream.

<p> The resulting channel will not be buffered; it will simply redirect
its I/O operations to the given stream.  Closing the channel will in
turn cause the stream to be closed.  </p>

@param  in
        The stream from which bytes are to be read

@return  A new readable byte channel
"
      end

      class 987010 "ReadableByteChannelImpl"
	visibility private 
	cpp_decl ""
	static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3293058 // <generalisation>
	  relation 3293058 ---|>
	    a public
	      java "${type}"
	      classrelation_ref 3293058 // <generalisation>
	    b parent class_ref 987138 // AbstractInterruptibleChannel
	end

	classrelation 3293186 // <realization>
	  relation 3293186 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 3293186 // <realization>
	    b parent class_ref 986498 // ReadableByteChannel
	end

	classrelation 3293314 // in (<unidirectional association>)
	  relation 3293314 --->
	    a role_name "in" package
	      comment " Not really interruptible
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3293314 // in (<unidirectional association>)
	    b parent class_ref 146434 // InputStream
	end

	attribute 1808642 "TRANSFER_SIZE"
	  class_attribute const_attribute private explicit_type "int"
	  init_value " 8192"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	attribute 1808770 "buf"
	  private explicit_type "byte"
	  multiplicity "[]"
	  init_value " new byte[0]"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}${multiplicity} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	attribute 1808898 "open"
	  private explicit_type "boolean"
	  init_value " true"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	classrelation 3293442 // readLock (<unidirectional association>)
	  relation 3293442 --->
	    a role_name "readLock" init_value " new Object()" private
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3293442 // readLock (<unidirectional association>)
	    b parent class_ref 129538 // Object
	end

	operation 7778946 "ReadableByteChannelImpl"
	  package explicit_return_type ""
	  nparams 1
	    param inout name "in" type class_ref 146434 // InputStream
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7779074 "read"
	  public explicit_return_type "int"
	  nparams 1
	    param inout name "dst" type class_ref 149890 // ByteBuffer
	  nexceptions 1
	    exception class_ref 146818 // IOException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7779202 "implCloseChannel"
	  protected explicit_return_type "void"
	  nparams 0
	  nexceptions 1
	    exception class_ref 146818 // IOException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      operation 7779330 "newChannel"
	class_operation public return_type class_ref 986626 // WritableByteChannel
	nparams 1
	  param in name "out" type class_ref 151298 // OutputStream
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}final ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs a channel that writes bytes to the given stream.

<p> The resulting channel will not be buffered; it will simply redirect
its I/O operations to the given stream.  Closing the channel will in
turn cause the stream to be closed.  </p>

@param  out
        The stream to which bytes are to be written

@return  A new writable byte channel
"
      end

      class 987394 "WritableByteChannelImpl"
	visibility private 
	cpp_decl ""
	static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3293570 // <generalisation>
	  relation 3293570 ---|>
	    a public
	      java "${type}"
	      classrelation_ref 3293570 // <generalisation>
	    b parent class_ref 987138 // AbstractInterruptibleChannel
	end

	classrelation 3293698 // <realization>
	  relation 3293698 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 3293698 // <realization>
	    b parent class_ref 986626 // WritableByteChannel
	end

	classrelation 3293826 // out (<unidirectional association>)
	  relation 3293826 --->
	    a role_name "out" package
	      comment " Not really interruptible
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3293826 // out (<unidirectional association>)
	    b parent class_ref 151298 // OutputStream
	end

	attribute 1809026 "TRANSFER_SIZE"
	  class_attribute const_attribute private explicit_type "int"
	  init_value " 8192"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	attribute 1809154 "buf"
	  private explicit_type "byte"
	  multiplicity "[]"
	  init_value " new byte[0]"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type}${multiplicity} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	attribute 1809282 "open"
	  private explicit_type "boolean"
	  init_value " true"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	classrelation 3293954 // writeLock (<unidirectional association>)
	  relation 3293954 --->
	    a role_name "writeLock" init_value " new Object()" private
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3293954 // writeLock (<unidirectional association>)
	    b parent class_ref 129538 // Object
	end

	operation 7779458 "WritableByteChannelImpl"
	  package explicit_return_type ""
	  nparams 1
	    param inout name "out" type class_ref 151298 // OutputStream
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7779586 "write"
	  public explicit_return_type "int"
	  nparams 1
	    param inout name "src" type class_ref 149890 // ByteBuffer
	  nexceptions 1
	    exception class_ref 146818 // IOException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 7779714 "implCloseChannel"
	  protected explicit_return_type "void"
	  nparams 0
	  nexceptions 1
	    exception class_ref 146818 // IOException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      operation 7779842 "newReader"
	class_operation public return_type class_ref 407298 // Reader
	nparams 3
	  param inout name "ch" type class_ref 986498 // ReadableByteChannel
	  param inout name "dec" type class_ref 167554 // CharsetDecoder
	  param in name "minBufferCap" explicit_type "int"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " -- Character streams from channels --

Constructs a reader that decodes bytes from the given channel using the
given decoder.

<p> The resulting stream will contain an internal input buffer of at
least <tt>minBufferCap</tt> bytes.  The stream's <tt>read</tt> methods
will, as needed, fill the buffer by reading bytes from the underlying
channel; if the channel is in non-blocking mode when bytes are to be
read then an {@link IllegalBlockingModeException} will be thrown.  The
resulting stream will not otherwise be buffered, and it will not support
the {@link Reader#mark mark} or {@link Reader#reset reset} methods.
Closing the stream will in turn cause the channel to be closed.  </p>

@param  ch
        The channel from which bytes will be read

@param  dec
        The charset decoder to be used

@param  minBufferCap
        The minimum capacity of the internal byte buffer,
        or <tt>-1</tt> if an implementation-dependent
        default capacity is to be used

@return  A new reader
"
      end

      operation 7779970 "newReader"
	class_operation public return_type class_ref 407298 // Reader
	nparams 2
	  param inout name "ch" type class_ref 986498 // ReadableByteChannel
	  param inout name "csName" type class_ref 128130 // String
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs a reader that decodes bytes from the given channel according
to the named charset.

<p> An invocation of this method of the form

<blockquote><pre>
Channels.newReader(ch, csname)</pre></blockquote>

behaves in exactly the same way as the expression

<blockquote><pre>
Channels.newReader(ch,
                   Charset.forName(csName)
                       .newDecoder(),
                   -1);</pre></blockquote>

@param  ch
        The channel from which bytes will be read

@param  csName
        The name of the charset to be used

@return  A new reader

@throws  UnsupportedCharsetException
         If no support for the named charset is available
         in this instance of the Java virtual machine
"
      end

      operation 7780098 "newWriter"
	class_operation public return_type class_ref 428034 // Writer
	nparams 3
	  param in name "ch" type class_ref 986626 // WritableByteChannel
	  param in name "enc" type class_ref 167682 // CharsetEncoder
	  param in name "minBufferCap" explicit_type "int"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}final ${t0} ${p0}, final ${t1} ${p1}, final ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs a writer that encodes characters using the given encoder and
writes the resulting bytes to the given channel.

<p> The resulting stream will contain an internal output buffer of at
least <tt>minBufferCap</tt> bytes.  The stream's <tt>write</tt> methods
will, as needed, flush the buffer by writing bytes to the underlying
channel; if the channel is in non-blocking mode when bytes are to be
written then an {@link IllegalBlockingModeException} will be thrown.
The resulting stream will not otherwise be buffered.  Closing the stream
will in turn cause the channel to be closed.  </p>

@param  ch
        The channel to which bytes will be written

@param  enc
        The charset encoder to be used

@param  minBufferCap
        The minimum capacity of the internal byte buffer,
        or <tt>-1</tt> if an implementation-dependent
        default capacity is to be used

@return  A new writer
"
      end

      operation 7780226 "newWriter"
	class_operation public return_type class_ref 428034 // Writer
	nparams 2
	  param inout name "ch" type class_ref 986626 // WritableByteChannel
	  param inout name "csName" type class_ref 128130 // String
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs a writer that encodes characters according to the named
charset and writes the resulting bytes to the given channel.

<p> An invocation of this method of the form

<blockquote><pre>
Channels.newWriter(ch, csname)</pre></blockquote>

behaves in exactly the same way as the expression

<blockquote><pre>
Channels.newWriter(ch,
                   Charset.forName(csName)
                       .newEncoder(),
                   -1);</pre></blockquote>

@param  ch
        The channel to which bytes will be written

@param  csName
        The name of the charset to be used

@return  A new writer

@throws  UnsupportedCharsetException
         If no support for the named charset is available
         in this instance of the Java virtual machine
"
      end
    end

    class 987266 "InterruptibleChannel"
      visibility public stereotype "interface"
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A channel that can be asynchronously closed and interrupted.

<p> A channel that implements this interface is <i>asynchronously
closeable:</i> If a thread is blocked in an I/O operation on an
interruptible channel then another thread may invoke the channel's {@link
#close close} method.  This will cause the blocked thread to receive an
{@link AsynchronousCloseException}.

<p> A channel that implements this interface is also <i>interruptible:</i>
If a thread is blocked in an I/O operation on an interruptible channel then
another thread may invoke the blocked thread's {@link Thread#interrupt()
interrupt} method.  This will cause the channel to be closed, the blocked
thread to receive a {@link ClosedByInterruptException}, and the blocked
thread's interrupt status to be set.

<p> If a thread's interrupt status is already set and it invokes a blocking
I/O operation upon a channel then the channel will be closed and the thread
will immediately receive a {@link ClosedByInterruptException}; its interrupt
status will remain set.

<p> A channel supports asynchronous closing and interruption if, and only
if, it implements this interface.  This can be tested at runtime, if
necessary, via the <tt>instanceof</tt> operator.


@author Mark Reinhold
@author JSR-51 Expert Group
@since 1.4
"
      classrelation 3292546 // <generalisation>
	relation 3292546 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3292546 // <generalisation>
	  b parent class_ref 940034 // Channel
      end

      operation 7777922 "close"
	public explicit_return_type "void"
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Closes this channel.

<p> Any thread currently blocked in an I/O operation upon this channel
will receive an {@link AsynchronousCloseException}.

<p> This method otherwise behaves exactly as specified by the {@link
Channel#close Channel} interface.  </p>

@throws  IOException  If an I/O error occurs
"
      end
    end

    class 987522 "ClosedByInterruptException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Checked exception received by a thread when another thread interrupts it
while it is blocked in an I/O operation upon a channel.  Before this
exception is thrown the channel will have been closed and the interrupt
status of the previously-blocked thread will have been set.

@since 1.4
"
      classrelation 3294082 // <generalisation>
	relation 3294082 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3294082 // <generalisation>
	  b parent class_ref 985346 // AsynchronousCloseException
      end

      attribute 1809410 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " -4488191543534286750L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7780354 "ClosedByInterruptException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 987650 "ClosedSelectorException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when an attempt is made to invoke an I/O
operation upon a closed selector.

@since 1.4
"
      classrelation 3294210 // <generalisation>
	relation 3294210 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3294210 // <generalisation>
	  b parent class_ref 254850 // IllegalStateException
      end

      attribute 1809538 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 6466297122317847835L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7780482 "ClosedSelectorException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 987778 "ConnectionPendingException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when an attempt is made to connect a {@link
SocketChannel} for which a non-blocking connection operation is already in
progress.

@since 1.4
"
      classrelation 3294338 // <generalisation>
	relation 3294338 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3294338 // <generalisation>
	  b parent class_ref 254850 // IllegalStateException
      end

      attribute 1809666 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 2008393366501760879L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7780866 "ConnectionPendingException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 988162 "ScatteringByteChannel"
      visibility public stereotype "interface"
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A channel that can read bytes into a sequence of buffers.

<p> A <i>scattering</i> read operation reads, in a single invocation, a
sequence of bytes into one or more of a given sequence of buffers.
Scattering reads are often useful when implementing network protocols or
file formats that, for example, group data into segments consisting of one
or more fixed-length headers followed by a variable-length body.  Similar
<i>gathering</i> write operations are defined in the {@link
GatheringByteChannel} interface.  </p>


@author Mark Reinhold
@author JSR-51 Expert Group
@since 1.4
"
      classrelation 3295618 // <generalisation>
	relation 3295618 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3295618 // <generalisation>
	  b parent class_ref 986498 // ReadableByteChannel
      end

      operation 7784194 "read"
	public explicit_return_type "long"
	nparams 3
	  param inout name "dsts" type class_ref 149890 // ByteBuffer
	multiplicity "[]"
	  param in name "offset" explicit_type "int"
	  param in name "length" explicit_type "int"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0}[] ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Reads a sequence of bytes from this channel into a subsequence of the
given buffers.

<p> An invocation of this method attempts to read up to <i>r</i> bytes
from this channel, where <i>r</i> is the total number of bytes remaining
the specified subsequence of the given buffer array, that is,

<blockquote><pre>
dsts[offset].remaining()
    + dsts[offset+1].remaining()
    + ... + dsts[offset+length-1].remaining()</pre></blockquote>

at the moment that this method is invoked.

<p> Suppose that a byte sequence of length <i>n</i> is read, where
<tt>0</tt>&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
Up to the first <tt>dsts[offset].remaining()</tt> bytes of this sequence
are transferred into buffer <tt>dsts[offset]</tt>, up to the next
<tt>dsts[offset+1].remaining()</tt> bytes are transferred into buffer
<tt>dsts[offset+1]</tt>, and so forth, until the entire byte sequence
is transferred into the given buffers.  As many bytes as possible are
transferred into each buffer, hence the final position of each updated
buffer, except the last updated buffer, is guaranteed to be equal to
that buffer's limit.

<p> This method may be invoked at any time.  If another thread has
already initiated a read operation upon this channel, however, then an
invocation of this method will block until the first operation is
complete. </p>

@param  dsts
        The buffers into which bytes are to be transferred

@param  offset
        The offset within the buffer array of the first buffer into
        which bytes are to be transferred; must be non-negative and no
        larger than <tt>dsts.length</tt>

@param  length
        The maximum number of buffers to be accessed; must be
        non-negative and no larger than
        <tt>dsts.length</tt>&nbsp;-&nbsp;<tt>offset</tt>

@return The number of bytes read, possibly zero,
        or <tt>-1</tt> if the channel has reached end-of-stream

@throws  IndexOutOfBoundsException
         If the preconditions on the <tt>offset</tt> and <tt>length</tt>
         parameters do not hold

@throws  NonReadableChannelException
         If this channel was not opened for reading

@throws  ClosedChannelException
         If this channel is closed

@throws  AsynchronousCloseException
         If another thread closes this channel
         while the read operation is in progress

@throws  ClosedByInterruptException
         If another thread interrupts the current thread
         while the read operation is in progress, thereby
         closing the channel and setting the current thread's
         interrupt status

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7784322 "read"
	public explicit_return_type "long"
	nparams 1
	  param inout name "dsts" type class_ref 149890 // ByteBuffer
	multiplicity "[]"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0}[] ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Reads a sequence of bytes from this channel into the given buffers.

<p> An invocation of this method of the form <tt>c.read(dsts)</tt>
behaves in exactly the same manner as the invocation

<blockquote><pre>
c.read(dsts, 0, dsts.length);</pre></blockquote>

@param  dsts
        The buffers into which bytes are to be transferred

@return The number of bytes read, possibly zero,
        or <tt>-1</tt> if the channel has reached end-of-stream

@throws  NonReadableChannelException
         If this channel was not opened for reading

@throws  ClosedChannelException
         If this channel is closed

@throws  AsynchronousCloseException
         If another thread closes this channel
         while the read operation is in progress

@throws  ClosedByInterruptException
         If another thread interrupts the current thread
         while the read operation is in progress, thereby
         closing the channel and setting the current thread's
         interrupt status

@throws  IOException
         If some other I/O error occurs
"
      end
    end

    class 988290 "GatheringByteChannel"
      visibility public stereotype "interface"
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A channel that can write bytes from a sequence of buffers.

<p> A <i>gathering</i> write operation writes, in a single invocation, a
sequence of bytes from one or more of a given sequence of buffers.
Gathering writes are often useful when implementing network protocols or
file formats that, for example, group data into segments consisting of one
or more fixed-length headers followed by a variable-length body.  Similar
<i>scattering</i> read operations are defined in the {@link
ScatteringByteChannel} interface.  </p>


@author Mark Reinhold
@author JSR-51 Expert Group
@since 1.4
"
      classrelation 3295874 // <generalisation>
	relation 3295874 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3295874 // <generalisation>
	  b parent class_ref 986626 // WritableByteChannel
      end

      operation 7784450 "write"
	public explicit_return_type "long"
	nparams 3
	  param inout name "srcs" type class_ref 149890 // ByteBuffer
	multiplicity "[]"
	  param in name "offset" explicit_type "int"
	  param in name "length" explicit_type "int"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0}[] ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Writes a sequence of bytes to this channel from a subsequence of the
given buffers.

<p> An attempt is made to write up to <i>r</i> bytes to this channel,
where <i>r</i> is the total number of bytes remaining in the specified
subsequence of the given buffer array, that is,

<blockquote><pre>
srcs[offset].remaining()
    + srcs[offset+1].remaining()
    + ... + srcs[offset+length-1].remaining()</pre></blockquote>

at the moment that this method is invoked.

<p> Suppose that a byte sequence of length <i>n</i> is written, where
<tt>0</tt>&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
Up to the first <tt>srcs[offset].remaining()</tt> bytes of this sequence
are written from buffer <tt>srcs[offset]</tt>, up to the next
<tt>srcs[offset+1].remaining()</tt> bytes are written from buffer
<tt>srcs[offset+1]</tt>, and so forth, until the entire byte sequence is
written.  As many bytes as possible are written from each buffer, hence
the final position of each updated buffer, except the last updated
buffer, is guaranteed to be equal to that buffer's limit.

<p> Unless otherwise specified, a write operation will return only after
writing all of the <i>r</i> requested bytes.  Some types of channels,
depending upon their state, may write only some of the bytes or possibly
none at all.  A socket channel in non-blocking mode, for example, cannot
write any more bytes than are free in the socket's output buffer.

<p> This method may be invoked at any time.  If another thread has
already initiated a write operation upon this channel, however, then an
invocation of this method will block until the first operation is
complete. </p>

@param  srcs
        The buffers from which bytes are to be retrieved

@param  offset
        The offset within the buffer array of the first buffer from
        which bytes are to be retrieved; must be non-negative and no
        larger than <tt>srcs.length</tt>

@param  length
        The maximum number of buffers to be accessed; must be
        non-negative and no larger than
        <tt>srcs.length</tt>&nbsp;-&nbsp;<tt>offset</tt>

@return  The number of bytes written, possibly zero

@throws  IndexOutOfBoundsException
         If the preconditions on the <tt>offset</tt> and <tt>length</tt>
         parameters do not hold

@throws  NonWritableChannelException
         If this channel was not opened for writing

@throws  ClosedChannelException
         If this channel is closed

@throws  AsynchronousCloseException
         If another thread closes this channel
         while the write operation is in progress

@throws  ClosedByInterruptException
         If another thread interrupts the current thread
         while the write operation is in progress, thereby
         closing the channel and setting the current thread's
         interrupt status

@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7784578 "write"
	public explicit_return_type "long"
	nparams 1
	  param inout name "srcs" type class_ref 149890 // ByteBuffer
	multiplicity "[]"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0}[] ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Writes a sequence of bytes to this channel from the given buffers.

<p> An invocation of this method of the form <tt>c.write(srcs)</tt>
behaves in exactly the same manner as the invocation

<blockquote><pre>
c.write(srcs, 0, srcs.length);</pre></blockquote>

@param  srcs
        The buffers from which bytes are to be retrieved

@return  The number of bytes written, possibly zero

@throws  NonWritableChannelException
         If this channel was not opened for writing

@throws  ClosedChannelException
         If this channel is closed

@throws  AsynchronousCloseException
         If another thread closes this channel
         while the write operation is in progress

@throws  ClosedByInterruptException
         If another thread interrupts the current thread
         while the write operation is in progress, thereby
         closing the channel and setting the current thread's
         interrupt status

@throws  IOException
         If some other I/O error occurs
"
      end
    end

    class 988418 "MulticastChannel"
      visibility public stereotype "interface"
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A network channel that supports Internet Protocol (IP) multicasting.

<p> IP multicasting is the transmission of IP datagrams to members of
a <em>group</em> that is zero or more hosts identified by a single destination
address.

<p> In the case of a channel to an {@link StandardProtocolFamily#INET IPv4} socket,
the underlying operating system supports <a href=\"http://www.ietf.org/rfc/rfc2236.txt\">
<i>RFC&nbsp;2236: Internet Group Management Protocol, Version 2 (IGMPv2)</i></a>.
It may optionally support source filtering as specified by <a
href=\"http://www.ietf.org/rfc/rfc3376.txt\"> <i>RFC&nbsp;3376: Internet Group
Management Protocol, Version 3 (IGMPv3)</i></a>.
For channels to an {@link StandardProtocolFamily#INET6 IPv6} socket, the equivalent
standards are <a href=\"http://www.ietf.org/rfc/rfc2710.txt\"> <i>RFC&nbsp;2710:
Multicast Listener Discovery (MLD) for IPv6</i></a> and <a
href=\"http://www.ietf.org/rfc/rfc3810.txt\"> <i>RFC&nbsp;3810: Multicast Listener
Discovery Version 2 (MLDv2) for IPv6</i></a>.

<p> The {@link #join(InetAddress,NetworkInterface)} method is used to
join a group and receive all multicast datagrams sent to the group. A channel
may join several multicast groups and may join the same group on several
{@link NetworkInterface interfaces}. Membership is dropped by invoking the {@link
MembershipKey#drop drop} method on the returned {@link MembershipKey}. If the
underlying platform supports source filtering then the {@link MembershipKey#block
block} and {@link MembershipKey#unblock unblock} methods can be used to block or
unblock multicast datagrams from particular source addresses.

<p> The {@link #join(InetAddress,NetworkInterface,InetAddress)} method
is used to begin receiving datagrams sent to a group whose source address matches
a given source address. This method throws {@link UnsupportedOperationException}
if the underlying platform does not support source filtering.  Membership is
<em>cumulative</em> and this method may be invoked again with the same group
and interface to allow receiving datagrams from other source addresses. The
method returns a {@link MembershipKey} that represents membership to receive
datagrams from the given source address. Invoking the key's {@link
MembershipKey#drop drop} method drops membership so that datagrams from the
source address can no longer be received.

<h2>Platform dependencies</h2>

The multicast implementation is intended to map directly to the native
multicasting facility. Consequently, the following items should be considered
when developing an application that receives IP multicast datagrams:

<ol>

<li><p> The creation of the channel should specify the {@link ProtocolFamily}
that corresponds to the address type of the multicast groups that the channel
will join. There is no guarantee that a channel to a socket in one protocol
family can join and receive multicast datagrams when the address of the
multicast group corresponds to another protocol family. For example, it is
implementation specific if a channel to an {@link StandardProtocolFamily#INET6 IPv6}
socket can join an {@link StandardProtocolFamily#INET IPv4} multicast group and receive
multicast datagrams sent to the group. </p></li>

<li><p> The channel's socket should be bound to the {@link
InetAddress#isAnyLocalAddress wildcard} address. If the socket is bound to
a specific address, rather than the wildcard address then it is implementation
specific if multicast datagrams are received by the socket. </p></li>

<li><p> The {@link StandardSocketOptions#SO_REUSEADDR SO_REUSEADDR} option should be
enabled prior to {@link NetworkChannel#bind binding} the socket. This is
required to allow multiple members of the group to bind to the same
address. </p></li>

</ol>

<p> <b>Usage Example:</b>
<pre>
    // join multicast group on this interface, and also use this
    // interface for outgoing multicast datagrams
    NetworkInterface ni = NetworkInterface.getByName(\"hme0\");

    DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET)
        .setOption(StandardSocketOptions.SO_REUSEADDR, true)
        .bind(new InetSocketAddress(5000))
        .setOption(StandardSocketOptions.IP_MULTICAST_IF, ni);

    InetAddress group = InetAddress.getByName(\"225.4.5.6\");

    MembershipKey key = dc.join(group, ni);
</pre>

@since 1.7
"
      classrelation 3296130 // <generalisation>
	relation 3296130 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3296130 // <generalisation>
	  b parent class_ref 986114 // NetworkChannel
      end

      operation 7784706 "close"
	public explicit_return_type "void"
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
	comment "Closes this channel.

<p> If the channel is a member of a multicast group then the membership
is {@link MembershipKey#drop dropped}. Upon return, the {@link
MembershipKey membership-key} will be {@link MembershipKey#isValid
invalid}.

<p> This method otherwise behaves exactly as specified by the {@link
Channel} interface.

@throws  IOException
         If an I/O error occurs
"
      end

      operation 7784834 "join"
	public return_type class_ref 988546 // MembershipKey
	nparams 2
	  param inout name "group" type class_ref 513154 // InetAddress
	  param inout name "interf" type class_ref 962306 // NetworkInterface
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Joins a multicast group to begin receiving all datagrams sent to the group,
returning a membership key.

<p> If this channel is currently a member of the group on the given
interface to receive all datagrams then the membership key, representing
that membership, is returned. Otherwise this channel joins the group and
the resulting new membership key is returned. The resulting membership key
is not {@link MembershipKey#sourceAddress source-specific}.

<p> A multicast channel may join several multicast groups, including
the same group on more than one interface. An implementation may impose a
limit on the number of groups that may be joined at the same time.

@param   group
         The multicast address to join
@param   interf
         The network interface on which to join the group

@return  The membership key

@throws  IllegalArgumentException
         If the group parameter is not a {@link InetAddress#isMulticastAddress
         multicast} address, or the group parameter is an address type
         that is not supported by this channel
@throws  IllegalStateException
         If the channel already has source-specific membership of the
         group on the interface
@throws  UnsupportedOperationException
         If the channel's socket is not an Internet Protocol socket
@throws  ClosedChannelException
         If this channel is closed
@throws  IOException
         If an I/O error occurs
@throws  SecurityException
         If a security manager is set, and its
         {@link SecurityManager#checkMulticast(InetAddress) checkMulticast}
         method denies access to the multiast group
"
      end

      operation 7784962 "join"
	public return_type class_ref 988546 // MembershipKey
	nparams 3
	  param inout name "group" type class_ref 513154 // InetAddress
	  param inout name "interf" type class_ref 962306 // NetworkInterface
	  param inout name "source" type class_ref 513154 // InetAddress
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Joins a multicast group to begin receiving datagrams sent to the group
from a given source address.

<p> If this channel is currently a member of the group on the given
interface to receive datagrams from the given source address then the
membership key, representing that membership, is returned. Otherwise this
channel joins the group and the resulting new membership key is returned.
The resulting membership key is {@link MembershipKey#sourceAddress
source-specific}.

<p> Membership is <em>cumulative</em> and this method may be invoked
again with the same group and interface to allow receiving datagrams sent
by other source addresses to the group.

@param   group
         The multicast address to join
@param   interf
         The network interface on which to join the group
@param   source
         The source address

@return  The membership key

@throws  IllegalArgumentException
         If the group parameter is not a {@link
         InetAddress#isMulticastAddress multicast} address, the
         source parameter is not a unicast address, the group
         parameter is an address type that is not supported by this channel,
         or the source parameter is not the same address type as the group
@throws  IllegalStateException
         If the channel is currently a member of the group on the given
         interface to receive all datagrams
@throws  UnsupportedOperationException
         If the channel's socket is not an Internet Protocol socket or
         source filtering is not supported
@throws  ClosedChannelException
         If this channel is closed
@throws  IOException
         If an I/O error occurs
@throws  SecurityException
         If a security manager is set, and its
         {@link SecurityManager#checkMulticast(InetAddress) checkMulticast}
         method denies access to the multiast group
"
      end
    end

    class 988546 "MembershipKey"
      abstract visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A token representing the membership of an Internet Protocol (IP) multicast
group.

<p> A membership key may represent a membership to receive all datagrams sent
to the group, or it may be <em>source-specific</em>, meaning that it
represents a membership that receives only datagrams from a specific source
address. Whether or not a membership key is source-specific may be determined
by invoking its {@link #sourceAddress() sourceAddress} method.

<p> A membership key is valid upon creation and remains valid until the
membership is dropped by invoking the {@link #drop() drop} method, or
the channel is closed. The validity of the membership key may be tested
by invoking its {@link #isValid() isValid} method.

<p> Where a membership key is not source-specific and the underlying operation
system supports source filtering, then the {@link #block block} and {@link
#unblock unblock} methods can be used to block or unblock multicast datagrams
from particular source addresses.

@see MulticastChannel

@since 1.7
"
      operation 7793794 "MembershipKey"
	protected explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Initializes a new instance of this class.
"
      end

      operation 7793922 "isValid"
	abstract public explicit_return_type "boolean"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Tells whether or not this membership is valid.

<p> A multicast group membership is valid upon creation and remains
valid until the membership is dropped by invoking the {@link #drop() drop}
method, or the channel is closed.

@return  {@code true} if this membership key is valid, {@code false}
         otherwise
"
      end

      operation 7794050 "drop"
	abstract public explicit_return_type "void"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Drop membership.

<p> If the membership key represents a membership to receive all datagrams
then the membership is dropped and the channel will no longer receive any
datagrams sent to the group. If the membership key is source-specific
then the channel will no longer receive datagrams sent to the group from
that source address.

<p> After membership is dropped it may still be possible to receive
datagrams sent to the group. This can arise when datagrams are waiting to
be received in the socket's receive buffer. After membership is dropped
then the channel may {@link MulticastChannel#join join} the group again
in which case a new membership key is returned.

<p> Upon return, this membership object will be {@link #isValid() invalid}.
If the multicast group membership is already invalid then invoking this
method has no effect. Once a multicast group membership is invalid,
it remains invalid forever.
"
      end

      operation 7794178 "block"
	abstract public return_type class_ref 988546 // MembershipKey
	nparams 1
	  param inout name "source" type class_ref 513154 // InetAddress
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Block multicast datagrams from the given source address.

<p> If this membership key is not source-specific, and the underlying
operating system supports source filtering, then this method blocks
multicast datagrams from the given source address. If the given source
address is already blocked then this method has no effect.
After a source address is blocked it may still be possible to receive
datagrams from that source. This can arise when datagrams are waiting to
be received in the socket's receive buffer.

@param   source
         The source address to block

@return  This membership key

@throws  IllegalArgumentException
         If the {@code source} parameter is not a unicast address or
         is not the same address type as the multicast group
@throws  IllegalStateException
         If this membership key is source-specific or is no longer valid
@throws  UnsupportedOperationException
         If the underlying operating system does not support source
         filtering
@throws  IOException
         If an I/O error occurs
"
      end

      operation 7794306 "unblock"
	abstract public return_type class_ref 988546 // MembershipKey
	nparams 1
	  param inout name "source" type class_ref 513154 // InetAddress
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Unblock multicast datagrams from the given source address that was
previously blocked using the {@link #block(InetAddress) block} method.

@param   source
         The source address to unblock

@return  This membership key

@throws  IllegalStateException
         If the given source address is not currently blocked or the
         membership key is no longer valid
"
      end

      operation 7794434 "channel"
	abstract public return_type class_ref 988418 // MulticastChannel
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the channel for which this membership key was created. This
method will continue to return the channel even after the membership
becomes {@link #isValid invalid}.

@return  the channel
"
      end

      operation 7794562 "group"
	abstract public return_type class_ref 513154 // InetAddress
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the multicast group for which this membership key was created.
This method will continue to return the group even after the membership
becomes {@link #isValid invalid}.

@return  the multicast group
"
      end

      operation 7794690 "networkInterface"
	abstract public return_type class_ref 962306 // NetworkInterface
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the network interface for which this membership key was created.
This method will continue to return the network interface even after the
membership becomes {@link #isValid invalid}.

@return  the network interface
"
      end

      operation 7794818 "sourceAddress"
	abstract public return_type class_ref 513154 // InetAddress
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the source address if this membership key is source-specific,
or {@code null} if this membership is not source-specific.

@return  The source address if this membership key is source-specific,
         otherwise {@code null}
"
      end
    end

    class 988674 "SeekableByteChannel"
      visibility public stereotype "interface"
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A byte channel that maintains a current <i>position</i> and allows the
position to be changed.

<p> A seekable byte channel is connected to an entity, typically a file,
that contains a variable-length sequence of bytes that can be read and
written. The current position can be {@link #position() <i>queried</i>} and
{@link #position(long) <i>modified</i>}. The channel also provides access to
the current <i>size</i> of the entity to which the channel is connected. The
size increases when bytes are written beyond its current size; the size
decreases when it is {@link #truncate <i>truncated</i>}.

<p> The {@link #position(long) position} and {@link #truncate truncate} methods
which do not otherwise have a value to return are specified to return the
channel upon which they are invoked. This allows method invocations to be
chained. Implementations of this interface should specialize the return type
so that method invocations on the implementation class can be chained.

@since 1.7
@see java.nio.file.Files#newByteChannel
"
      classrelation 3296514 // <generalisation>
	relation 3296514 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3296514 // <generalisation>
	  b parent class_ref 986370 // ByteChannel
      end

      operation 7787650 "read"
	public explicit_return_type "int"
	nparams 1
	  param inout name "dst" type class_ref 149890 // ByteBuffer
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
	comment "Reads a sequence of bytes from this channel into the given buffer.

<p> Bytes are read starting at this channel's current position, and
then the position is updated with the number of bytes actually read.
Otherwise this method behaves exactly as specified in the {@link
ReadableByteChannel} interface.
"
      end

      operation 7787778 "write"
	public explicit_return_type "int"
	nparams 1
	  param inout name "src" type class_ref 149890 // ByteBuffer
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	java_annotation "@Override
"
	
	
	
	comment "Writes a sequence of bytes to this channel from the given buffer.

<p> Bytes are written starting at this channel's current position, unless
the channel is connected to an entity such as a file that is opened with
the {@link java.nio.file.StandardOpenOption#APPEND APPEND} option, in
which case the position is first advanced to the end. The entity to which
the channel is connected is grown, if necessary, to accommodate the
written bytes, and then the position is updated with the number of bytes
actually written. Otherwise this method behaves exactly as specified by
the {@link WritableByteChannel} interface.
"
      end

      operation 7787906 "position"
	public explicit_return_type "long"
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns this channel's position.

@return  This channel's position,
         a non-negative integer counting the number of bytes
         from the beginning of the entity to the current position

@throws  ClosedChannelException
         If this channel is closed
@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7788034 "position"
	public return_type class_ref 988674 // SeekableByteChannel
	nparams 1
	  param in name "newPosition" explicit_type "long"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sets this channel's position.

<p> Setting the position to a value that is greater than the current size
is legal but does not change the size of the entity.  A later attempt to
read bytes at such a position will immediately return an end-of-file
indication.  A later attempt to write bytes at such a position will cause
the entity to grow to accommodate the new bytes; the values of any bytes
between the previous end-of-file and the newly-written bytes are
unspecified.

<p> Setting the channel's position is not recommended when connected to
an entity, typically a file, that is opened with the {@link
java.nio.file.StandardOpenOption#APPEND APPEND} option. When opened for
append, the position is first advanced to the end before writing.

@param  newPosition
        The new position, a non-negative integer counting
        the number of bytes from the beginning of the entity

@return  This channel

@throws  ClosedChannelException
         If this channel is closed
@throws  IllegalArgumentException
         If the new position is negative
@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7788162 "size"
	public explicit_return_type "long"
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the current size of entity to which this channel is connected.

@return  The current size, measured in bytes

@throws  ClosedChannelException
         If this channel is closed
@throws  IOException
         If some other I/O error occurs
"
      end

      operation 7788290 "truncate"
	public return_type class_ref 988674 // SeekableByteChannel
	nparams 1
	  param in name "size" explicit_type "long"
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Truncates the entity, to which this channel is connected, to the given
size.

<p> If the given size is less than the current size then the entity is
truncated, discarding any bytes beyond the new end. If the given size is
greater than or equal to the current size then the entity is not modified.
In either case, if the current position is greater than the given size
then it is set to that size.

<p> An implementation of this interface may prohibit truncation when
connected to an entity, typically a file, opened with the {@link
java.nio.file.StandardOpenOption#APPEND APPEND} option.

@param  size
        The new size, a non-negative byte count

@return  This channel

@throws  NonWritableChannelException
         If this channel was not opened for writing
@throws  ClosedChannelException
         If this channel is closed
@throws  IllegalArgumentException
         If the new size is negative
@throws  IOException
         If some other I/O error occurs
"
      end
    end

    class 988930 "FileLockInterruptionException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Checked exception received by a thread when another thread interrupts it
while it is waiting to acquire a file lock.  Before this exception is thrown
the interrupt status of the previously-blocked thread will have been set.

@since 1.4
"
      classrelation 3297922 // <generalisation>
	relation 3297922 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3297922 // <generalisation>
	  b parent class_ref 146818 // IOException
      end

      attribute 1810434 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 7104080643653532383L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7793154 "FileLockInterruptionException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 989058 "IllegalBlockingModeException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when a blocking-mode-specific operation
is invoked upon a channel in the incorrect blocking mode.

@since 1.4
"
      classrelation 3298050 // <generalisation>
	relation 3298050 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3298050 // <generalisation>
	  b parent class_ref 254850 // IllegalStateException
      end

      attribute 1810562 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " -3335774961855590474L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7793282 "IllegalBlockingModeException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 989186 "IllegalChannelGroupException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when an attempt is made to open a channel
in a group that was not created by the same provider. 

@since 1.7
"
      classrelation 3298178 // <generalisation>
	relation 3298178 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3298178 // <generalisation>
	  b parent class_ref 187778 // IllegalArgumentException
      end

      attribute 1810690 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " -2495041211157744253L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7793410 "IllegalChannelGroupException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 989314 "IllegalSelectorException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when an attempt is made to register a channel
with a selector that was not created by the provider that created the
channel.

@since 1.4
"
      classrelation 3298306 // <generalisation>
	relation 3298306 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3298306 // <generalisation>
	  b parent class_ref 187778 // IllegalArgumentException
      end

      attribute 1810818 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " -8406323347253320987L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7793538 "IllegalSelectorException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 989442 "InterruptedByTimeoutException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Checked exception received by a thread when a timeout elapses before an
asynchronous operation completes.

@since 1.7
"
      classrelation 3298434 // <generalisation>
	relation 3298434 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3298434 // <generalisation>
	  b parent class_ref 146818 // IOException
      end

      attribute 1810946 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " -4268008601014042947L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7793666 "InterruptedByTimeoutException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 989570 "NoConnectionPendingException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when the {@link SocketChannel#finishConnect
finishConnect} method of a {@link SocketChannel} is invoked without first
successfully invoking its {@link SocketChannel#connect connect} method.

@since 1.4
"
      classrelation 3298562 // <generalisation>
	relation 3298562 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3298562 // <generalisation>
	  b parent class_ref 254850 // IllegalStateException
      end

      attribute 1811074 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " -8296561183633134743L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7794946 "NoConnectionPendingException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 989698 "NonReadableChannelException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when an attempt is made to read
from a channel that was not originally opened for reading.

@since 1.4
"
      classrelation 3298690 // <generalisation>
	relation 3298690 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3298690 // <generalisation>
	  b parent class_ref 254850 // IllegalStateException
      end

      attribute 1811202 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " -3200915679294993514L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7795074 "NonReadableChannelException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 989826 "NonWritableChannelException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when an attempt is made to write
to a channel that was not originally opened for writing.

@since 1.4
"
      classrelation 3298818 // <generalisation>
	relation 3298818 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3298818 // <generalisation>
	  b parent class_ref 254850 // IllegalStateException
      end

      attribute 1811330 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " -7071230488279011621L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7795202 "NonWritableChannelException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 989954 "NotYetBoundException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when an attempt is made to invoke an I/O
operation upon a server socket channel that is not yet bound.

@since 1.4
"
      classrelation 3298946 // <generalisation>
	relation 3298946 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3298946 // <generalisation>
	  b parent class_ref 254850 // IllegalStateException
      end

      attribute 1811458 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 4640999303950202242L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7795330 "NotYetBoundException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 990082 "NotYetConnectedException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when an attempt is made to invoke an I/O
operation upon a socket channel that is not yet connected.

@since 1.4
"
      classrelation 3299074 // <generalisation>
	relation 3299074 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3299074 // <generalisation>
	  b parent class_ref 254850 // IllegalStateException
      end

      attribute 1811586 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 4697316551909513464L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7795458 "NotYetConnectedException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 990210 "OverlappingFileLockException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when an attempt is made to acquire a lock on a
region of a file that overlaps a region already locked by the same Java
virtual machine, or when another thread is already waiting to lock an
overlapping region of the same file.

@since 1.4
"
      classrelation 3299202 // <generalisation>
	relation 3299202 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3299202 // <generalisation>
	  b parent class_ref 254850 // IllegalStateException
      end

      attribute 1811714 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 2047812138163068433L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7795586 "OverlappingFileLockException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 990338 "Pipe"
      abstract visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A pair of channels that implements a unidirectional pipe.

<p> A pipe consists of a pair of channels: A writable {@link
Pipe.SinkChannel sink} channel and a readable {@link Pipe.SourceChannel source}
channel.  Once some bytes are written to the sink channel they can be read
from source channel in exactlyAthe order in which they were written.

<p> Whether or not a thread writing bytes to a pipe will block until another
thread reads those bytes, or some previously-written bytes, from the pipe is
system-dependent and therefore unspecified.  Many pipe implementations will
buffer up to a certain number of bytes between the sink and source channels,
but such buffering should not be assumed.  </p>


@author Mark Reinhold
@author JSR-51 Expert Group
@since 1.4
"
      class 990466 "SourceChannel"
	abstract visibility public 
	cpp_decl ""
	static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3299330 // <generalisation>
	  relation 3299330 ---|>
	    a public
	      java "${type}"
	      classrelation_ref 3299330 // <generalisation>
	    b parent class_ref 987906 // AbstractSelectableChannel
	end

	classrelation 3299458 // <realization>
	  relation 3299458 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 3299458 // <realization>
	    b parent class_ref 986498 // ReadableByteChannel
	end

	classrelation 3299586 // <realization>
	  relation 3299586 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 3299586 // <realization>
	    b parent class_ref 988162 // ScatteringByteChannel
	end

	operation 7795714 "SourceChannel"
	  protected explicit_return_type ""
	  nparams 1
	    param inout name "provider" type class_ref 988034 // SelectorProvider
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Constructs a new instance of this class.

@param  provider
        The selector provider
"
	end

	operation 7795842 "validOps"
	  public explicit_return_type "int"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns an operation set identifying this channel's supported
operations.

<p> Pipe-source channels only support reading, so this method
returns {@link SelectionKey#OP_READ}.  </p>

@return  The valid-operation set
"
	end
      end

      class 990594 "SinkChannel"
	abstract visibility public 
	cpp_decl ""
	static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3299714 // <generalisation>
	  relation 3299714 ---|>
	    a public
	      java "${type}"
	      classrelation_ref 3299714 // <generalisation>
	    b parent class_ref 987906 // AbstractSelectableChannel
	end

	classrelation 3299842 // <realization>
	  relation 3299842 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 3299842 // <realization>
	    b parent class_ref 986626 // WritableByteChannel
	end

	classrelation 3299970 // <realization>
	  relation 3299970 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 3299970 // <realization>
	    b parent class_ref 988290 // GatheringByteChannel
	end

	operation 7795970 "SinkChannel"
	  protected explicit_return_type ""
	  nparams 1
	    param inout name "provider" type class_ref 988034 // SelectorProvider
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Initializes a new instance of this class.

@param  provider
        The selector provider
"
	end

	operation 7796098 "validOps"
	  public explicit_return_type "int"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns an operation set identifying this channel's supported
operations.

<p> Pipe-sink channels only support writing, so this method returns
{@link SelectionKey#OP_WRITE}.  </p>

@return  The valid-operation set
"
	end
      end

      operation 7796226 "Pipe"
	protected explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Initializes a new instance of this class.
"
      end

      operation 7796354 "source"
	abstract public return_type class_ref 990466 // SourceChannel
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns this pipe's source channel.

@return  This pipe's source channel
"
      end

      operation 7796482 "sink"
	abstract public return_type class_ref 990594 // SinkChannel
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns this pipe's sink channel.

@return  This pipe's sink channel
"
      end

      operation 7796610 "open"
	class_operation public return_type class_ref 990338 // Pipe
	nparams 0
	nexceptions 1
	  exception class_ref 146818 // IOException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Opens a pipe.

<p> The new pipe is created by invoking the {@link
java.nio.channels.spi.SelectorProvider#openPipe openPipe} method of the
system-wide default {@link java.nio.channels.spi.SelectorProvider}
object.  </p>

@return  A new pipe

@throws  IOException
         If an I/O error occurs
"
      end
    end

    class 990722 "ReadPendingException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when an attempt is made to read from an
asynchronous socket channel and a previous read has not completed.

@since 1.7
"
      classrelation 3300098 // <generalisation>
	relation 3300098 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3300098 // <generalisation>
	  b parent class_ref 254850 // IllegalStateException
      end

      attribute 1811842 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 1986315242191227217L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7796738 "ReadPendingException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 990850 "ShutdownChannelGroupException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when an attempt is made to construct a channel in 
a group that is shutdown or the completion handler for an I/O operation 
cannot be invoked because the channel group has terminated.

@since 1.7
"
      classrelation 3300866 // <generalisation>
	relation 3300866 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3300866 // <generalisation>
	  b parent class_ref 254850 // IllegalStateException
      end

      attribute 1812482 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " -3903801676350154157L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7801218 "ShutdownChannelGroupException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 990978 "UnresolvedAddressException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when an attempt is made to invoke a network
operation upon an unresolved socket address.

@since 1.4
"
      classrelation 3301634 // <generalisation>
	relation 3301634 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3301634 // <generalisation>
	  b parent class_ref 187778 // IllegalArgumentException
      end

      attribute 1812610 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 6136959093620794148L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7804034 "UnresolvedAddressException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 991106 "UnsupportedAddressTypeException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when an attempt is made to bind or connect
to a socket address of a type that is not supported.

@since 1.4
"
      classrelation 3301762 // <generalisation>
	relation 3301762 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3301762 // <generalisation>
	  b parent class_ref 187778 // IllegalArgumentException
      end

      attribute 1812738 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " -2964323842829700493L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7804162 "UnsupportedAddressTypeException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end

    class 991234 "WritePendingException"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Unchecked exception thrown when an attempt is made to write to an
asynchronous socket channel and a previous write has not completed.

@since 1.7
"
      classrelation 3301890 // <generalisation>
	relation 3301890 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3301890 // <generalisation>
	  b parent class_ref 254850 // IllegalStateException
      end

      attribute 1812866 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 7031871839266032276L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 7804290 "WritePendingException"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Constructs an instance of this class.
"
      end
    end
  end

  deploymentview 167938 "channels"
    //deployment diagram settings
    deploymentdiagramsettings
     end
    artifact 722434 "AcceptPendingException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 983938 // AcceptPendingException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 722562 "AlreadyBoundException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 984066 // AlreadyBoundException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 722690 "AlreadyConnectedException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 984194 // AlreadyConnectedException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 722818 "Channel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.io.IOException;
import java.io.Closeable;
${definition}"
      associated_elems
	class_ref 940034 // Channel
      end
      comment "Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 722946 "AsynchronousChannel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.io.IOException;
import java.util.concurrent.Future;
${definition}"
      associated_elems
	class_ref 984450 // AsynchronousChannel
      end
      comment "Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 723074 "AsynchronousByteChannel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.nio.ByteBuffer;
import java.util.concurrent.Future;
${definition}"
      associated_elems
	class_ref 984322 // AsynchronousByteChannel
      end
      comment "Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 723202 "AsynchronousChannelGroup"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.nio.channels.spi.AsynchronousChannelProvider;
import java.io.IOException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
${definition}"
      associated_elems
	class_ref 984834 // AsynchronousChannelGroup
      end
      comment "Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 723330 "ClosedChannelException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 985474 // ClosedChannelException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 723458 "AsynchronousCloseException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 985346 // AsynchronousCloseException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 723586 "AsynchronousFileChannel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.nio.file.*;
import java.nio.file.attribute.FileAttribute;
import java.nio.file.spi.*;
import java.nio.ByteBuffer;
import java.io.IOException;
import java.util.concurrent.Future;
import java.util.concurrent.ExecutorService;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
${definition}"
      associated_elems
	class_ref 985602 // AsynchronousFileChannel
      end
      comment "Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 723714 "NetworkChannel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.net.SocketOption;
import java.net.SocketAddress;
import java.util.Set;
import java.io.IOException;
${definition}"
      associated_elems
	class_ref 986114 // NetworkChannel
      end
      comment "Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 723842 "AsynchronousServerSocketChannel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.nio.channels.spi.*;
import java.net.SocketOption;
import java.net.SocketAddress;
import java.util.concurrent.Future;
import java.io.IOException;
${definition}"
      associated_elems
	class_ref 985986 // AsynchronousServerSocketChannel
      end
      comment "Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 723970 "AsynchronousSocketChannel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.nio.channels.spi.*;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.Future;
import java.io.IOException;
import java.net.SocketOption;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
${definition}"
      associated_elems
	class_ref 986242 // AsynchronousSocketChannel
      end
      comment "Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 724098 "ReadableByteChannel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.io.IOException;
import java.nio.ByteBuffer;
${definition}"
      associated_elems
	class_ref 986498 // ReadableByteChannel
      end
      comment "Copyright (c) 2000, 2001, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 724226 "WritableByteChannel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.io.IOException;
import java.nio.ByteBuffer;
${definition}"
      associated_elems
	class_ref 986626 // WritableByteChannel
      end
      comment "Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 724354 "ByteChannel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.io.IOException;
${definition}"
      associated_elems
	class_ref 986370 // ByteChannel
      end
      comment "Copyright (c) 2000, 2001, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 724482 "CancelledKeyException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 986754 // CancelledKeyException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 724610 "InterruptibleChannel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.io.IOException;
${definition}"
      associated_elems
	class_ref 987266 // InterruptibleChannel
      end
      comment "Copyright (c) 2001, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















"
    end

    artifact 724866 "Channels"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.UnsupportedCharsetException;
import java.nio.channels.spi.AbstractInterruptibleChannel;
import java.util.concurrent.ExecutionException;
import sun.nio.ch.ChannelInputStream;
import sun.nio.cs.StreamDecoder;
import sun.nio.cs.StreamEncoder;
${definition}"
      associated_elems
	class_ref 986882 // Channels
      end
      comment "Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 724994 "ClosedByInterruptException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 987522 // ClosedByInterruptException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 725122 "ClosedSelectorException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 987650 // ClosedSelectorException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 725250 "CompletionHandler"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 984578 // CompletionHandler
      end
      comment "Copyright (c) 2007, 2009, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 725378 "ConnectionPendingException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 987778 // ConnectionPendingException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 725506 "SelectableChannel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.io.IOException;
import java.nio.channels.spi.AbstractInterruptibleChannel;
import java.nio.channels.spi.SelectorProvider;
${definition}"
      associated_elems
	class_ref 210434 // SelectableChannel
      end
      comment "Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 725762 "ScatteringByteChannel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.io.IOException;
import java.nio.ByteBuffer;
${definition}"
      associated_elems
	class_ref 988162 // ScatteringByteChannel
      end
      comment "Copyright (c) 2000, 2006, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 725890 "GatheringByteChannel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.io.IOException;
import java.nio.ByteBuffer;
${definition}"
      associated_elems
	class_ref 988290 // GatheringByteChannel
      end
      comment "Copyright (c) 2000, 2001, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 726018 "MulticastChannel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.io.IOException;
import java.net.ProtocolFamily;
import java.net.StandardProtocolFamily;
import java.net.StandardSocketOptions;
${definition}"
      associated_elems
	class_ref 988418 // MulticastChannel
      end
      comment "Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 726146 "DatagramChannel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.io.IOException;
import java.net.ProtocolFamily;
import java.net.DatagramSocket;
import java.net.SocketOption;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.spi.AbstractSelectableChannel;
import java.nio.channels.spi.SelectorProvider;
${definition}"
      associated_elems
	class_ref 964994 // DatagramChannel
      end
      comment "Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 726274 "SeekableByteChannel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.nio.ByteBuffer;
import java.io.IOException;
${definition}"
      associated_elems
	class_ref 988674 // SeekableByteChannel
      end
      comment "Copyright (c) 2007, 2011, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 726402 "FileChannel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.io.*;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.spi.AbstractInterruptibleChannel;
import java.nio.file.*;
import java.nio.file.attribute.FileAttribute;
import java.nio.file.spi.*;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
${definition}"
      associated_elems
	class_ref 924034 // FileChannel
      end
      comment "Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 726530 "FileLock"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.io.IOException;
${definition}"
      associated_elems
	class_ref 985858 // FileLock
      end
      comment "Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 726658 "FileLockInterruptionException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 988930 // FileLockInterruptionException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 726786 "IllegalBlockingModeException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 989058 // IllegalBlockingModeException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 726914 "IllegalChannelGroupException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 989186 // IllegalChannelGroupException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 727042 "IllegalSelectorException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 989314 // IllegalSelectorException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 727170 "InterruptedByTimeoutException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 989442 // InterruptedByTimeoutException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 727298 "MembershipKey"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.io.IOException;
${definition}"
      associated_elems
	class_ref 988546 // MembershipKey
      end
      comment "Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 727426 "NoConnectionPendingException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 989570 // NoConnectionPendingException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 727554 "NonReadableChannelException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 989698 // NonReadableChannelException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 727682 "NonWritableChannelException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 989826 // NonWritableChannelException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 727810 "NotYetBoundException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 989954 // NotYetBoundException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 727938 "NotYetConnectedException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 990082 // NotYetConnectedException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 728066 "OverlappingFileLockException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 990210 // OverlappingFileLockException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 728194 "Pipe"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.io.IOException;
import java.nio.channels.spi.*;
${definition}"
      associated_elems
	class_ref 990338 // Pipe
      end
      comment "Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 728322 "ReadPendingException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 990722 // ReadPendingException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 728450 "SelectionKey"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import java.io.IOException;
${definition}"
      associated_elems
	class_ref 210562 // SelectionKey
      end
      comment "Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 728578 "Selector"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.io.Closeable;
import java.io.IOException;
import java.nio.channels.spi.SelectorProvider;
import java.util.Set;
${definition}"
      associated_elems
	class_ref 275586 // Selector
      end
      comment "Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 728706 "ServerSocketChannel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.io.IOException;
import java.net.ServerSocket;
import java.net.SocketOption;
import java.net.SocketAddress;
import java.nio.channels.spi.AbstractSelectableChannel;
import java.nio.channels.spi.SelectorProvider;
${definition}"
      associated_elems
	class_ref 211714 // ServerSocketChannel
      end
      comment "Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 728834 "ShutdownChannelGroupException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 990850 // ShutdownChannelGroupException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 728962 "SocketChannel"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.io.IOException;
import java.net.Socket;
import java.net.SocketOption;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.spi.AbstractSelectableChannel;
import java.nio.channels.spi.SelectorProvider;
${definition}"
      associated_elems
	class_ref 212482 // SocketChannel
      end
      comment "Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.




















"
    end

    artifact 729090 "UnresolvedAddressException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 990978 // UnresolvedAddressException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 729218 "UnsupportedAddressTypeException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 991106 // UnsupportedAddressTypeException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end

    artifact 729346 "WritePendingException"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 991234 // WritePendingException
      end
      comment "Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.

ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.






















 -- This file was mechanically generated: Do not edit! -- //"
    end
  end

  package_ref 182018 // spi
end
