class Trie
!!!5714050.java!!!	Trie()
    m_Root = new Node();
!!!5714178.java!!!	put(inout key : String, inout value : Object) : Object

    final int len = key.length();
    if (len > m_charBuffer.length)
    {
        // make the biggest buffer ever needed in get(String)
        m_charBuffer = new char[len];
    }

    Node node = m_Root;

    for (int i = 0; i < len; i++)
    {
      Node nextNode = node.m_nextChar[Character.toUpperCase(key.charAt(i))];

      if (nextNode != null)
      {
        node = nextNode;
      }
      else
      {
        for (; i < len; i++)
        {
          Node newNode = new Node();
          // put this value into the tree with a case insensitive key
          node.m_nextChar[Character.toUpperCase(key.charAt(i))] = newNode;
          node.m_nextChar[Character.toLowerCase(key.charAt(i))] = newNode;
          node = newNode;
        }
        break;
      }
    }

    Object ret = node.m_Value;

    node.m_Value = value;

    return ret;
!!!5714306.java!!!	get(in key : String) : Object

    final int len = key.length();

    /* If the name is too long, we won't find it, this also keeps us
     * from overflowing m_charBuffer
     */
    if (m_charBuffer.length < len)
        return null;

    Node node = m_Root;
    switch (len) // optimize the look up based on the number of chars
    {
        // case 0 looks silly, but the generated bytecode runs
        // faster for lookup of elements of length 2 with this in
        // and a fair bit faster.  Don't know why.
        case 0 :
            {
                return null;
            }

        case 1 :
            {
                final char ch = key.charAt(0);
                if (ch < ALPHA_SIZE)
                {
                    node = node.m_nextChar[ch];
                    if (node != null)
                        return node.m_Value;
                }
                return null;
            }
//        comment out case 2 because the default is faster
//        case 2 :
//            {
//                final char ch0 = key.charAt(0);
//                final char ch1 = key.charAt(1);
//                if (ch0 < ALPHA_SIZE && ch1 < ALPHA_SIZE)
//                {
//                    node = node.m_nextChar[ch0];
//                    if (node != null)
//                    {
//
//                        if (ch1 < ALPHA_SIZE)
//                        {
//                            node = node.m_nextChar[ch1];
//                            if (node != null)
//                                return node.m_Value;
//                        }
//                    }
//                }
//                return null;
//           }
        default :
            {
                key.getChars(0, len, m_charBuffer, 0);
                // copy string into array
                for (int i = 0; i < len; i++)
                {
                    final char ch = m_charBuffer[i];
                    if (ALPHA_SIZE <= ch)
                    {
                        // the key is not 7-bit ASCII so we won't find it here
                        return null;
                    }

                    node = node.m_nextChar[ch];
                    if (node == null)
                        return null;
                }

                return node.m_Value;
            }
    }
