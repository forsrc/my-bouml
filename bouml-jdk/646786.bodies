class NodeImpl
!!!4169602.java!!!	NodeImpl(inout ownerDocument : CoreDocumentImpl)
        // as long as we do not have any owner, ownerNode is our ownerDocument
        ownerNode = ownerDocument;
!!!4170114.java!!!	getNodeValue() : String
        return null;            // overridden in some subclasses
!!!4170242.java!!!	setNodeValue(inout x : String) : void
        // Default behavior is to do nothing, overridden in some subclasses
!!!4170370.java!!!	appendChild(inout newChild : Node) : Node
        return insertBefore(newChild, null);
!!!4170498.java!!!	cloneNode(inout deep : boolean) : Node

        if (needsSyncData()) {
            synchronizeData();
        }

        NodeImpl newnode;
        try {
            newnode = (NodeImpl)clone();
        }
        catch (CloneNotSupportedException e) {
            // if we get here we have an error in our program we may as well
            // be vocal about it, so that people can take appropriate action.
            throw new RuntimeException("**Internal Error**" + e);
        }

        // Need to break the association w/ original kids
        newnode.ownerNode      = ownerDocument();
        newnode.isOwned(false);

        // By default we make all clones readwrite,
        // this is overriden in readonly subclasses
        newnode.isReadOnly(false);

        ownerDocument().callUserDataHandlers(this, newnode,
                                             UserDataHandler.NODE_CLONED);

        return newnode;

!!!4170626.java!!!	getOwnerDocument() : Document
        // if we have an owner simply forward the request
        // otherwise ownerNode is our ownerDocument
        if (isOwned()) {
            return ownerNode.ownerDocument();
        } else {
            return (Document) ownerNode;
        }
!!!4170754.java!!!	ownerDocument() : CoreDocumentImpl
        // if we have an owner simply forward the request
        // otherwise ownerNode is our ownerDocument
        if (isOwned()) {
            return ownerNode.ownerDocument();
        } else {
            return (CoreDocumentImpl) ownerNode;
        }
!!!4170882.java!!!	setOwnerDocument(inout doc : CoreDocumentImpl) : void
        if (needsSyncData()) {
            synchronizeData();
        }
        // if we have an owner we rely on it to have it right
        // otherwise ownerNode is our ownerDocument
        if (!isOwned()) {
            ownerNode = doc;
        }
!!!4171010.java!!!	getNodeNumber() : int
        int nodeNumber;
        CoreDocumentImpl cd = (CoreDocumentImpl)(this.getOwnerDocument());
        nodeNumber = cd.getNodeNumber(this);
        return nodeNumber;
!!!4171138.java!!!	getParentNode() : Node
        return null;            // overriden by ChildNode
!!!4171266.java!!!	parentNode() : NodeImpl
        return null;
!!!4171394.java!!!	getNextSibling() : Node
        return null;            // default behavior, overriden in ChildNode
!!!4171522.java!!!	getPreviousSibling() : Node
        return null;            // default behavior, overriden in ChildNode
!!!4171650.java!!!	previousSibling() : ChildNode
        return null;            // default behavior, overriden in ChildNode
!!!4171778.java!!!	getAttributes() : NamedNodeMap
        return null; // overridden in ElementImpl
!!!4171906.java!!!	hasAttributes() : boolean
        return false;           // overridden in ElementImpl
!!!4172034.java!!!	hasChildNodes() : boolean
        return false;
!!!4172162.java!!!	getChildNodes() : NodeList
        return this;
!!!4172290.java!!!	getFirstChild() : Node
        return null;
!!!4172418.java!!!	getLastChild() : Node
        return null;
!!!4172546.java!!!	insertBefore(inout newChild : Node, inout refChild : Node) : Node
        throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR,
              DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN,
                 "HIERARCHY_REQUEST_ERR", null));
!!!4172674.java!!!	removeChild(inout oldChild : Node) : Node
        throw new DOMException(DOMException.NOT_FOUND_ERR,
              DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN,
                 "NOT_FOUND_ERR", null));
!!!4172802.java!!!	replaceChild(inout newChild : Node, inout oldChild : Node) : Node
        throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR,
              DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN,
                 "HIERARCHY_REQUEST_ERR", null));
!!!4172930.java!!!	getLength() : int
        return 0;
!!!4173058.java!!!	item(in index : int) : Node
        return null;
!!!4173186.java!!!	normalize() : void
        /* by default we do not have any children,
           ParentNode overrides this behavior */
!!!4173314.java!!!	isSupported(inout feature : String, inout version : String) : boolean
        return ownerDocument().getImplementation().hasFeature(feature,
                                                              version);
!!!4173442.java!!!	getNamespaceURI() : String
        return null;
!!!4173570.java!!!	getPrefix() : String
        return null;
!!!4173698.java!!!	setPrefix(inout prefix : String) : void
        throw new DOMException(DOMException.NAMESPACE_ERR,
              DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN,
                 "NAMESPACE_ERR", null));
!!!4173826.java!!!	getLocalName() : String
        return null;
!!!4173954.java!!!	addEventListener(inout type : String, inout listener : EventListener, inout useCapture : boolean) : void
        // simply forward to Document
        ownerDocument().addEventListener(this, type, listener, useCapture);
!!!4174082.java!!!	removeEventListener(inout type : String, inout listener : EventListener, inout useCapture : boolean) : void
        // simply forward to Document
        ownerDocument().removeEventListener(this, type, listener, useCapture);
!!!4174210.java!!!	dispatchEvent(inout event : Event) : boolean
        // simply forward to Document
        return ownerDocument().dispatchEvent(this, event);
!!!4174338.java!!!	getBaseURI() : String
        return null;
!!!4174466.java!!!	compareTreePosition(inout other : Node) : short
        // Questions of clarification for this method - to be answered by the
        // DOM WG.   Current assumptions listed - LM
        //
        // 1. How do ENTITY nodes compare?
        //    Current assumption: TREE_POSITION_DISCONNECTED, as ENTITY nodes
        //    aren't really 'in the tree'
        //
        // 2. How do NOTATION nodes compare?
        //    Current assumption: TREE_POSITION_DISCONNECTED, as NOTATION nodes
        //    aren't really 'in the tree'
        //
        // 3. Are TREE_POSITION_ANCESTOR and TREE_POSITION_DESCENDANT
        //    only relevant for nodes that are "part of the document tree"?
        //     <outer>
        //         <inner  myattr="true"/>
        //     </outer>
        //    Is the element node "outer" considered an ancestor of "myattr"?
        //    Current assumption: No.
        //
        // 4. How do children of ATTRIBUTE nodes compare (with eachother, or
        //    with children of other attribute nodes with the same element)
        //    Current assumption: Children of ATTRIBUTE nodes are treated as if
        //    they they are the attribute node itself, unless the 2 nodes
        //    are both children of the same attribute.
        //
        // 5. How does an ENTITY_REFERENCE node compare with it's children?
        //    Given the DOM, it should precede its children as an ancestor.
        //    Given "document order",  does it represent the same position?
        //    Current assumption: An ENTITY_REFERENCE node is an ancestor of its
        //    children.
        //
        // 6. How do children of a DocumentFragment compare?
        //    Current assumption: If both nodes are part of the same document
        //    fragment, there are compared as if they were part of a document.


        // If the nodes are the same...
        if (this==other)
          return (TREE_POSITION_SAME_NODE | TREE_POSITION_EQUIVALENT);

        // If either node is of type ENTITY or NOTATION, compare as disconnected
        short thisType = this.getNodeType();
        short otherType = other.getNodeType();

        // If either node is of type ENTITY or NOTATION, compare as disconnected
        if (thisType == Node.ENTITY_NODE ||
            thisType == Node.NOTATION_NODE ||
            otherType == Node.ENTITY_NODE ||
            otherType == Node.NOTATION_NODE ) {
          return TREE_POSITION_DISCONNECTED;
        }

        // Find the ancestor of each node, and the distance each node is from
        // its ancestor.
        // During this traversal, look for ancestor/descendent relationships
        // between the 2 nodes in question.
        // We do this now, so that we get this info correct for attribute nodes
        // and their children.

        Node node;
        Node thisAncestor = this;
        Node otherAncestor = other;
        int thisDepth=0;
        int otherDepth=0;
        for (node=this; node != null; node = node.getParentNode()) {
            thisDepth +=1;
            if (node == other)
              // The other node is an ancestor of this one.
              return (TREE_POSITION_ANCESTOR | TREE_POSITION_PRECEDING);
            thisAncestor = node;
        }

        for (node=other; node!=null; node=node.getParentNode()) {
            otherDepth +=1;
            if (node == this)
              // The other node is a descendent of the reference node.
              return (TREE_POSITION_DESCENDANT | TREE_POSITION_FOLLOWING);
            otherAncestor = node;
        }


        Node thisNode = this;
        Node otherNode = other;

        int thisAncestorType = thisAncestor.getNodeType();
        int otherAncestorType = otherAncestor.getNodeType();

        // if the ancestor is an attribute, get owning element.
        // we are now interested in the owner to determine position.

        if (thisAncestorType == Node.ATTRIBUTE_NODE)  {
           thisNode = ((AttrImpl)thisAncestor).getOwnerElement();
        }
        if (otherAncestorType == Node.ATTRIBUTE_NODE) {
           otherNode = ((AttrImpl)otherAncestor).getOwnerElement();
        }

        // Before proceeding, we should check if both ancestor nodes turned
        // out to be attributes for the same element
        if (thisAncestorType == Node.ATTRIBUTE_NODE &&
            otherAncestorType == Node.ATTRIBUTE_NODE &&
            thisNode==otherNode)
            return TREE_POSITION_EQUIVALENT;

        // Now, find the ancestor of the owning element, if the original
        // ancestor was an attribute

        // Note:  the following 2 loops are quite close to the ones above.
        // May want to common them up.  LM.
        if (thisAncestorType == Node.ATTRIBUTE_NODE) {
            thisDepth=0;
            for (node=thisNode; node != null; node=node.getParentNode()) {
                thisDepth +=1;
                if (node == otherNode)
                  // The other node is an ancestor of the owning element
                  {
                  return TREE_POSITION_PRECEDING;
                  }
                thisAncestor = node;
            }
        }

        // Now, find the ancestor of the owning element, if the original
        // ancestor was an attribute
        if (otherAncestorType == Node.ATTRIBUTE_NODE) {
            otherDepth=0;
            for (node=otherNode; node != null; node=node.getParentNode()) {
                otherDepth +=1;
                if (node == thisNode)
                  // The other node is a descendent of the reference
                  // node's element
                  return TREE_POSITION_FOLLOWING;
                otherAncestor = node;
            }
        }

        // thisAncestor and otherAncestor must be the same at this point,
        // otherwise, we are not in the same tree or document fragment
        if (thisAncestor != otherAncestor)
          return TREE_POSITION_DISCONNECTED;


        // Go up the parent chain of the deeper node, until we find a node
        // with the same depth as the shallower node

        if (thisDepth > otherDepth) {
          for (int i=0; i<thisDepth - otherDepth; i++)
            thisNode = thisNode.getParentNode();
          // Check if the node we have reached is in fact "otherNode". This can
          // happen in the case of attributes.  In this case, otherNode
          // "precedes" this.
          if (thisNode == otherNode)
            return TREE_POSITION_PRECEDING;
        }

        else {
          for (int i=0; i<otherDepth - thisDepth; i++)
            otherNode = otherNode.getParentNode();
          // Check if the node we have reached is in fact "thisNode".  This can
          // happen in the case of attributes.  In this case, otherNode
          // "follows" this.
          if (otherNode == thisNode)
            return TREE_POSITION_FOLLOWING;
        }

        // We now have nodes at the same depth in the tree.  Find a common
        // ancestor.
        Node thisNodeP, otherNodeP;
        for (thisNodeP=thisNode.getParentNode(),
                  otherNodeP=otherNode.getParentNode();
             thisNodeP!=otherNodeP;) {
             thisNode = thisNodeP;
             otherNode = otherNodeP;
             thisNodeP = thisNodeP.getParentNode();
             otherNodeP = otherNodeP.getParentNode();
        }

        // At this point, thisNode and otherNode are direct children of
        // the common ancestor.
        // See whether thisNode or otherNode is the leftmost

        for (Node current=thisNodeP.getFirstChild();
                  current!=null;
                  current=current.getNextSibling()) {
               if (current==otherNode) {
                 return TREE_POSITION_PRECEDING;
               }
               else if (current==thisNode) {
                 return TREE_POSITION_FOLLOWING;
               }
        }
        // REVISIT:  shouldn't get here.   Should probably throw an
        // exception
        return 0;

!!!4174594.java!!!	compareDocumentPosition(inout other : Node) : short

        // If the nodes are the same, no flags should be set
        if (this==other)
          return 0;

        // check if other is from a different implementation
        try {
            NodeImpl node = (NodeImpl) other;
        } catch (ClassCastException e) {
            // other comes from a different implementation
            String msg = DOMMessageFormatter.formatMessage(
               DOMMessageFormatter.DOM_DOMAIN, "NOT_SUPPORTED_ERR", null);
            throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);
        }

        Document thisOwnerDoc, otherOwnerDoc;
        // get the respective Document owners.
        if (this.getNodeType() == Node.DOCUMENT_NODE)
          thisOwnerDoc = (Document)this;
        else
          thisOwnerDoc = this.getOwnerDocument();
        if (other.getNodeType() == Node.DOCUMENT_NODE)
          otherOwnerDoc = (Document)other;
        else
          otherOwnerDoc = other.getOwnerDocument();

        // If from different documents, we know they are disconnected.
        // and have an implementation dependent order
        if (thisOwnerDoc != otherOwnerDoc &&
            thisOwnerDoc !=null &&
            otherOwnerDoc !=null)
 {
          int otherDocNum = ((CoreDocumentImpl)otherOwnerDoc).getNodeNumber();
          int thisDocNum = ((CoreDocumentImpl)thisOwnerDoc).getNodeNumber();
          if (otherDocNum > thisDocNum)
            return DOCUMENT_POSITION_DISCONNECTED |
                   DOCUMENT_POSITION_FOLLOWING |
                   DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
          else
            return DOCUMENT_POSITION_DISCONNECTED |
                   DOCUMENT_POSITION_PRECEDING |
                   DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;

        }

        // Find the ancestor of each node, and the distance each node is from
        // its ancestor.
        // During this traversal, look for ancestor/descendent relationships
        // between the 2 nodes in question.
        // We do this now, so that we get this info correct for attribute nodes
        // and their children.

        Node node;
        Node thisAncestor = this;
        Node otherAncestor = other;

        int thisDepth=0;
        int otherDepth=0;
        for (node=this; node != null; node = node.getParentNode()) {
            thisDepth +=1;
            if (node == other)
              // The other node is an ancestor of this one.
              return (DOCUMENT_POSITION_CONTAINS |
                      DOCUMENT_POSITION_PRECEDING);
            thisAncestor = node;
        }

        for (node=other; node!=null; node=node.getParentNode()) {
            otherDepth +=1;
            if (node == this)
              // The other node is a descendent of the reference node.
              return (DOCUMENT_POSITION_IS_CONTAINED |
                      DOCUMENT_POSITION_FOLLOWING);
            otherAncestor = node;
        }



        int thisAncestorType = thisAncestor.getNodeType();
        int otherAncestorType = otherAncestor.getNodeType();
        Node thisNode = this;
        Node otherNode = other;

        // Special casing for ENTITY, NOTATION, DOCTYPE and ATTRIBUTES
        // LM:  should rewrite this.
        switch (thisAncestorType) {
          case Node.NOTATION_NODE:
          case Node.ENTITY_NODE: {
            DocumentType container = thisOwnerDoc.getDoctype();
            if (container == otherAncestor) return
                   (DOCUMENT_POSITION_CONTAINS | DOCUMENT_POSITION_PRECEDING);
            switch (otherAncestorType) {
              case Node.NOTATION_NODE:
              case Node.ENTITY_NODE:  {
                if (thisAncestorType != otherAncestorType)
                 // the nodes are of different types
                 return ((thisAncestorType>otherAncestorType) ?
                    DOCUMENT_POSITION_PRECEDING:DOCUMENT_POSITION_FOLLOWING);
                else {
                 // the nodes are of the same type.  Find order.
                 if (thisAncestorType == Node.NOTATION_NODE)

                     if (((NamedNodeMapImpl)container.getNotations()).precedes(otherAncestor,thisAncestor))
                       return (DOCUMENT_POSITION_PRECEDING |
                               DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC);
                     else
                       return (DOCUMENT_POSITION_FOLLOWING |
                               DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC);
                 else
                     if (((NamedNodeMapImpl)container.getEntities()).precedes(otherAncestor,thisAncestor))
                       return (DOCUMENT_POSITION_PRECEDING |
                               DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC);
                     else
                       return (DOCUMENT_POSITION_FOLLOWING |
                               DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC);
                }
              }
            }
            thisNode = thisAncestor = thisOwnerDoc;
            break;
          }
          case Node.DOCUMENT_TYPE_NODE: {
            if (otherNode == thisOwnerDoc)
              return (DOCUMENT_POSITION_PRECEDING |
                      DOCUMENT_POSITION_CONTAINS);
            else if (thisOwnerDoc!=null && thisOwnerDoc==otherOwnerDoc)
              return (DOCUMENT_POSITION_FOLLOWING);
            break;
          }
          case Node.ATTRIBUTE_NODE: {
            thisNode = ((AttrImpl)thisAncestor).getOwnerElement();
            if (otherAncestorType==Node.ATTRIBUTE_NODE) {
              otherNode = ((AttrImpl)otherAncestor).getOwnerElement();
              if (otherNode == thisNode) {
                if (((NamedNodeMapImpl)thisNode.getAttributes()).precedes(other,this))
                  return (DOCUMENT_POSITION_PRECEDING |
                          DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC);
                else
                  return (DOCUMENT_POSITION_FOLLOWING |
                          DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC);
              }
            }

            // Now, find the ancestor of the element
            thisDepth=0;
            for (node=thisNode; node != null; node=node.getParentNode()) {
                thisDepth +=1;
                if (node == otherNode)
                  {
                  // The other node is an ancestor of the owning element
                  return (DOCUMENT_POSITION_CONTAINS |
                          DOCUMENT_POSITION_PRECEDING);
                  }
                thisAncestor = node;
            }
          }
        }
        switch (otherAncestorType) {
          case Node.NOTATION_NODE:
          case Node.ENTITY_NODE: {
          DocumentType container = thisOwnerDoc.getDoctype();
            if (container == this) return (DOCUMENT_POSITION_IS_CONTAINED |
                                          DOCUMENT_POSITION_FOLLOWING);
            otherNode = otherAncestor = thisOwnerDoc;
            break;
          }
          case Node.DOCUMENT_TYPE_NODE: {
            if (thisNode == otherOwnerDoc)
              return (DOCUMENT_POSITION_FOLLOWING |
                      DOCUMENT_POSITION_IS_CONTAINED);
            else if (otherOwnerDoc!=null && thisOwnerDoc==otherOwnerDoc)
              return (DOCUMENT_POSITION_PRECEDING);
            break;
          }
          case Node.ATTRIBUTE_NODE: {
            otherDepth=0;
            otherNode = ((AttrImpl)otherAncestor).getOwnerElement();
            for (node=otherNode; node != null; node=node.getParentNode()) {
                otherDepth +=1;
                if (node == thisNode)
                  // The other node is a descendent of the reference
                  // node's element
                  return DOCUMENT_POSITION_FOLLOWING |
                         DOCUMENT_POSITION_IS_CONTAINED;
                otherAncestor = node;
            }

          }
        }

        // thisAncestor and otherAncestor must be the same at this point,
        // otherwise, the original nodes are disconnected
        if (thisAncestor != otherAncestor) {
          int thisAncestorNum, otherAncestorNum;
          thisAncestorNum = ((NodeImpl)thisAncestor).getNodeNumber();
          otherAncestorNum = ((NodeImpl)otherAncestor).getNodeNumber();

          if (thisAncestorNum > otherAncestorNum)
            return DOCUMENT_POSITION_DISCONNECTED |
                   DOCUMENT_POSITION_FOLLOWING |
                   DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
          else
            return DOCUMENT_POSITION_DISCONNECTED |
                   DOCUMENT_POSITION_PRECEDING |
                   DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC;
        }


        // Go up the parent chain of the deeper node, until we find a node
        // with the same depth as the shallower node

        if (thisDepth > otherDepth) {
          for (int i=0; i<thisDepth - otherDepth; i++)
            thisNode = thisNode.getParentNode();
          // Check if the node we have reached is in fact "otherNode". This can
          // happen in the case of attributes.  In this case, otherNode
          // "precedes" this.
          if (thisNode == otherNode)
{
            return DOCUMENT_POSITION_PRECEDING;
          }
        }

        else {
          for (int i=0; i<otherDepth - thisDepth; i++)
            otherNode = otherNode.getParentNode();
          // Check if the node we have reached is in fact "thisNode".  This can
          // happen in the case of attributes.  In this case, otherNode
          // "follows" this.
          if (otherNode == thisNode)
            return DOCUMENT_POSITION_FOLLOWING;
        }

        // We now have nodes at the same depth in the tree.  Find a common
        // ancestor.
        Node thisNodeP, otherNodeP;
        for (thisNodeP=thisNode.getParentNode(),
                  otherNodeP=otherNode.getParentNode();
             thisNodeP!=otherNodeP;) {
             thisNode = thisNodeP;
             otherNode = otherNodeP;
             thisNodeP = thisNodeP.getParentNode();
             otherNodeP = otherNodeP.getParentNode();
        }

        // At this point, thisNode and otherNode are direct children of
        // the common ancestor.
        // See whether thisNode or otherNode is the leftmost

        for (Node current=thisNodeP.getFirstChild();
                  current!=null;
                  current=current.getNextSibling()) {
               if (current==otherNode) {
                 return DOCUMENT_POSITION_PRECEDING;
               }
               else if (current==thisNode) {
                 return DOCUMENT_POSITION_FOLLOWING;
               }
        }
        // REVISIT:  shouldn't get here.   Should probably throw an
        // exception
        return 0;

!!!4174722.java!!!	getTextContent() : String
        return getNodeValue();  // overriden in some subclasses
!!!4174850.java!!!	getTextContent(inout buf : StringBuffer) : void
        String content = getNodeValue();
        if (content != null) {
            buf.append(content);
        }
!!!4174978.java!!!	setTextContent(inout textContent : String) : void
        setNodeValue(textContent);
!!!4175106.java!!!	isSameNode(inout other : Node) : boolean
        // we do not use any wrapper so the answer is obvious
        return this == other;
!!!4175234.java!!!	isDefaultNamespace(inout namespaceURI : String) : boolean
        // REVISIT: remove casts when DOM L3 becomes REC.
        short type = this.getNodeType();
        switch (type) {
        case Node.ELEMENT_NODE: {
            String namespace = this.getNamespaceURI();
            String prefix = this.getPrefix();

            // REVISIT: is it possible that prefix is empty string?
            if (prefix == null || prefix.length() == 0) {
                if (namespaceURI == null) {
                    return (namespace == namespaceURI);
                }
                return namespaceURI.equals(namespace);
            }
            if (this.hasAttributes()) {
                ElementImpl elem = (ElementImpl)this;
                NodeImpl attr = (NodeImpl)elem.getAttributeNodeNS("http://www.w3.org/2000/xmlns/", "xmlns");
                if (attr != null) {
                    String value = attr.getNodeValue();
                    if (namespaceURI == null) {
                        return (namespace == value);
                    }
                    return namespaceURI.equals(value);
                }
            }

            NodeImpl ancestor = (NodeImpl)getElementAncestor(this);
            if (ancestor != null) {
                return ancestor.isDefaultNamespace(namespaceURI);
            }
            return false;
        }
        case Node.DOCUMENT_NODE:{
                return((NodeImpl)((Document)this).getDocumentElement()).isDefaultNamespace(namespaceURI);
            }

        case Node.ENTITY_NODE :
        case Node.NOTATION_NODE:
        case Node.DOCUMENT_FRAGMENT_NODE:
        case Node.DOCUMENT_TYPE_NODE:
            // type is unknown
            return false;
        case Node.ATTRIBUTE_NODE:{
                if (this.ownerNode.getNodeType() == Node.ELEMENT_NODE) {
                    return ownerNode.isDefaultNamespace(namespaceURI);

                }
                return false;
            }
        default:{
                NodeImpl ancestor = (NodeImpl)getElementAncestor(this);
                if (ancestor != null) {
                    return ancestor.isDefaultNamespace(namespaceURI);
                }
                return false;
            }

        }


!!!4175362.java!!!	lookupPrefix(inout namespaceURI : String) : String

        // REVISIT: When Namespaces 1.1 comes out this may not be true
        // Prefix can't be bound to null namespace
        if (namespaceURI == null) {
            return null;
        }

        short type = this.getNodeType();

        switch (type) {
        case Node.ELEMENT_NODE: {

                String namespace = this.getNamespaceURI(); // to flip out children
                return lookupNamespacePrefix(namespaceURI, (ElementImpl)this);
            }
        case Node.DOCUMENT_NODE:{
                return((NodeImpl)((Document)this).getDocumentElement()).lookupPrefix(namespaceURI);
            }

        case Node.ENTITY_NODE :
        case Node.NOTATION_NODE:
        case Node.DOCUMENT_FRAGMENT_NODE:
        case Node.DOCUMENT_TYPE_NODE:
            // type is unknown
            return null;
        case Node.ATTRIBUTE_NODE:{
                if (this.ownerNode.getNodeType() == Node.ELEMENT_NODE) {
                    return ownerNode.lookupPrefix(namespaceURI);

                }
                return null;
            }
        default:{
                NodeImpl ancestor = (NodeImpl)getElementAncestor(this);
                if (ancestor != null) {
                    return ancestor.lookupPrefix(namespaceURI);
                }
                return null;
            }

        }
!!!4175490.java!!!	lookupNamespaceURI(inout specifiedPrefix : String) : String
        short type = this.getNodeType();
        switch (type) {
        case Node.ELEMENT_NODE : {

                String namespace = this.getNamespaceURI();
                String prefix = this.getPrefix();
                if (namespace !=null) {
                    // REVISIT: is it possible that prefix is empty string?
                    if (specifiedPrefix== null && prefix==specifiedPrefix) {
                        // looking for default namespace
                        return namespace;
                    } else if (prefix != null && prefix.equals(specifiedPrefix)) {
                        // non default namespace
                        return namespace;
                    }
                }
                if (this.hasAttributes()) {
                    NamedNodeMap map = this.getAttributes();
                    int length = map.getLength();
                    for (int i=0;i<length;i++) {
                        Node attr = map.item(i);
                        String attrPrefix = attr.getPrefix();
                        String value = attr.getNodeValue();
                        namespace = attr.getNamespaceURI();
                        if (namespace !=null && namespace.equals("http://www.w3.org/2000/xmlns/")) {
                            // at this point we are dealing with DOM Level 2 nodes only
                            if (specifiedPrefix == null &&
                                attr.getNodeName().equals("xmlns")) {
                                // default namespace
                                return value;
                            } else if (attrPrefix !=null &&
                                       attrPrefix.equals("xmlns") &&
                                       attr.getLocalName().equals(specifiedPrefix)) {
                                // non default namespace
                                return value;
                            }
                        }
                    }
                }
                NodeImpl ancestor = (NodeImpl)getElementAncestor(this);
                if (ancestor != null) {
                    return ancestor.lookupNamespaceURI(specifiedPrefix);
                }

                return null;


            }
        case Node.DOCUMENT_NODE : {
                return((NodeImpl)((Document)this).getDocumentElement()).lookupNamespaceURI(specifiedPrefix);
            }
        case Node.ENTITY_NODE :
        case Node.NOTATION_NODE:
        case Node.DOCUMENT_FRAGMENT_NODE:
        case Node.DOCUMENT_TYPE_NODE:
            // type is unknown
            return null;
        case Node.ATTRIBUTE_NODE:{
                if (this.ownerNode.getNodeType() == Node.ELEMENT_NODE) {
                    return ownerNode.lookupNamespaceURI(specifiedPrefix);

                }
                return null;
            }
        default:{
                NodeImpl ancestor = (NodeImpl)getElementAncestor(this);
                if (ancestor != null) {
                    return ancestor.lookupNamespaceURI(specifiedPrefix);
                }
                return null;
            }

        }
!!!4175618.java!!!	getElementAncestor(inout currentNode : Node) : Node
        Node parent = currentNode.getParentNode();
        if (parent != null) {
            short type = parent.getNodeType();
            if (type == Node.ELEMENT_NODE) {
                return parent;
            }
            return getElementAncestor(parent);
        }
        return null;
!!!4175746.java!!!	lookupNamespacePrefix(inout namespaceURI : String, inout el : ElementImpl) : String
        String namespace = this.getNamespaceURI();
        // REVISIT: if no prefix is available is it null or empty string, or
        //          could be both?
        String prefix = this.getPrefix();

        if (namespace!=null && namespace.equals(namespaceURI)) {
            if (prefix != null) {
                String foundNamespace =  el.lookupNamespaceURI(prefix);
                if (foundNamespace !=null && foundNamespace.equals(namespaceURI)) {
                    return prefix;
                }

            }
        }
        if (this.hasAttributes()) {
            NamedNodeMap map = this.getAttributes();
            int length = map.getLength();
            for (int i=0;i<length;i++) {
                Node attr = map.item(i);
                String attrPrefix = attr.getPrefix();
                String value = attr.getNodeValue();
                namespace = attr.getNamespaceURI();
                if (namespace !=null && namespace.equals("http://www.w3.org/2000/xmlns/")) {
                    // DOM Level 2 nodes
                    if (((attr.getNodeName().equals("xmlns")) ||
                         (attrPrefix !=null && attrPrefix.equals("xmlns")) &&
                         value.equals(namespaceURI))) {

                        String localname= attr.getLocalName();
                        String foundNamespace = el.lookupNamespaceURI(localname);
                        if (foundNamespace !=null && foundNamespace.equals(namespaceURI)) {
                            return localname;
                        }
                    }


                }
            }
        }
        NodeImpl ancestor = (NodeImpl)getElementAncestor(this);

        if (ancestor != null) {
            return ancestor.lookupNamespacePrefix(namespaceURI, el);
        }
        return null;
!!!4175874.java!!!	isEqualNode(inout arg : Node) : boolean
        if (arg == this) {
            return true;
        }
        if (arg.getNodeType() != getNodeType()) {
            return false;
        }
        // in theory nodeName can't be null but better be careful
        // who knows what other implementations may be doing?...
        if (getNodeName() == null) {
            if (arg.getNodeName() != null) {
                return false;
            }
        }
        else if (!getNodeName().equals(arg.getNodeName())) {
            return false;
        }

        if (getLocalName() == null) {
            if (arg.getLocalName() != null) {
                return false;
            }
        }
        else if (!getLocalName().equals(arg.getLocalName())) {
            return false;
        }

        if (getNamespaceURI() == null) {
            if (arg.getNamespaceURI() != null) {
                return false;
            }
        }
        else if (!getNamespaceURI().equals(arg.getNamespaceURI())) {
            return false;
        }

        if (getPrefix() == null) {
            if (arg.getPrefix() != null) {
                return false;
            }
        }
        else if (!getPrefix().equals(arg.getPrefix())) {
            return false;
        }

        if (getNodeValue() == null) {
            if (arg.getNodeValue() != null) {
                return false;
            }
        }
        else if (!getNodeValue().equals(arg.getNodeValue())) {
            return false;
        }


        return true;
!!!4176002.java!!!	getFeature(inout feature : String, inout version : String) : Object
        // we don't have any alternate node, either this node does the job
        // or we don't have anything that does
        return isSupported(feature, version) ? this : null;
!!!4176130.java!!!	setUserData(inout key : String, inout data : Object, inout handler : UserDataHandler) : Object
        return ownerDocument().setUserData(this, key, data, handler);
!!!4176258.java!!!	getUserData(inout key : String) : Object
        return ownerDocument().getUserData(this, key);
!!!4176386.java!!!	getUserDataRecord() : Map
        return ownerDocument().getUserDataRecord(this);
!!!4176514.java!!!	setReadOnly(inout readOnly : boolean, inout deep : boolean) : void

        if (needsSyncData()) {
            synchronizeData();
        }
        isReadOnly(readOnly);

!!!4176642.java!!!	getReadOnly() : boolean

        if (needsSyncData()) {
            synchronizeData();
        }
        return isReadOnly();

!!!4176770.java!!!	setUserData(inout data : Object) : void
        ownerDocument().setUserData(this, data);
!!!4176898.java!!!	getUserData() : Object
        return ownerDocument().getUserData(this);
!!!4177026.java!!!	changed() : void
        // we do not actually store this information on every node, we only
        // have a global indicator on the Document. Doing otherwise cost us too
        // much for little gain.
        ownerDocument().changed();
!!!4177154.java!!!	changes() : int
        // we do not actually store this information on every node, we only
        // have a global indicator on the Document. Doing otherwise cost us too
        // much for little gain.
        return ownerDocument().changes();
!!!4177282.java!!!	synchronizeData() : void
        // By default just change the flag to avoid calling this method again
        needsSyncData(false);
!!!4177410.java!!!	getContainer() : Node
       return null;
!!!4177538.java!!!	isReadOnly() : boolean
        return (flags & READONLY) != 0;
!!!4177666.java!!!	isReadOnly(inout value : boolean) : void
        flags = (short) (value ? flags | READONLY : flags & ~READONLY);
!!!4177794.java!!!	needsSyncData() : boolean
        return (flags & SYNCDATA) != 0;
!!!4177922.java!!!	needsSyncData(inout value : boolean) : void
        flags = (short) (value ? flags | SYNCDATA : flags & ~SYNCDATA);
!!!4178050.java!!!	needsSyncChildren() : boolean
        return (flags & SYNCCHILDREN) != 0;
!!!4178178.java!!!	needsSyncChildren(inout value : boolean) : void
        flags = (short) (value ? flags | SYNCCHILDREN : flags & ~SYNCCHILDREN);
!!!4178306.java!!!	isOwned() : boolean
        return (flags & OWNED) != 0;
!!!4178434.java!!!	isOwned(inout value : boolean) : void
        flags = (short) (value ? flags | OWNED : flags & ~OWNED);
!!!4178562.java!!!	isFirstChild() : boolean
        return (flags & FIRSTCHILD) != 0;
!!!4178690.java!!!	isFirstChild(inout value : boolean) : void
        flags = (short) (value ? flags | FIRSTCHILD : flags & ~FIRSTCHILD);
!!!4178818.java!!!	isSpecified() : boolean
        return (flags & SPECIFIED) != 0;
!!!4178946.java!!!	isSpecified(inout value : boolean) : void
        flags = (short) (value ? flags | SPECIFIED : flags & ~SPECIFIED);
!!!4179074.java!!!	internalIsIgnorableWhitespace() : boolean
        return (flags & IGNORABLEWS) != 0;
!!!4179202.java!!!	isIgnorableWhitespace(inout value : boolean) : void
        flags = (short) (value ? flags | IGNORABLEWS : flags & ~IGNORABLEWS);
!!!4179330.java!!!	hasStringValue() : boolean
        return (flags & HASSTRING) != 0;
!!!4179458.java!!!	hasStringValue(inout value : boolean) : void
        flags = (short) (value ? flags | HASSTRING : flags & ~HASSTRING);
!!!4179586.java!!!	isNormalized() : boolean
        return (flags & NORMALIZED) != 0;
!!!4179714.java!!!	isNormalized(inout value : boolean) : void
        // See if flag should propagate to parent.
        if (!value && isNormalized() && ownerNode != null) {
            ownerNode.isNormalized(false);
        }
        flags = (short) (value ?  flags | NORMALIZED : flags & ~NORMALIZED);
!!!4179842.java!!!	isIdAttribute() : boolean
        return (flags & ID) != 0;
!!!4179970.java!!!	isIdAttribute(inout value : boolean) : void
        flags = (short) (value ? flags | ID : flags & ~ID);
!!!4180098.java!!!	toString() : String
        return "["+getNodeName()+": "+getNodeValue()+"]";
!!!4180226.java!!!	writeObject(inout out : ObjectOutputStream) : void

        // synchronize data
        if (needsSyncData()) {
            synchronizeData();
        }
        // write object
        out.defaultWriteObject();

