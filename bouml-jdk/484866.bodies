class DefaultMBeanServerInterceptor
!!!2924546.java!!!	DefaultMBeanServerInterceptor(inout outer : MBeanServer, inout delegate : MBeanServerDelegate, inout instantiator : MBeanInstantiator, inout repository : Repository)
        if (outer == null) throw new
            IllegalArgumentException("outer MBeanServer cannot be null");
        if (delegate == null) throw new
            IllegalArgumentException("MBeanServerDelegate cannot be null");
        if (instantiator == null) throw new
            IllegalArgumentException("MBeanInstantiator cannot be null");
        if (repository == null) throw new
            IllegalArgumentException("Repository cannot be null");

        this.server   = outer;
        this.delegate = delegate;
        this.instantiator = instantiator;
        this.repository   = repository;
        this.domain       = repository.getDefaultDomain();
!!!2924674.java!!!	createMBean(inout className : String, inout name : ObjectName) : ObjectInstance

        return createMBean(className, name, (Object[]) null, (String[]) null);

!!!2924802.java!!!	createMBean(inout className : String, inout name : ObjectName, inout loaderName : ObjectName) : ObjectInstance

        return createMBean(className, name, loaderName, (Object[]) null,
                           (String[]) null);
!!!2924930.java!!!	createMBean(inout className : String, inout name : ObjectName, inout params : Object [[]], inout signature : String [[]]) : ObjectInstance

        try {
            return createMBean(className, name, null, true,
                               params, signature);
        } catch (InstanceNotFoundException e) {
            /* Can only happen if loaderName doesn't exist, but we just
               passed null, so we shouldn't get this exception.  */
            throw EnvHelp.initCause(
                new IllegalArgumentException("Unexpected exception: " + e), e);
        }
!!!2925058.java!!!	createMBean(inout className : String, inout name : ObjectName, inout loaderName : ObjectName, inout params : Object [[]], inout signature : String [[]]) : ObjectInstance

        return createMBean(className, name, loaderName, false,
                           params, signature);
!!!2925186.java!!!	createMBean(inout className : String, inout name : ObjectName, inout loaderName : ObjectName, inout withDefaultLoaderRepository : boolean, inout params : Object [[]], inout signature : String [[]]) : ObjectInstance

        Class<?> theClass;

        if (className == null) {
            final RuntimeException wrapped =
                new IllegalArgumentException("The class name cannot be null");
            throw new RuntimeOperationsException(wrapped,
                      "Exception occurred during MBean creation");
        }

        if (name != null) {
            if (name.isPattern()) {
                final RuntimeException wrapped =
                    new IllegalArgumentException("Invalid name->" +
                                                 name.toString());
                final String msg = "Exception occurred during MBean creation";
                throw new RuntimeOperationsException(wrapped, msg);
            }

            name = nonDefaultDomain(name);
        }

        checkMBeanPermission(className, null, null, "instantiate");
        checkMBeanPermission(className, null, name, "registerMBean");

        /* Load the appropriate class. */
        if (withDefaultLoaderRepository) {
            if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {
                MBEANSERVER_LOGGER.logp(Level.FINER,
                        DefaultMBeanServerInterceptor.class.getName(),
                        "createMBean",
                        "ClassName = " + className + ", ObjectName = " + name);
            }
            theClass =
                instantiator.findClassWithDefaultLoaderRepository(className);
        } else if (loaderName == null) {
            if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {
                MBEANSERVER_LOGGER.logp(Level.FINER,
                        DefaultMBeanServerInterceptor.class.getName(),
                        "createMBean", "ClassName = " + className +
                        ", ObjectName = " + name + ", Loader name = null");
            }

            theClass = instantiator.findClass(className,
                                  server.getClass().getClassLoader());
        } else {
            loaderName = nonDefaultDomain(loaderName);

            if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {
                MBEANSERVER_LOGGER.logp(Level.FINER,
                        DefaultMBeanServerInterceptor.class.getName(),
                        "createMBean", "ClassName = " + className +
                        ", ObjectName = " + name +
                        ", Loader name = " + loaderName);
            }

            theClass = instantiator.findClass(className, loaderName);
        }

        checkMBeanTrustPermission(theClass);

        // Check that the MBean can be instantiated by the MBeanServer.
        Introspector.testCreation(theClass);

        // Check the JMX MBean compliance of the class
        Introspector.checkCompliance(theClass);

        Object moi= instantiator.instantiate(theClass, params,  signature,
                                             server.getClass().getClassLoader());

        final String infoClassName = getNewMBeanClassName(moi);

        return registerObject(infoClassName, moi, name);
!!!2925314.java!!!	registerMBean(inout object : Object, inout name : ObjectName) : ObjectInstance

        // ------------------------------
        // ------------------------------
        Class<?> theClass = object.getClass();

        Introspector.checkCompliance(theClass);

        final String infoClassName = getNewMBeanClassName(object);

        checkMBeanPermission(infoClassName, null, name, "registerMBean");
        checkMBeanTrustPermission(theClass);

        return registerObject(infoClassName, object, name);
!!!2925442.java!!!	getNewMBeanClassName(inout mbeanToRegister : Object) : String
        if (mbeanToRegister instanceof DynamicMBean) {
            DynamicMBean mbean = (DynamicMBean) mbeanToRegister;
            final String name;
            try {
                name = mbean.getMBeanInfo().getClassName();
            } catch (Exception e) {
                // Includes case where getMBeanInfo() returns null
                NotCompliantMBeanException ncmbe =
                    new NotCompliantMBeanException("Bad getMBeanInfo()");
                ncmbe.initCause(e);
                throw ncmbe;
            }
            if (name == null) {
                final String msg = "MBeanInfo has null class name";
                throw new NotCompliantMBeanException(msg);
            }
            return name;
        } else
            return mbeanToRegister.getClass().getName();
!!!2925570.java!!!	unregisterMBean(inout name : ObjectName) : void

        if (name == null) {
            final RuntimeException wrapped =
                new IllegalArgumentException("Object name cannot be null");
            throw new RuntimeOperationsException(wrapped,
                      "Exception occurred trying to unregister the MBean");
        }

        name = nonDefaultDomain(name);

        /* The semantics of preDeregister are tricky.  If it throws an
           exception, then the unregisterMBean fails.  This allows an
           MBean to refuse to be unregistered.  If it returns
           successfully, then the unregisterMBean can proceed.  In
           this case the preDeregister may have cleaned up some state,
           and will not expect to be called a second time.  So if two
           threads try to unregister the same MBean at the same time
           then one of them must wait for the other one to either (a)
           call preDeregister and get an exception or (b) call
           preDeregister successfully and unregister the MBean.
           Suppose thread T1 is unregistering an MBean and thread T2
           is trying to unregister the same MBean, so waiting for T1.
           Then a deadlock is possible if the preDeregister for T1
           ends up needing a lock held by T2.  Given the semantics
           just described, there does not seem to be any way to avoid
           this.  This will not happen to code where it is clear for
           any given MBean what thread may unregister that MBean.

           On the other hand we clearly do not want a thread that is
           unregistering MBean A to have to wait for another thread
           that is unregistering another MBean B (see bug 6318664).  A
           deadlock in this situation could reasonably be considered
           gratuitous.  So holding a global lock across the
           preDeregister call would be bad.

           So we have a set of ObjectNames that some thread is
           currently unregistering.  When a thread wants to unregister
           a name, it must first check if the name is in the set, and
           if so it must wait.  When a thread successfully unregisters
           a name it removes the name from the set and notifies any
           waiting threads that the set has changed.

           This implies that we must be very careful to ensure that
           the name is removed from the set and waiters notified, no
           matter what code path is taken.  */

        synchronized (beingUnregistered) {
            while (beingUnregistered.contains(name)) {
                try {
                    beingUnregistered.wait();
                } catch (InterruptedException e) {
                    throw new MBeanRegistrationException(e, e.toString());
                    // pretend the exception came from preDeregister;
                    // in another execution sequence it could have
                }
            }
            beingUnregistered.add(name);
        }

        try {
            exclusiveUnregisterMBean(name);
        } finally {
            synchronized (beingUnregistered) {
                beingUnregistered.remove(name);
                beingUnregistered.notifyAll();
            }
        }
!!!2925698.java!!!	exclusiveUnregisterMBean(inout name : ObjectName) : void

        DynamicMBean instance = getMBean(name);
        // may throw InstanceNotFoundException

        checkMBeanPermission(instance, null, name, "unregisterMBean");

        if (instance instanceof MBeanRegistration)
            preDeregisterInvoke((MBeanRegistration) instance);

        final Object resource = getResource(instance);

        // Unregisters the MBean from the repository.
        // Returns the resource context that was used.
        // The returned context does nothing for regular MBeans.
        // For ClassLoader MBeans and JMXNamespace (and JMXDomain)
        // MBeans - the context makes it possible to unregister these
        // objects from the appropriate framework artifacts, such as
        // the CLR or the dispatcher, from within the repository lock.
        // In case of success, we also need to call context.done() at the
        // end of this method.
        //
        final ResourceContext context =
                unregisterFromRepository(resource, instance, name);

        try {
            if (instance instanceof MBeanRegistration)
                postDeregisterInvoke(name,(MBeanRegistration) instance);
        } finally {
            context.done();
        }
!!!2925826.java!!!	getObjectInstance(inout name : ObjectName) : ObjectInstance

        name = nonDefaultDomain(name);
        DynamicMBean instance = getMBean(name);

        checkMBeanPermission(instance, null, name, "getObjectInstance");

        final String className = getClassName(instance);

        return new ObjectInstance(name, className);
!!!2925954.java!!!	queryMBeans(inout name : ObjectName, inout query : QueryExp) : Set
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            // Check if the caller has the right to invoke 'queryMBeans'
            //
            checkMBeanPermission((String) null, null, null, "queryMBeans");

            // Perform query without "query".
            //
            Set<ObjectInstance> list = queryMBeansImpl(name, null);

            // Check if the caller has the right to invoke 'queryMBeans'
            // on each specific classname/objectname in the list.
            //
            Set<ObjectInstance> allowedList =
                new HashSet<ObjectInstance>(list.size());
            for (ObjectInstance oi : list) {
                try {
                    checkMBeanPermission(oi.getClassName(), null,
                                         oi.getObjectName(), "queryMBeans");
                    allowedList.add(oi);
                } catch (SecurityException e) {
                    // OK: Do not add this ObjectInstance to the list
                }
            }

            // Apply query to allowed MBeans only.
            //
            return filterListOfObjectInstances(allowedList, query);
        } else {
            // Perform query.
            //
            return queryMBeansImpl(name, query);
        }
!!!2926082.java!!!	queryMBeansImpl(inout name : ObjectName, inout query : QueryExp) : Set
        // Query the MBeans on the repository
        //
        Set<NamedObject> list = repository.query(name, query);

        return (objectInstancesFromFilteredNamedObjects(list, query));
!!!2926210.java!!!	queryNames(inout name : ObjectName, inout query : QueryExp) : Set
        Set<ObjectName> queryList;
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            // Check if the caller has the right to invoke 'queryNames'
            //
            checkMBeanPermission((String) null, null, null, "queryNames");

            // Perform query without "query".
            //
            Set<ObjectInstance> list = queryMBeansImpl(name, null);

            // Check if the caller has the right to invoke 'queryNames'
            // on each specific classname/objectname in the list.
            //
            Set<ObjectInstance> allowedList =
                new HashSet<ObjectInstance>(list.size());
            for (ObjectInstance oi : list) {
                try {
                    checkMBeanPermission(oi.getClassName(), null,
                                         oi.getObjectName(), "queryNames");
                    allowedList.add(oi);
                } catch (SecurityException e) {
                    // OK: Do not add this ObjectInstance to the list
                }
            }

            // Apply query to allowed MBeans only.
            //
            Set<ObjectInstance> queryObjectInstanceList =
                filterListOfObjectInstances(allowedList, query);
            queryList = new HashSet<ObjectName>(queryObjectInstanceList.size());
            for (ObjectInstance oi : queryObjectInstanceList) {
                queryList.add(oi.getObjectName());
            }
        } else {
            // Perform query.
            //
            queryList = queryNamesImpl(name, query);
        }
        return queryList;
!!!2926338.java!!!	queryNamesImpl(inout name : ObjectName, inout query : QueryExp) : Set
        // Query the MBeans on the repository
        //
        Set<NamedObject> list = repository.query(name, query);

        return (objectNamesFromFilteredNamedObjects(list, query));
!!!2926466.java!!!	isRegistered(inout name : ObjectName) : boolean
        if (name == null) {
            throw new RuntimeOperationsException(
                     new IllegalArgumentException("Object name cannot be null"),
                     "Object name cannot be null");
        }

        name = nonDefaultDomain(name);

        /* No Permission check */
        // isRegistered is always unchecked as per JMX spec.

        return (repository.contains(name));
!!!2926594.java!!!	getDomains() : String
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            // Check if the caller has the right to invoke 'getDomains'
            //
            checkMBeanPermission((String) null, null, null, "getDomains");

            // Return domains
            //
            String[] domains = repository.getDomains();

            // Check if the caller has the right to invoke 'getDomains'
            // on each specific domain in the list.
            //
            List<String> result = new ArrayList<String>(domains.length);
            for (int i = 0; i < domains.length; i++) {
                try {
                    ObjectName dom = Util.newObjectName(domains[i] + ":x=x");
                    checkMBeanPermission((String) null, null, dom, "getDomains");
                    result.add(domains[i]);
                } catch (SecurityException e) {
                    // OK: Do not add this domain to the list
                }
            }

            // Make an array from result.
            //
            return result.toArray(new String[result.size()]);
        } else {
            return repository.getDomains();
        }
!!!2926722.java!!!	getMBeanCount() : Integer
        return (repository.getCount());
!!!2926850.java!!!	getAttribute(inout name : ObjectName, inout attribute : String) : Object

        if (name == null) {
            throw new RuntimeOperationsException(new
                IllegalArgumentException("Object name cannot be null"),
                "Exception occurred trying to invoke the getter on the MBean");
        }
        if (attribute == null) {
            throw new RuntimeOperationsException(new
                IllegalArgumentException("Attribute cannot be null"),
                "Exception occurred trying to invoke the getter on the MBean");
        }

        name = nonDefaultDomain(name);

        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {
            MBEANSERVER_LOGGER.logp(Level.FINER,
                    DefaultMBeanServerInterceptor.class.getName(),
                    "getAttribute",
                    "Attribute = " + attribute + ", ObjectName = " + name);
        }

        final DynamicMBean instance = getMBean(name);
        checkMBeanPermission(instance, attribute, name, "getAttribute");

        try {
            return instance.getAttribute(attribute);
        } catch (AttributeNotFoundException e) {
            throw e;
        } catch (Throwable t) {
            rethrowMaybeMBeanException(t);
            throw new AssertionError(); // not reached
        }
!!!2926978.java!!!	getAttributes(inout name : ObjectName, inout attributes : String [[]]) : AttributeList

        if (name == null) {
            throw new RuntimeOperationsException(new
                IllegalArgumentException("ObjectName name cannot be null"),
                "Exception occurred trying to invoke the getter on the MBean");
        }

        if (attributes == null) {
            throw new RuntimeOperationsException(new
                IllegalArgumentException("Attributes cannot be null"),
                "Exception occurred trying to invoke the getter on the MBean");
        }

        name = nonDefaultDomain(name);

        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {
            MBEANSERVER_LOGGER.logp(Level.FINER,
                    DefaultMBeanServerInterceptor.class.getName(),
                    "getAttributes", "ObjectName = " + name);
        }

        final DynamicMBean instance = getMBean(name);
        final String[] allowedAttributes;
        final SecurityManager sm = System.getSecurityManager();
        if (sm == null)
            allowedAttributes = attributes;
        else {
            final String classname = getClassName(instance);

            // Check if the caller has the right to invoke 'getAttribute'
            //
            checkMBeanPermission(classname, null, name, "getAttribute");

            // Check if the caller has the right to invoke 'getAttribute'
            // on each specific attribute
            //
            List<String> allowedList =
                new ArrayList<String>(attributes.length);
            for (String attr : attributes) {
                try {
                    checkMBeanPermission(classname, attr, name, "getAttribute");
                    allowedList.add(attr);
                } catch (SecurityException e) {
                    // OK: Do not add this attribute to the list
                }
            }
            allowedAttributes =
                    allowedList.toArray(new String[allowedList.size()]);
        }

        try {
            return instance.getAttributes(allowedAttributes);
        } catch (Throwable t) {
            rethrow(t);
            throw new AssertionError();
        }
!!!2927106.java!!!	setAttribute(inout name : ObjectName, inout attribute : Attribute) : void

        if (name == null) {
            throw new RuntimeOperationsException(new
                IllegalArgumentException("ObjectName name cannot be null"),
                "Exception occurred trying to invoke the setter on the MBean");
        }

        if (attribute == null) {
            throw new RuntimeOperationsException(new
                IllegalArgumentException("Attribute cannot be null"),
                "Exception occurred trying to invoke the setter on the MBean");
        }

        name = nonDefaultDomain(name);

        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {
            MBEANSERVER_LOGGER.logp(Level.FINER,
                    DefaultMBeanServerInterceptor.class.getName(),
                    "setAttribute", "ObjectName = " + name +
                    ", Attribute = " + attribute.getName());
        }

        DynamicMBean instance = getMBean(name);
        checkMBeanPermission(instance, attribute.getName(), name, "setAttribute");

        try {
            instance.setAttribute(attribute);
        } catch (AttributeNotFoundException e) {
            throw e;
        } catch (InvalidAttributeValueException e) {
            throw e;
        } catch (Throwable t) {
            rethrowMaybeMBeanException(t);
            throw new AssertionError();
        }
!!!2927234.java!!!	setAttributes(inout name : ObjectName, inout attributes : AttributeList) : AttributeList

        if (name == null) {
            throw new RuntimeOperationsException(new
                IllegalArgumentException("ObjectName name cannot be null"),
                "Exception occurred trying to invoke the setter on the MBean");
        }

        if (attributes == null) {
            throw new RuntimeOperationsException(new
            IllegalArgumentException("AttributeList  cannot be null"),
            "Exception occurred trying to invoke the setter on the MBean");
        }

        name = nonDefaultDomain(name);

        final DynamicMBean instance = getMBean(name);
        final AttributeList allowedAttributes;
        final SecurityManager sm = System.getSecurityManager();
        if (sm == null)
            allowedAttributes = attributes;
        else {
            String classname = getClassName(instance);

            // Check if the caller has the right to invoke 'setAttribute'
            //
            checkMBeanPermission(classname, null, name, "setAttribute");

            // Check if the caller has the right to invoke 'setAttribute'
            // on each specific attribute
            //
            allowedAttributes = new AttributeList(attributes.size());
            for (Attribute attribute : attributes.asList()) {
                try {
                    checkMBeanPermission(classname, attribute.getName(),
                                         name, "setAttribute");
                    allowedAttributes.add(attribute);
                } catch (SecurityException e) {
                    // OK: Do not add this attribute to the list
                }
            }
        }
        try {
            return instance.setAttributes(allowedAttributes);
        } catch (Throwable t) {
            rethrow(t);
            throw new AssertionError();
        }
!!!2927362.java!!!	invoke(inout name : ObjectName, inout operationName : String, inout params : Object [[]], inout signature : String [[]]) : Object

        name = nonDefaultDomain(name);

        DynamicMBean instance = getMBean(name);
        checkMBeanPermission(instance, operationName, name, "invoke");
        try {
            return instance.invoke(operationName, params, signature);
        } catch (Throwable t) {
            rethrowMaybeMBeanException(t);
            throw new AssertionError();
        }
!!!2927490.java!!!	rethrow(inout t : Throwable) : void
        try {
            throw t;
        } catch (ReflectionException e) {
            throw e;
        } catch (RuntimeOperationsException e) {
            throw e;
        } catch (RuntimeErrorException e) {
            throw e;
        } catch (RuntimeException e) {
            throw new RuntimeMBeanException(e, e.toString());
        } catch (Error e) {
            throw new RuntimeErrorException(e, e.toString());
        } catch (Throwable t2) {
            // should not happen
            throw new RuntimeException("Unexpected exception", t2);
        }
!!!2927618.java!!!	rethrowMaybeMBeanException(inout t : Throwable) : void
        if (t instanceof MBeanException)
            throw (MBeanException) t;
        rethrow(t);
!!!2927746.java!!!	registerObject(inout classname : String, inout object : Object, inout name : ObjectName) : ObjectInstance

        if (object == null) {
            final RuntimeException wrapped =
                new IllegalArgumentException("Cannot add null object");
            throw new RuntimeOperationsException(wrapped,
                        "Exception occurred trying to register the MBean");
        }

        DynamicMBean mbean = Introspector.makeDynamicMBean(object);

        return registerDynamicMBean(classname, mbean, name);
!!!2927874.java!!!	registerDynamicMBean(inout classname : String, inout mbean : DynamicMBean, inout name : ObjectName) : ObjectInstance


        name = nonDefaultDomain(name);

        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {
            MBEANSERVER_LOGGER.logp(Level.FINER,
                    DefaultMBeanServerInterceptor.class.getName(),
                    "registerMBean", "ObjectName = " + name);
        }

        ObjectName logicalName = preRegister(mbean, server, name);

        // preRegister returned successfully, so from this point on we
        // must call postRegister(false) if there is any problem.
        boolean registered = false;
        boolean registerFailed = false;
        ResourceContext context = null;

        try {
            if (mbean instanceof DynamicMBean2) {
                try {
                    ((DynamicMBean2) mbean).preRegister2(server, logicalName);
                    registerFailed = true;  // until we succeed
                } catch (Exception e) {
                    if (e instanceof RuntimeException)
                        throw (RuntimeException) e;
                    if (e instanceof InstanceAlreadyExistsException)
                        throw (InstanceAlreadyExistsException) e;
                    throw new RuntimeException(e);
                }
            }

            if (logicalName != name && logicalName != null) {
                logicalName =
                        ObjectName.getInstance(nonDefaultDomain(logicalName));
            }

            checkMBeanPermission(classname, null, logicalName, "registerMBean");

            if (logicalName == null) {
                final RuntimeException wrapped =
                    new IllegalArgumentException("No object name specified");
                throw new RuntimeOperationsException(wrapped,
                            "Exception occurred trying to register the MBean");
            }

            final Object resource = getResource(mbean);

            // Register the MBean with the repository.
            // Returns the resource context that was used.
            // The returned context does nothing for regular MBeans.
            // For ClassLoader MBeans the context makes it possible to register these
            // objects with the appropriate framework artifacts, such as
            // the CLR, from within the repository lock.
            // In case of success, we also need to call context.done() at the
            // end of this method.
            //
            context = registerWithRepository(resource, mbean, logicalName);


            registerFailed = false;
            registered = true;

        } finally {
            try {
                postRegister(logicalName, mbean, registered, registerFailed);
            } finally {
                if (registered && context!=null) context.done();
            }
        }
        return new ObjectInstance(logicalName, classname);
!!!2928002.java!!!	throwMBeanRegistrationException(inout t : Throwable, inout where : String) : void
        if (t instanceof RuntimeException) {
            throw new RuntimeMBeanException((RuntimeException)t,
                    "RuntimeException thrown " + where);
        } else if (t instanceof Error) {
            throw new RuntimeErrorException((Error)t,
                    "Error thrown " + where);
        } else if (t instanceof MBeanRegistrationException) {
            throw (MBeanRegistrationException)t;
        } else if (t instanceof Exception) {
            throw new MBeanRegistrationException((Exception)t,
                    "Exception thrown " + where);
        } else // neither Error nor Exception??
            throw new RuntimeException(t);
!!!2928130.java!!!	preRegister(inout mbean : DynamicMBean, inout mbs : MBeanServer, inout name : ObjectName) : ObjectName

        ObjectName newName = null;

        try {
            if (mbean instanceof MBeanRegistration)
                newName = ((MBeanRegistration) mbean).preRegister(mbs, name);
        } catch (Throwable t) {
            throwMBeanRegistrationException(t, "in preRegister method");
        }

        if (newName != null) return newName;
        else return name;
!!!2928258.java!!!	postRegister(inout logicalName : ObjectName, inout mbean : DynamicMBean, inout registrationDone : boolean, inout registerFailed : boolean) : void

        if (registerFailed && mbean instanceof DynamicMBean2)
            ((DynamicMBean2) mbean).registerFailed();
        try {
            if (mbean instanceof MBeanRegistration)
                ((MBeanRegistration) mbean).postRegister(registrationDone);
        } catch (RuntimeException e) {
            MBEANSERVER_LOGGER.fine("While registering MBean ["+logicalName+
                    "]: " + "Exception thrown by postRegister: " +
                    "rethrowing <"+e+">, but keeping the MBean registered");
            throw new RuntimeMBeanException(e,
                      "RuntimeException thrown in postRegister method: "+
                      "rethrowing <"+e+">, but keeping the MBean registered");
        } catch (Error er) {
            MBEANSERVER_LOGGER.fine("While registering MBean ["+logicalName+
                    "]: " + "Error thrown by postRegister: " +
                    "rethrowing <"+er+">, but keeping the MBean registered");
            throw new RuntimeErrorException(er,
                      "Error thrown in postRegister method: "+
                      "rethrowing <"+er+">, but keeping the MBean registered");
        }
!!!2928386.java!!!	preDeregisterInvoke(inout moi : MBeanRegistration) : void
        try {
            moi.preDeregister();
        } catch (Throwable t) {
            throwMBeanRegistrationException(t, "in preDeregister method");
        }
!!!2928514.java!!!	postDeregisterInvoke(inout mbean : ObjectName, inout moi : MBeanRegistration) : void
        try {
            moi.postDeregister();
        } catch (RuntimeException e) {
            MBEANSERVER_LOGGER.fine("While unregistering MBean ["+mbean+
                    "]: " + "Exception thrown by postDeregister: " +
                    "rethrowing <"+e+">, although the MBean is succesfully " +
                    "unregistered");
            throw new RuntimeMBeanException(e,
                      "RuntimeException thrown in postDeregister method: "+
                      "rethrowing <"+e+
                      ">, although the MBean is sucessfully unregistered");
        } catch (Error er) {
            MBEANSERVER_LOGGER.fine("While unregistering MBean ["+mbean+
                    "]: " + "Error thrown by postDeregister: " +
                    "rethrowing <"+er+">, although the MBean is succesfully " +
                    "unregistered");
            throw new RuntimeErrorException(er,
                      "Error thrown in postDeregister method: "+
                      "rethrowing <"+er+
                      ">, although the MBean is sucessfully unregistered");
        }
!!!2928642.java!!!	getMBean(inout name : ObjectName) : DynamicMBean

        if (name == null) {
            throw new RuntimeOperationsException(new
                IllegalArgumentException("Object name cannot be null"),
                               "Exception occurred trying to get an MBean");
        }
        DynamicMBean obj = repository.retrieve(name);
        if (obj == null) {
            if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {
                MBEANSERVER_LOGGER.logp(Level.FINER,
                        DefaultMBeanServerInterceptor.class.getName(),
                        "getMBean", name + " : Found no object");
            }
            throw new InstanceNotFoundException(name.toString());
        }
        return obj;
!!!2928770.java!!!	getResource(inout mbean : DynamicMBean) : Object
        if (mbean instanceof DynamicMBean2)
            return ((DynamicMBean2) mbean).getResource();
        else
            return mbean;
!!!2928898.java!!!	nonDefaultDomain(inout name : ObjectName) : ObjectName
        if (name == null || name.getDomain().length() > 0)
            return name;

        /* The ObjectName looks like ":a=b", and that's what its
           toString() will return in this implementation.  So
           we can just stick the default domain in front of it
           to get a non-default-domain name.  We depend on the
           fact that toString() works like that and that it
           leaves wildcards in place (so we can detect an error
           if one is supplied where it shouldn't be).  */
        final String completeName = domain + name;

        return Util.newObjectName(completeName);
!!!2929026.java!!!	getDefaultDomain() : String
        return domain;
!!!2929154.java!!!	addNotificationListener(inout name : ObjectName, inout listener : NotificationListener, inout filter : NotificationFilter, inout handback : Object) : void

        // ------------------------------
        // ------------------------------
        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {
            MBEANSERVER_LOGGER.logp(Level.FINER,
                    DefaultMBeanServerInterceptor.class.getName(),
                    "addNotificationListener", "ObjectName = " + name);
        }

        DynamicMBean instance = getMBean(name);
        checkMBeanPermission(instance, null, name, "addNotificationListener");

        NotificationBroadcaster broadcaster =
                getNotificationBroadcaster(name, instance,
                                           NotificationBroadcaster.class);

        // ------------------
        // Check listener
        // ------------------
        if (listener == null) {
            throw new RuntimeOperationsException(new
                IllegalArgumentException("Null listener"),"Null listener");
        }

        NotificationListener listenerWrapper =
            getListenerWrapper(listener, name, instance, true);
        broadcaster.addNotificationListener(listenerWrapper, filter, handback);
!!!2929282.java!!!	addNotificationListener(inout name : ObjectName, inout listener : ObjectName, inout filter : NotificationFilter, inout handback : Object) : void

        // ------------------------------
        // ------------------------------

        // ----------------
        // Get listener object
        // ----------------
        DynamicMBean instance = getMBean(listener);
        Object resource = getResource(instance);
        if (!(resource instanceof NotificationListener)) {
            throw new RuntimeOperationsException(new
                IllegalArgumentException(listener.getCanonicalName()),
                "The MBean " + listener.getCanonicalName() +
                "does not implement the NotificationListener interface") ;
        }

        // ----------------
        // Add a listener on an MBean
        // ----------------
        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {
            MBEANSERVER_LOGGER.logp(Level.FINER,
                    DefaultMBeanServerInterceptor.class.getName(),
                    "addNotificationListener",
                    "ObjectName = " + name + ", Listener = " + listener);
        }
        server.addNotificationListener(name,(NotificationListener) resource,
                                       filter, handback) ;
!!!2929410.java!!!	removeNotificationListener(inout name : ObjectName, inout listener : NotificationListener) : void
        removeNotificationListener(name, listener, null, null, true);
!!!2929538.java!!!	removeNotificationListener(inout name : ObjectName, inout listener : NotificationListener, inout filter : NotificationFilter, inout handback : Object) : void
        removeNotificationListener(name, listener, filter, handback, false);
!!!2929666.java!!!	removeNotificationListener(inout name : ObjectName, inout listener : ObjectName) : void
        NotificationListener instance = getListener(listener);

        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {
            MBEANSERVER_LOGGER.logp(Level.FINER,
                    DefaultMBeanServerInterceptor.class.getName(),
                    "removeNotificationListener",
                    "ObjectName = " + name + ", Listener = " + listener);
        }
        server.removeNotificationListener(name, instance);
!!!2929794.java!!!	removeNotificationListener(inout name : ObjectName, inout listener : ObjectName, inout filter : NotificationFilter, inout handback : Object) : void

        NotificationListener instance = getListener(listener);

        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {
            MBEANSERVER_LOGGER.logp(Level.FINER,
                    DefaultMBeanServerInterceptor.class.getName(),
                    "removeNotificationListener",
                    "ObjectName = " + name + ", Listener = " + listener);
        }
        server.removeNotificationListener(name, instance, filter, handback);
!!!2929922.java!!!	getListener(inout listener : ObjectName) : NotificationListener
        // ----------------
        // Get listener object
        // ----------------
        DynamicMBean instance;
        try {
            instance = getMBean(listener);
        } catch (InstanceNotFoundException e) {
            throw EnvHelp.initCause(
                          new ListenerNotFoundException(e.getMessage()), e);
        }

        Object resource = getResource(instance);
        if (!(resource instanceof NotificationListener)) {
            final RuntimeException exc =
                new IllegalArgumentException(listener.getCanonicalName());
            final String msg =
                "MBean " + listener.getCanonicalName() + " does not " +
                "implement " + NotificationListener.class.getName();
            throw new RuntimeOperationsException(exc, msg);
        }
        return (NotificationListener) resource;
!!!2930050.java!!!	removeNotificationListener(inout name : ObjectName, inout listener : NotificationListener, inout filter : NotificationFilter, inout handback : Object, inout removeAll : boolean) : void

        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {
            MBEANSERVER_LOGGER.logp(Level.FINER,
                    DefaultMBeanServerInterceptor.class.getName(),
                    "removeNotificationListener", "ObjectName = " + name);
        }

        DynamicMBean instance = getMBean(name);
        checkMBeanPermission(instance, null, name, "removeNotificationListener");

        /* We could simplify the code by assigning broadcaster after
           assigning listenerWrapper, but that would change the error
           behavior when both the broadcaster and the listener are
           erroneous.  */

        Class<? extends NotificationBroadcaster> reqClass =
            removeAll ? NotificationBroadcaster.class : NotificationEmitter.class;
        NotificationBroadcaster broadcaster =
            getNotificationBroadcaster(name, instance, reqClass);

        NotificationListener listenerWrapper =
            getListenerWrapper(listener, name, instance, false);

        if (listenerWrapper == null)
            throw new ListenerNotFoundException("Unknown listener");

        if (removeAll)
            broadcaster.removeNotificationListener(listenerWrapper);
        else {
            NotificationEmitter emitter = (NotificationEmitter) broadcaster;
            emitter.removeNotificationListener(listenerWrapper,
                                               filter,
                                               handback);
        }
!!!2930178.java!!!	getNotificationBroadcaster(inout name : ObjectName, inout instance : Object, inout reqClass : Class) : T
        if (reqClass.isInstance(instance))
            return reqClass.cast(instance);
        if (instance instanceof DynamicMBean2)
            instance = ((DynamicMBean2) instance).getResource();
        if (reqClass.isInstance(instance))
            return reqClass.cast(instance);
        final RuntimeException exc =
            new IllegalArgumentException(name.getCanonicalName());
        final String msg =
            "MBean " + name.getCanonicalName() + " does not " +
            "implement " + reqClass.getName();
        throw new RuntimeOperationsException(exc, msg);
!!!2930306.java!!!	getMBeanInfo(inout name : ObjectName) : MBeanInfo

        // ------------------------------
        // ------------------------------

        DynamicMBean moi = getMBean(name);
        final MBeanInfo mbi;
        try {
            mbi = moi.getMBeanInfo();
        } catch (RuntimeMBeanException e) {
            throw e;
        } catch (RuntimeErrorException e) {
            throw e;
        } catch (RuntimeException e) {
            throw new RuntimeMBeanException(e,
                    "getMBeanInfo threw RuntimeException");
        } catch (Error e) {
            throw new RuntimeErrorException(e, "getMBeanInfo threw Error");
        }
        if (mbi == null)
            throw new JMRuntimeException("MBean " + name +
                                         "has no MBeanInfo");

        checkMBeanPermission(mbi.getClassName(), null, name, "getMBeanInfo");

        return mbi;
!!!2930434.java!!!	isInstanceOf(inout name : ObjectName, inout className : String) : boolean

        final DynamicMBean instance = getMBean(name);
        checkMBeanPermission(instance, null, name, "isInstanceOf");

        try {
            Object resource = getResource(instance);

            final String resourceClassName =
                    (resource instanceof DynamicMBean) ?
                        getClassName((DynamicMBean) resource) :
                        resource.getClass().getName();

            if (resourceClassName.equals(className))
                return true;
            final ClassLoader cl = resource.getClass().getClassLoader();

            final Class<?> classNameClass = Class.forName(className, false, cl);
            if (classNameClass.isInstance(resource))
                return true;

            final Class<?> resourceClass = Class.forName(resourceClassName, false, cl);
            return classNameClass.isAssignableFrom(resourceClass);
        } catch (Exception x) {
            /* Could be SecurityException or ClassNotFoundException */
            if (MBEANSERVER_LOGGER.isLoggable(Level.FINEST)) {
                MBEANSERVER_LOGGER.logp(Level.FINEST,
                        DefaultMBeanServerInterceptor.class.getName(),
                        "isInstanceOf", "Exception calling isInstanceOf", x);
            }
            return false;
        }

!!!2930562.java!!!	getClassLoaderFor(inout mbeanName : ObjectName) : ClassLoader

        DynamicMBean instance = getMBean(mbeanName);
        checkMBeanPermission(instance, null, mbeanName, "getClassLoaderFor");
        return getResource(instance).getClass().getClassLoader();
!!!2930690.java!!!	getClassLoader(inout loaderName : ObjectName) : ClassLoader

        if (loaderName == null) {
            checkMBeanPermission((String) null, null, null, "getClassLoader");
            return server.getClass().getClassLoader();
        }

        DynamicMBean instance = getMBean(loaderName);
        checkMBeanPermission(instance, null, loaderName, "getClassLoader");

        Object resource = getResource(instance);

        /* Check if the given MBean is a ClassLoader */
        if (!(resource instanceof ClassLoader))
            throw new InstanceNotFoundException(loaderName.toString() +
                                                " is not a classloader");

        return (ClassLoader) resource;
!!!2930818.java!!!	sendNotification(inout NotifType : String, inout name : ObjectName) : void

        // ------------------------------
        // ------------------------------

        // ---------------------
        // Create notification
        // ---------------------
        MBeanServerNotification notif = new MBeanServerNotification(
            NotifType,MBeanServerDelegate.DELEGATE_NAME,0,name);

        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {
            MBEANSERVER_LOGGER.logp(Level.FINER,
                    DefaultMBeanServerInterceptor.class.getName(),
                    "sendNotification", NotifType + " " + name);
        }

        delegate.sendNotification(notif);
!!!2930946.java!!!	objectNamesFromFilteredNamedObjects(inout list : Set, inout query : QueryExp) : Set
        Set<ObjectName> result = new HashSet<ObjectName>();
        // No query ...
        if (query == null) {
            for (NamedObject no : list) {
                result.add(no.getName());
            }
        } else {
            // Access the filter
            final MBeanServer oldServer = QueryEval.getMBeanServer();
            query.setMBeanServer(server);
            try {
                for (NamedObject no : list) {
                    boolean res;
                    try {
                        res = query.apply(no.getName());
                    } catch (Exception e) {
                        res = false;
                    }
                    if (res) {
                        result.add(no.getName());
                    }
                }
            } finally {
                /*
                 * query.setMBeanServer is probably
                 * QueryEval.setMBeanServer so put back the old
                 * value.  Since that method uses a ThreadLocal
                 * variable, this code is only needed for the
                 * unusual case where the user creates a custom
                 * QueryExp that calls a nested query on another
                 * MBeanServer.
                 */
                query.setMBeanServer(oldServer);
            }
        }
        return result;
!!!2931074.java!!!	objectInstancesFromFilteredNamedObjects(inout list : Set, inout query : QueryExp) : Set
        Set<ObjectInstance> result = new HashSet<ObjectInstance>();
        // No query ...
        if (query == null) {
            for (NamedObject no : list) {
                final DynamicMBean obj = no.getObject();
                final String className = safeGetClassName(obj);
                result.add(new ObjectInstance(no.getName(), className));
            }
        } else {
            // Access the filter
            MBeanServer oldServer = QueryEval.getMBeanServer();
            query.setMBeanServer(server);
            try {
                for (NamedObject no : list) {
                    final DynamicMBean obj = no.getObject();
                    boolean res;
                    try {
                        res = query.apply(no.getName());
                    } catch (Exception e) {
                        res = false;
                    }
                    if (res) {
                        String className = safeGetClassName(obj);
                        result.add(new ObjectInstance(no.getName(), className));
                    }
                }
            } finally {
                /*
                 * query.setMBeanServer is probably
                 * QueryEval.setMBeanServer so put back the old
                 * value.  Since that method uses a ThreadLocal
                 * variable, this code is only needed for the
                 * unusual case where the user creates a custom
                 * QueryExp that calls a nested query on another
                 * MBeanServer.
                 */
                query.setMBeanServer(oldServer);
            }
        }
        return result;
!!!2931202.java!!!	safeGetClassName(inout mbean : DynamicMBean) : String
        try {
            return getClassName(mbean);
        } catch (Exception e) {
            if (MBEANSERVER_LOGGER.isLoggable(Level.FINEST)) {
                MBEANSERVER_LOGGER.logp(Level.FINEST,
                        DefaultMBeanServerInterceptor.class.getName(),
                        "safeGetClassName",
                        "Exception getting MBean class name", e);
            }
            return null;
        }
!!!2931330.java!!!	filterListOfObjectInstances(inout list : Set, inout query : QueryExp) : Set
        // Null query.
        //
        if (query == null) {
            return list;
        } else {
            Set<ObjectInstance> result = new HashSet<ObjectInstance>();
            // Access the filter.
            //
            for (ObjectInstance oi : list) {
                boolean res = false;
                MBeanServer oldServer = QueryEval.getMBeanServer();
                query.setMBeanServer(server);
                try {
                    res = query.apply(oi.getObjectName());
                } catch (Exception e) {
                    res = false;
                } finally {
                    /*
                     * query.setMBeanServer is probably
                     * QueryEval.setMBeanServer so put back the old
                     * value.  Since that method uses a ThreadLocal
                     * variable, this code is only needed for the
                     * unusual case where the user creates a custom
                     * QueryExp that calls a nested query on another
                     * MBeanServer.
                     */
                    query.setMBeanServer(oldServer);
                }
                if (res) {
                    result.add(oi);
                }
            }
            return result;
        }
!!!2931458.java!!!	getListenerWrapper(inout l : NotificationListener, inout name : ObjectName, inout mbean : DynamicMBean, inout create : boolean) : NotificationListener
        Object resource = getResource(mbean);
        ListenerWrapper wrapper = new ListenerWrapper(l, name, resource);
        synchronized (listenerWrappers) {
            WeakReference<ListenerWrapper> ref = listenerWrappers.get(wrapper);
            if (ref != null) {
                NotificationListener existing = ref.get();
                if (existing != null)
                    return existing;
            }
            if (create) {
                ref = new WeakReference<ListenerWrapper>(wrapper);
                listenerWrappers.put(wrapper, ref);
                return wrapper;
            } else
                return null;
        }
!!!2931586.java!!!	instantiate(inout className : String) : Object
        throw new UnsupportedOperationException("Not supported yet.");
!!!2931714.java!!!	instantiate(inout className : String, inout loaderName : ObjectName) : Object
        throw new UnsupportedOperationException("Not supported yet.");
!!!2931842.java!!!	instantiate(inout className : String, inout params : Object [[]], inout signature : String [[]]) : Object
        throw new UnsupportedOperationException("Not supported yet.");
!!!2931970.java!!!	instantiate(inout className : String, inout loaderName : ObjectName, inout params : Object [[]], inout signature : String [[]]) : Object
        throw new UnsupportedOperationException("Not supported yet.");
!!!2932098.java!!!	deserialize(inout name : ObjectName, inout data : byte [[]]) : ObjectInputStream
        throw new UnsupportedOperationException("Not supported yet.");
!!!2932226.java!!!	deserialize(inout className : String, inout data : byte [[]]) : ObjectInputStream
        throw new UnsupportedOperationException("Not supported yet.");
!!!2932354.java!!!	deserialize(inout className : String, inout loaderName : ObjectName, inout data : byte [[]]) : ObjectInputStream
        throw new UnsupportedOperationException("Not supported yet.");
!!!2932482.java!!!	getClassLoaderRepository() : ClassLoaderRepository
        throw new UnsupportedOperationException("Not supported yet.");
!!!2933250.java!!!	getClassName(inout mbean : DynamicMBean) : String
        if (mbean instanceof DynamicMBean2)
            return ((DynamicMBean2) mbean).getClassName();
        else
            return mbean.getMBeanInfo().getClassName();
!!!2933378.java!!!	checkMBeanPermission(inout mbean : DynamicMBean, inout member : String, inout objectName : ObjectName, inout actions : String) : void
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            checkMBeanPermission(safeGetClassName(mbean),
                                 member,
                                 objectName,
                                 actions);
        }
!!!2933506.java!!!	checkMBeanPermission(inout classname : String, inout member : String, inout objectName : ObjectName, inout actions : String) : void
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            Permission perm = new MBeanPermission(classname,
                                                  member,
                                                  objectName,
                                                  actions);
            sm.checkPermission(perm);
        }
!!!2933634.java!!!	checkMBeanTrustPermission(in theClass : Class) : void
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            Permission perm = new MBeanTrustPermission("register");
            PrivilegedAction<ProtectionDomain> act =
                new PrivilegedAction<ProtectionDomain>() {
                    public ProtectionDomain run() {
                        return theClass.getProtectionDomain();
                    }
                };
            ProtectionDomain pd = AccessController.doPrivileged(act);
            AccessControlContext acc =
                new AccessControlContext(new ProtectionDomain[] { pd });
            sm.checkPermission(perm, acc);
        }
!!!2936578.java!!!	registerWithRepository(in resource : Object, in object : DynamicMBean, in logicalName : ObjectName) : DefaultMBeanServerInterceptor::ResourceContext

        // Creates a registration context, if needed.
        //
        final ResourceContext context =
                makeResourceContextFor(resource, logicalName);


        repository.addMBean(object, logicalName, context);
        // May throw InstanceAlreadyExistsException

        // ---------------------
        // Send create event
        // ---------------------
        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {
            MBEANSERVER_LOGGER.logp(Level.FINER,
                    DefaultMBeanServerInterceptor.class.getName(),
                    "addObject", "Send create notification of object " +
                    logicalName.getCanonicalName());
        }

        sendNotification(
                MBeanServerNotification.REGISTRATION_NOTIFICATION,
                logicalName);

        return context;
!!!2936706.java!!!	unregisterFromRepository(in resource : Object, in object : DynamicMBean, in logicalName : ObjectName) : DefaultMBeanServerInterceptor::ResourceContext

        // Creates a registration context, if needed.
        //
        final ResourceContext context =
                makeResourceContextFor(resource, logicalName);


        repository.remove(logicalName, context);

        // ---------------------
        // Send deletion event
        // ---------------------
        if (MBEANSERVER_LOGGER.isLoggable(Level.FINER)) {
            MBEANSERVER_LOGGER.logp(Level.FINER,
                    DefaultMBeanServerInterceptor.class.getName(),
                    "unregisterMBean", "Send delete notification of object " +
                    logicalName.getCanonicalName());
        }

        sendNotification(MBeanServerNotification.UNREGISTRATION_NOTIFICATION,
                logicalName);
        return context;
!!!2936834.java!!!	addClassLoader(inout loader : ClassLoader, in logicalName : ObjectName) : void
        /**
         * Called when the newly registered MBean is a ClassLoader
         * If so, tell the ClassLoaderRepository (CLR) about it.  We do
         * this even if the loader is a PrivateClassLoader.  In that
         * case, the CLR remembers the loader for use when it is
         * explicitly named (e.g. as the loader in createMBean) but
         * does not add it to the list that is consulted by
         * ClassLoaderRepository.loadClass.
         */
        final ModifiableClassLoaderRepository clr = getInstantiatorCLR();
        if (clr == null) {
            final RuntimeException wrapped =
                    new IllegalArgumentException(
                    "Dynamic addition of class loaders" +
                    " is not supported");
            throw new RuntimeOperationsException(wrapped,
                    "Exception occurred trying to register" +
                    " the MBean as a class loader");
        }
        clr.addClassLoader(logicalName, loader);
!!!2936962.java!!!	removeClassLoader(inout loader : ClassLoader, in logicalName : ObjectName) : void
        /**
         * Removes the  MBean from the default loader repository.
         */
        if (loader != server.getClass().getClassLoader()) {
            final ModifiableClassLoaderRepository clr = getInstantiatorCLR();
            if (clr != null) {
                clr.removeClassLoader(logicalName);
            }
        }
!!!2937090.java!!!	createClassLoaderContext(in loader : ClassLoader, in logicalName : ObjectName) : DefaultMBeanServerInterceptor::ResourceContext
        return new ResourceContext() {

            public void registering() {
                addClassLoader(loader, logicalName);
            }

            public void unregistered() {
                removeClassLoader(loader, logicalName);
            }

            public void done() {
            }
        };
!!!2937218.java!!!	makeResourceContextFor(inout resource : Object, inout logicalName : ObjectName) : DefaultMBeanServerInterceptor::ResourceContext
        if (resource instanceof ClassLoader) {
            return createClassLoaderContext((ClassLoader) resource,
                    logicalName);
        }
        return ResourceContext.NONE;
!!!2937346.java!!!	getInstantiatorCLR() : ModifiableClassLoaderRepository
        return AccessController.doPrivileged(new PrivilegedAction<ModifiableClassLoaderRepository>() {
            @Override
            public ModifiableClassLoaderRepository run() {
                return instantiator != null ? instantiator.getClassLoaderRepository() : null;
            }
        });
