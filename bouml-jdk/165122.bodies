class CDRInputStream_1_0
!!!345730.java!!!	dup() : CDRInputStreamBase
        CDRInputStreamBase result = null ;

        try {
            result = (CDRInputStreamBase)this.getClass().newInstance();
        } catch (Exception e) {
            throw wrapper.couldNotDuplicateCdrInputStream( e ) ;
        }
        result.init(this.orb,
                    this.bbwi.byteBuffer,
                    this.bbwi.buflen,
                    this.littleEndian,
                    this.bufferManagerRead);

        ((CDRInputStream_1_0)result).bbwi.position(this.bbwi.position());
        // To ensure we keep bbwi.byteBuffer.limit in sync with bbwi.buflen.
        ((CDRInputStream_1_0)result).bbwi.byteBuffer.limit(this.bbwi.buflen);

        return result;
!!!345858.java!!!	init(inout orb : ORB, inout byteBuffer : ByteBuffer, in size : int, inout littleEndian : boolean, inout bufferManager : BufferManagerRead) : void
        this.orb = (ORB)orb;
        this.wrapper = ORBUtilSystemException.get( (ORB)orb,
            CORBALogDomains.RPC_ENCODING ) ;
        this.omgWrapper = OMGSystemException.get( (ORB)orb,
            CORBALogDomains.RPC_ENCODING ) ;
        this.littleEndian = littleEndian;
        this.bufferManagerRead = bufferManager;
        this.bbwi = new ByteBufferWithInfo(orb,byteBuffer,0);
        this.bbwi.buflen = size;
        this.bbwi.byteBuffer.limit(bbwi.buflen);
        this.markAndResetHandler = bufferManagerRead.getMarkAndResetHandler();

        debug = ((ORB)orb).transportDebugFlag;
!!!345986.java!!!	performORBVersionSpecificInit() : void
        createRepositoryIdHandlers();
!!!346114.java!!!	createRepositoryIdHandlers() : void
        repIdUtil = RepositoryIdFactory.getRepIdUtility();
        repIdStrs = RepositoryIdFactory.getRepIdStringsFactory();
!!!346242.java!!!	getGIOPVersion() : GIOPVersion
        return GIOPVersion.V1_0;
!!!346370.java!!!	setHeaderPadding(inout headerPadding : boolean) : void
        throw wrapper.giopVersionError();
!!!346498.java!!!	computeAlignment(in index : int, in align : int) : int
        if (align > 1) {
            int incr = index & (align - 1);
            if (incr != 0)
                return align - incr;
        }

        return 0;
!!!346626.java!!!	getSize() : int
        return bbwi.position();
!!!346754.java!!!	checkBlockLength(in align : int, in dataSize : int) : void
        // Since chunks can end at arbitrary points (though not within
        // primitive CDR types, arrays of primitives, strings, wstrings,
        // or indirections),
        // we must check here for termination of the current chunk.
        if (!isChunked)
            return;

        // RMI-IIOP stream format version 2 case in which we know
        // that there is no more optional data available.  If the
        // Serializable's readObject method tries to read anything,
        // we must throw a MARSHAL exception with the special minor code
        // so that the ValueHandler can give the correct exception
        // to readObject.  The state is cleared when the ValueHandler
        // calls end_value after the readObject method exits.
        if (specialNoOptionalDataState) {
            throw omgWrapper.rmiiiopOptionalDataIncompatible1() ;
        }

        boolean checkForEndTag = false;

        // Are we at the end of the current chunk?  If so,
        // try to interpret the next long as a chunk length.
        // (It has to be either a chunk length, end tag,
        // or valuetag.)
        //
        // If it isn't a chunk length, blockLength will
        // remain set to maxBlockLength.
        if (blockLength == get_offset()) {

            blockLength = maxBlockLength;
            start_block();

            // What's next is either a valuetag or
            // an end tag.  If it's a valuetag, we're
            // probably being called as part of the process
            // to read the valuetag.  If it's an end tag,
            // then there isn't enough data left in
            // this valuetype to read!
            if (blockLength == maxBlockLength)
                checkForEndTag = true;

        } else
        if (blockLength < get_offset()) {
            // Are we already past the end of the current chunk?
            // This is always an error.
            throw wrapper.chunkOverflow() ;
        }

        // If what's next on the wire isn't a chunk length or
        // what we want to read (which can't be split across chunks)
        // won't fit in the current chunk, throw this exception.
        // This probably means that we're in an RMI-IIOP
        // Serializable's readObject method or a custom marshaled
        // IDL type is reading too much/in an incorrect order
        int requiredNumBytes =
                            computeAlignment(bbwi.position(), align) + dataSize;

        if (blockLength != maxBlockLength &&
            blockLength < get_offset() + requiredNumBytes) {
            throw omgWrapper.rmiiiopOptionalDataIncompatible2() ;
        }

        // REVISIT - We should look at using the built in advancement
        //           of using ByteBuffer.get() rather than explicitly
        //           advancing the ByteBuffer's position.
        //           This is true for anywhere we are incrementing
        //           the ByteBuffer's position.
        if (checkForEndTag) {
            int nextLong = read_long();
            bbwi.position(bbwi.position() - 4);

            // It was an end tag, so there wasn't enough data
            // left in the valuetype's encoding on the wire
            // to read what we wanted
            if (nextLong < 0)
                throw omgWrapper.rmiiiopOptionalDataIncompatible3() ;
        }
!!!346882.java!!!	alignAndCheck(in align : int, in n : int) : void

        checkBlockLength(align, n);

        // WARNING: Must compute real alignment after calling
        // checkBlockLength since it may move the position
        int alignResult = computeAlignment(bbwi.position(), align);
        bbwi.position(bbwi.position() + alignResult);

        if (bbwi.position() + n > bbwi.buflen)
            grow(align, n);
!!!347010.java!!!	grow(in align : int, in n : int) : void

        bbwi.needed = n;

        bbwi = bufferManagerRead.underflow(bbwi);

!!!347138.java!!!	consumeEndian() : void
        littleEndian = read_boolean();
!!!347266.java!!!	read_longdouble() : double
        throw wrapper.longDoubleNotImplemented( CompletionStatus.COMPLETED_MAYBE);
!!!347394.java!!!	read_boolean() : boolean
        return (read_octet() != 0);
!!!347522.java!!!	read_char() : char
        alignAndCheck(1, 1);

        return getConvertedChars(1, getCharConverter())[0];
!!!347650.java!!!	read_wchar() : char

        // Don't allow transmission of wchar/wstring data with
        // foreign ORBs since it's against the spec.
        if (ORBUtility.isForeignORB((ORB)orb)) {
            throw wrapper.wcharDataInGiop10( CompletionStatus.COMPLETED_MAYBE);
        }

        // If we're talking to one of our legacy ORBs, do what
        // they did:
        int b1, b2;

        alignAndCheck(2, 2);

        if (littleEndian) {
            b2 = bbwi.byteBuffer.get(bbwi.position()) & 0x00FF;
            bbwi.position(bbwi.position() + 1);
            b1 = bbwi.byteBuffer.get(bbwi.position()) & 0x00FF;
            bbwi.position(bbwi.position() + 1);
        } else {
            b1 = bbwi.byteBuffer.get(bbwi.position()) & 0x00FF;
            bbwi.position(bbwi.position() + 1);
            b2 = bbwi.byteBuffer.get(bbwi.position()) & 0x00FF;
            bbwi.position(bbwi.position() + 1);
        }

        return (char)((b1 << 8) + (b2 << 0));
!!!347778.java!!!	read_octet() : byte

        alignAndCheck(1, 1);

        byte b = bbwi.byteBuffer.get(bbwi.position());
        bbwi.position(bbwi.position() + 1);

        return b;
!!!347906.java!!!	read_short() : short
        int b1, b2;

        alignAndCheck(2, 2);

        if (littleEndian) {
            b2 = (bbwi.byteBuffer.get(bbwi.position()) << 0) & 0x000000FF;
            bbwi.position(bbwi.position() + 1);
            b1 = (bbwi.byteBuffer.get(bbwi.position()) << 8) & 0x0000FF00;
            bbwi.position(bbwi.position() + 1);
        } else {
            b1 = (bbwi.byteBuffer.get(bbwi.position()) << 8) & 0x0000FF00;
            bbwi.position(bbwi.position() + 1);
            b2 = (bbwi.byteBuffer.get(bbwi.position()) << 0) & 0x000000FF;
            bbwi.position(bbwi.position() + 1);
        }

        return (short)(b1 | b2);
!!!348034.java!!!	read_ushort() : short
        return read_short();
!!!348162.java!!!	read_long() : int
        int b1, b2, b3, b4;

        alignAndCheck(4, 4);

        int bufPos = bbwi.position();
        if (littleEndian) {
            b4 = bbwi.byteBuffer.get(bufPos++) & 0xFF;
            b3 = bbwi.byteBuffer.get(bufPos++) & 0xFF;
            b2 = bbwi.byteBuffer.get(bufPos++) & 0xFF;
            b1 = bbwi.byteBuffer.get(bufPos++) & 0xFF;
        } else {
            b1 = bbwi.byteBuffer.get(bufPos++) & 0xFF;
            b2 = bbwi.byteBuffer.get(bufPos++) & 0xFF;
            b3 = bbwi.byteBuffer.get(bufPos++) & 0xFF;
            b4 = bbwi.byteBuffer.get(bufPos++) & 0xFF;
        }
        bbwi.position(bufPos);

        return (b1 << 24) | (b2 << 16) | (b3 << 8) | b4;
!!!348290.java!!!	read_ulong() : int
        return read_long();
!!!348418.java!!!	read_longlong() : long
        long i1, i2;

        alignAndCheck(8, 8);

        if (littleEndian) {
            i2 = read_long() & 0xFFFFFFFFL;
            i1 = (long)read_long() << 32;
        } else {
            i1 = (long)read_long() << 32;
            i2 = read_long() & 0xFFFFFFFFL;
        }

        return (i1 | i2);
!!!348546.java!!!	read_ulonglong() : long
        return read_longlong();
!!!348674.java!!!	read_float() : float
        return Float.intBitsToFloat(read_long());
!!!348802.java!!!	read_double() : double
        return Double.longBitsToDouble(read_longlong());
!!!348930.java!!!	checkForNegativeLength(in length : int) : void
        if (length < 0)
            throw wrapper.negativeStringLength( CompletionStatus.COMPLETED_MAYBE,
                new Integer(length) ) ;
!!!349058.java!!!	readStringOrIndirection(inout allowIndirection : boolean) : String

        int len = read_long();

        //
        // Check for indirection
        //
        if (allowIndirection) {
            if (len == 0xffffffff)
                return null;
            else
                stringIndirection = get_offset() - 4;
        }

        checkForNegativeLength(len);

        return internalReadString(len);
!!!349186.java!!!	internalReadString(in len : int) : String
        // Workaround for ORBs which send string lengths of
        // zero to mean empty string.
        //
        // IMPORTANT: Do not replace 'new String("")' with "", it may result
        // in a Serialization bug (See serialization.zerolengthstring) and
        // bug id: 4728756 for details
        if (len == 0)
            return new String("");

        char[] result = getConvertedChars(len - 1, getCharConverter());

        // Skip over the 1 byte null
        read_octet();

        return new String(result, 0, getCharConverter().getNumChars());
!!!349314.java!!!	read_string() : String
        return readStringOrIndirection(false);
!!!349442.java!!!	read_wstring() : String
        // Don't allow transmission of wchar/wstring data with
        // foreign ORBs since it's against the spec.
        if (ORBUtility.isForeignORB((ORB)orb)) {
            throw wrapper.wcharDataInGiop10( CompletionStatus.COMPLETED_MAYBE);
        }

        int len = read_long();

        //
        // Workaround for ORBs which send string lengths of
        // zero to mean empty string.
        //
        //
        // IMPORTANT: Do not replace 'new String("")' with "", it may result
        // in a Serialization bug (See serialization.zerolengthstring) and
        // bug id: 4728756 for details
        if (len == 0)
            return new String("");

        checkForNegativeLength(len);

        len--;
        char[] c = new char[len];

        for (int i = 0; i < len; i++)
            c[i] = read_wchar();

        // skip the two null terminator bytes
        read_wchar();
        // bbwi.position(bbwi.position() + 2);

        return new String(c);
!!!349570.java!!!	read_octet_array(inout b : byte [[]], in offset : int, in length : int) : void
        if ( b == null )
            throw wrapper.nullParam() ;

        // Must call alignAndCheck at least once to ensure
        // we aren't at the end of a chunk.  Of course, we
        // should only call it if we actually need to read
        // something, otherwise we might end up with an
        // exception at the end of the stream.
        if (length == 0)
            return;

        alignAndCheck(1, 1);

        int n = offset;
        while (n < length+offset) {
            int avail;
            int bytes;
            int wanted;

            avail = bbwi.buflen - bbwi.position();
            if (avail <= 0) {
                grow(1, 1);
                avail = bbwi.buflen - bbwi.position();
            }
            wanted = (length + offset) - n;
            bytes = (wanted < avail) ? wanted : avail;
            // Microbenchmarks are showing a loop of ByteBuffer.get(int) being
            // faster than ByteBuffer.get(byte[], int, int).
            for (int i = 0; i < bytes; i++) {
                b[n+i] = bbwi.byteBuffer.get(bbwi.position() + i);
            }

            bbwi.position(bbwi.position() + bytes);

            n += bytes;
        }
!!!349698.java!!!	read_Principal() : Principal
        int len = read_long();
        byte[] pvalue = new byte[len];
        read_octet_array(pvalue,0,len);

        Principal p = new PrincipalImpl();
        p.name(pvalue);
        return p;
!!!349826.java!!!	read_TypeCode() : TypeCode
        TypeCodeImpl tc = new TypeCodeImpl(orb);
        tc.read_value(parent);
        return tc;
!!!349954.java!!!	read_any() : Any
        Any any = orb.create_any();
        TypeCodeImpl tc = new TypeCodeImpl(orb);

        // read off the typecode

        // REVISIT We could avoid this try-catch if we could peek the typecode
        // kind off this stream and see if it is a tk_value.  Looking at the
        // code we know that for tk_value the Any.read_value() below
        // ignores the tc argument anyway (except for the kind field).
        // But still we would need to make sure that the whole typecode,
        // including encapsulations, is read off.
        try {
            tc.read_value(parent);
        } catch (MARSHAL ex) {
            if (tc.kind().value() != TCKind._tk_value)
                throw ex;
            // We can be sure that the whole typecode encapsulation has been
            // read off.
            dprintThrowable(ex);
        }
        // read off the value of the any
        any.read_value(parent, tc);

        return any;
!!!350082.java!!!	read_Object() : Object
        return read_Object(null);
!!!350210.java!!!	read_Object(inout clz : Class) : Object
        // In any case, we must first read the IOR.
        IOR ior = IORFactories.makeIOR(parent) ;
        if (ior.isNil())
            return null ;

        PresentationManager.StubFactoryFactory sff = ORB.getStubFactoryFactory() ;
        String codeBase = ior.getProfile().getCodebase() ;
        PresentationManager.StubFactory stubFactory = null ;

        if (clz == null) {
            RepositoryId rid = RepositoryId.cache.getId( ior.getTypeId() ) ;
            String className = rid.getClassName() ;
            boolean isIDLInterface = rid.isIDLType() ;

            if (className == null || className.equals( "" ))
                stubFactory = null ;
            else
                try {
                    stubFactory = sff.createStubFactory( className,
                        isIDLInterface, codeBase, (Class)null,
                        (ClassLoader)null );
                } catch (Exception exc) {
                    // Could not create stubFactory, so use null.
                    // XXX stubFactory handling is still too complex:
                    // Can we resolve the stubFactory question once in
                    // a single place?
                    stubFactory = null ;
                }
        } else if (StubAdapter.isStubClass( clz )) {
            stubFactory = PresentationDefaults.makeStaticStubFactory(
                clz ) ;
        } else {
            // clz is an interface class
            boolean isIDL = IDLEntity.class.isAssignableFrom( clz ) ;

            stubFactory = sff.createStubFactory( clz.getName(),
                isIDL, codeBase, clz, clz.getClassLoader() ) ;
        }

        return internalIORToObject( ior, stubFactory, orb ) ;
!!!350338.java!!!	internalIORToObject(inout ior : IOR, inout stubFactory : PresentationManager::StubFactory, inout orb : ORB) : Object
        ORBUtilSystemException wrapper = ORBUtilSystemException.get(
            (ORB)orb, CORBALogDomains.RPC_ENCODING ) ;

        java.lang.Object servant = ior.getProfile().getServant() ;
        if (servant != null ) {
            if (servant instanceof Tie) {
                String codebase = ior.getProfile().getCodebase();
                org.omg.CORBA.Object objref = (org.omg.CORBA.Object)
                    Utility.loadStub( (Tie)servant, stubFactory, codebase,
                        false);

                // If we managed to load a stub, return it, otherwise we
                // must fail...
                if (objref != null) {
                    return objref;
                } else {
                    throw wrapper.readObjectException() ;
                }
            } else if (servant instanceof org.omg.CORBA.Object) {
                if (!(servant instanceof
                        org.omg.CORBA.portable.InvokeHandler)) {
                    return (org.omg.CORBA.Object) servant;
                }
            } else
                throw wrapper.badServantReadObject() ;
        }

        CorbaClientDelegate del = ORBUtility.makeClientDelegate( ior ) ;
        org.omg.CORBA.Object objref = null ;
        try {
            objref = stubFactory.makeStub() ;
        } catch (Throwable e) {
            wrapper.stubCreateError( e ) ;

            if (e instanceof ThreadDeath) {
                throw (ThreadDeath) e;
            }

            // Return the "default" stub...
            objref = new CORBAObjectImpl() ;
        }

        StubAdapter.setDelegate( objref, del ) ;
        return objref;
!!!350466.java!!!	read_abstract_interface() : Object
        return read_abstract_interface(null);
!!!350594.java!!!	read_abstract_interface(inout clz : Class) : Object
        boolean object = read_boolean();

        if (object) {
            return read_Object(clz);
        } else {
            return read_value();
        }
!!!350722.java!!!	read_value() : Serializable
        return read_value((Class)null);
!!!350850.java!!!	handleIndirection() : Serializable
        int indirection = read_long() + get_offset() - 4;
        if (valueCache != null && valueCache.containsVal(indirection)) {

            java.io.Serializable cachedValue
                = (java.io.Serializable)valueCache.getKey(indirection);
            return cachedValue;
        } else {
            // In RMI-IIOP the ValueHandler will recognize this
            // exception and use the provided indirection value
            // to lookup a possible indirection to an object
            // currently on the deserialization stack.
            throw new IndirectionException(indirection);
        }
!!!350978.java!!!	readRepositoryIds(in valueTag : int, inout expectedType : Class, inout expectedTypeRepId : String) : String
        return readRepositoryIds(valueTag, expectedType,
                                 expectedTypeRepId, null);
!!!351106.java!!!	readRepositoryIds(in valueTag : int, inout expectedType : Class, inout expectedTypeRepId : String, inout factory : BoxedValueHelper) : String
        switch(repIdUtil.getTypeInfo(valueTag)) {
            case RepositoryIdUtility.NO_TYPE_INFO :
                // Throw an exception if we have no repository ID info and
                // no expectedType to work with.  Otherwise, how would we
                // know what to unmarshal?
                if (expectedType == null) {
                    if (expectedTypeRepId != null) {
                        return expectedTypeRepId;
                    } else if (factory != null) {
                        return factory.get_id();
                    } else {
                        throw wrapper.expectedTypeNullAndNoRepId(
                            CompletionStatus.COMPLETED_MAYBE);
                    }
                }
                return repIdStrs.createForAnyType(expectedType);
            case RepositoryIdUtility.SINGLE_REP_TYPE_INFO :
                return read_repositoryId();
            case RepositoryIdUtility.PARTIAL_LIST_TYPE_INFO :
                return read_repositoryIds();
            default:
                throw wrapper.badValueTag( CompletionStatus.COMPLETED_MAYBE,
                    Integer.toHexString(valueTag) ) ;
        }
!!!351234.java!!!	read_value(inout expectedType : Class) : Serializable

        // Read value tag
        int vType = readValueTag();

        // Is value null?
        if (vType == 0)
            return null;

        // Is this an indirection to a previously
        // read valuetype?
        if (vType == 0xffffffff)
            return handleIndirection();

        // Save where this valuetype started so we
        // can put it in the indirection valueCache
        // later
        int indirection = get_offset() - 4;

        // Need to save this special marker variable
        // to restore its value during recursion
        boolean saveIsChunked = isChunked;

        isChunked = repIdUtil.isChunkedEncoding(vType);

        java.lang.Object value = null;

        String codebase_URL = null;
        if (repIdUtil.isCodeBasePresent(vType)) {
            codebase_URL = read_codebase_URL();
        }

        // Read repository id(s)
        String repositoryIDString
            = readRepositoryIds(vType, expectedType, null);

        // If isChunked was determined to be true based
        // on the valuetag, this will read a chunk length
        start_block();

        // Remember that end_flag keeps track of all nested
        // valuetypes and is used for older ORBs
        end_flag--;
        if (isChunked)
            chunkedValueNestingLevel--;

        if (repositoryIDString.equals(repIdStrs.getWStringValueRepId())) {
            value = read_wstring();
        } else
        if (repositoryIDString.equals(repIdStrs.getClassDescValueRepId())) {
            // read in the class whether with the old ClassDesc or the
            // new one
            value = readClass();
        } else {

            Class valueClass = expectedType;

            // By this point, either the expectedType or repositoryIDString
            // is guaranteed to be non-null.
            if (expectedType == null ||
                !repositoryIDString.equals(repIdStrs.createForAnyType(expectedType))) {

                valueClass = getClassFromString(repositoryIDString,
                                                codebase_URL,
                                                expectedType);
            }

            if (valueClass == null) {
                // No point attempting to use value handler below, since the
                // class information is not available.
                throw wrapper.couldNotFindClass(
                    CompletionStatus.COMPLETED_MAYBE,
                    new ClassNotFoundException());
            }

            if (valueClass != null &&
                org.omg.CORBA.portable.IDLEntity.class.isAssignableFrom(valueClass)) {

                value =  readIDLValue(indirection,
                                      repositoryIDString,
                                      valueClass,
                                      codebase_URL);

            } else {

                // Must be some form of RMI-IIOP valuetype

                try {
                    if (valueHandler == null)
                        valueHandler = ORBUtility.createValueHandler();

                    value = valueHandler.readValue(parent,
                                                   indirection,
                                                   valueClass,
                                                   repositoryIDString,
                                                   getCodeBase());

                } catch(SystemException sysEx) {
                    // Just rethrow any CORBA system exceptions
                    // that come out of the ValueHandler
                    throw sysEx;
                } catch(Exception ex) {
                    throw wrapper.valuehandlerReadException(
                        CompletionStatus.COMPLETED_MAYBE, ex ) ;
                } catch(Error e) {
                    throw wrapper.valuehandlerReadError(
                        CompletionStatus.COMPLETED_MAYBE, e ) ;
                }
            }
        }

        // Skip any remaining chunks until we get to
        // an end tag or a valuetag.  If we see a valuetag,
        // that means there was another valuetype in the sender's
        // version of this class that we need to skip over.
        handleEndOfValue();

        // Read and process the end tag if we're chunking.
        // Assumes that we're at the position of the end tag
        // (handleEndOfValue should assure this)
        readEndTag();

        // Cache the valuetype that we read
        if (valueCache == null)
            valueCache = new CacheTable(orb,false);
        valueCache.put(value, indirection);

        // Allow for possible continuation chunk.
        // If we're a nested valuetype inside of a chunked
        // valuetype, and that enclosing valuetype has
        // more data to write, it will need to have this
        // new chunk begin after we wrote our end tag.
        isChunked = saveIsChunked;
        start_block();

        return (java.io.Serializable)value;
!!!351362.java!!!	read_value(inout factory : BoxedValueHelper) : Serializable

        // Read value tag
        int vType = readValueTag();

        if (vType == 0)
            return null; // value is null
        else if (vType == 0xffffffff) { // Indirection tag
            int indirection = read_long() + get_offset() - 4;
            if (valueCache != null && valueCache.containsVal(indirection))
                {
                    java.io.Serializable cachedValue =
                           (java.io.Serializable)valueCache.getKey(indirection);
                    return cachedValue;
                }
            else {
                throw new IndirectionException(indirection);
            }
        }
        else {
            int indirection = get_offset() - 4;

            // end_block();

            boolean saveIsChunked = isChunked;
            isChunked = repIdUtil.isChunkedEncoding(vType);

            java.lang.Object value = null;

            String codebase_URL = null;
            if (repIdUtil.isCodeBasePresent(vType)){
                codebase_URL = read_codebase_URL();
            }

            // Read repository id
            String repositoryIDString
                = readRepositoryIds(vType, null, null, factory);

            // Compare rep. ids to see if we should use passed helper
            if (!repositoryIDString.equals(factory.get_id()))
                factory = Utility.getHelper(null, codebase_URL, repositoryIDString);

            start_block();
            end_flag--;
            if (isChunked)
                chunkedValueNestingLevel--;

            if (factory instanceof ValueHelper) {
                value = readIDLValueWithHelper((ValueHelper)factory, indirection);
            } else {
                valueIndirection = indirection;  // for callback
                value = factory.read_value(parent);
            }

            handleEndOfValue();
            readEndTag();

            // Put into valueCache
            if (valueCache == null)
                valueCache = new CacheTable(orb,false);
            valueCache.put(value, indirection);

            // allow for possible continuation chunk
            isChunked = saveIsChunked;
            start_block();

            return (java.io.Serializable)value;
        }
!!!351490.java!!!	isCustomType(inout helper : ValueHelper) : boolean
        try{
            TypeCode tc = helper.get_type();
            int kind = tc.kind().value();
            if (kind == TCKind._tk_value) {
                return (tc.type_modifier() == org.omg.CORBA.VM_CUSTOM.value);
            }
        } catch(BadKind ex) {
            throw wrapper.badKind(ex) ;
        }

        return false;
!!!351618.java!!!	read_value(inout value : Serializable) : Serializable

        // Put into valueCache using valueIndirection
        if (valueCache == null)
            valueCache = new CacheTable(orb,false);
        valueCache.put(value, valueIndirection);

        if (value instanceof StreamableValue)
            ((StreamableValue)value)._read(parent);
        else if (value instanceof CustomValue)
            ((CustomValue)value).unmarshal(parent);

        return value;
!!!351746.java!!!	read_value(inout repositoryId : String) : Serializable

        // if (inBlock)
        //    end_block();

        // Read value tag
        int vType = readValueTag();

        if (vType == 0)
            return null; // value is null
        else if (vType == 0xffffffff) { // Indirection tag
            int indirection = read_long() + get_offset() - 4;
            if (valueCache != null && valueCache.containsVal(indirection))
                {
                    java.io.Serializable cachedValue =
                          (java.io.Serializable)valueCache.getKey(indirection);
                    return cachedValue;
                }
            else {
                throw new IndirectionException(indirection);
            }
        }
        else {
            int indirection = get_offset() - 4;

            // end_block();

            boolean saveIsChunked = isChunked;
            isChunked = repIdUtil.isChunkedEncoding(vType);

            java.lang.Object value = null;

            String codebase_URL = null;
            if (repIdUtil.isCodeBasePresent(vType)){
                codebase_URL = read_codebase_URL();
            }

            // Read repository id
            String repositoryIDString
                = readRepositoryIds(vType, null, repositoryId);

            ValueFactory factory =
               Utility.getFactory(null, codebase_URL, orb, repositoryIDString);

            start_block();
            end_flag--;
            if (isChunked)
                chunkedValueNestingLevel--;

            valueIndirection = indirection;  // for callback
            value = factory.read_value(parent);

            handleEndOfValue();
            readEndTag();

            // Put into valueCache
            if (valueCache == null)
                valueCache = new CacheTable(orb,false);
            valueCache.put(value, indirection);

            // allow for possible continuation chunk
            isChunked = saveIsChunked;
            start_block();

            return (java.io.Serializable)value;
        }
!!!351874.java!!!	readClass() : Class

        String codebases = null, classRepId = null;

        if (orb == null ||
            ORBVersionFactory.getFOREIGN().equals(orb.getORBVersion()) ||
            ORBVersionFactory.getNEWER().compareTo(orb.getORBVersion()) <= 0) {

            codebases = (String)read_value(java.lang.String.class);
            classRepId = (String)read_value(java.lang.String.class);
        } else {
            // Pre-Merlin/J2EE 1.3 ORBs wrote the repository ID
            // and codebase strings in the wrong order.
            classRepId = (String)read_value(java.lang.String.class);
            codebases = (String)read_value(java.lang.String.class);
        }

        if (debug) {
            dprint("readClass codebases: "
                   + codebases
                   + " rep Id: "
                   + classRepId);
        }

        Class cl = null;

        RepositoryIdInterface repositoryID
            = repIdStrs.getFromString(classRepId);

        try {
            cl = repositoryID.getClassFromType(codebases);
        } catch(ClassNotFoundException cnfe) {
            throw wrapper.cnfeReadClass( CompletionStatus.COMPLETED_MAYBE,
                cnfe, repositoryID.getClassName() ) ;
        } catch(MalformedURLException me) {
            throw wrapper.malformedUrl( CompletionStatus.COMPLETED_MAYBE,
                me, repositoryID.getClassName(), codebases ) ;
        }

        return cl;
!!!352002.java!!!	readIDLValueWithHelper(inout helper : ValueHelper, in indirection : int) : Object
        // look for two-argument static read method
        Method readMethod;
        try {
            Class argTypes[] = {org.omg.CORBA.portable.InputStream.class, helper.get_class()};
            readMethod = helper.getClass().getDeclaredMethod(kReadMethod, argTypes);
        }
        catch(NoSuchMethodException nsme) { // must be boxed value helper
            java.lang.Object result = helper.read_value(parent);
            return result;
        }

        // found two-argument read method, so must be non-boxed value...
        // ...create a blank instance
        java.lang.Object val = null;
        try {
            val = helper.get_class().newInstance();
        } catch(java.lang.InstantiationException ie) {
            throw wrapper.couldNotInstantiateHelper( ie,
                helper.get_class() ) ;
        } catch(IllegalAccessException iae){
            // Value's constructor is protected or private
            //
            // So, use the helper to read the value.
            //
            // NOTE : This means that in this particular case a recursive ref.
            // would fail.
            return helper.read_value(parent);
        }

        // add blank instance to cache table
        if (valueCache == null)
            valueCache = new CacheTable(orb,false);
        valueCache.put(val, indirection);

        // if custom type, call unmarshal method
        if (val instanceof CustomMarshal && isCustomType(helper)) {
            ((CustomMarshal)val).unmarshal(parent);
            return val;
        }

        // call two-argument read method using reflection
        try {
            java.lang.Object args[] = {parent, val};
            readMethod.invoke(helper, args);
            return val;
        } catch(IllegalAccessException iae2) {
            throw wrapper.couldNotInvokeHelperReadMethod( iae2, helper.get_class() ) ;
        } catch(InvocationTargetException ite){
            throw wrapper.couldNotInvokeHelperReadMethod( ite, helper.get_class() ) ;
        }
!!!352130.java!!!	readBoxedIDLEntity(inout clazz : Class, inout codebase : String) : Object
        Class cls = null ;

        try {
            ClassLoader clazzLoader = (clazz == null ? null : clazz.getClassLoader());

            cls = Utility.loadClassForClass(clazz.getName()+"Helper", codebase,
                                                   clazzLoader, clazz, clazzLoader);
            final Class helperClass = cls ;

            final Class argTypes[] = {org.omg.CORBA.portable.InputStream.class};

            // getDeclaredMethod requires RuntimePermission accessDeclaredMembers
            // if a different class loader is used (even though the javadoc says otherwise)
            Method readMethod = null;
            try {
                readMethod = (Method)AccessController.doPrivileged(
                    new PrivilegedExceptionAction() {
                        public java.lang.Object run() throws NoSuchMethodException {
                            return helperClass.getDeclaredMethod(kReadMethod, argTypes);
                        }
                    }
                );
            } catch (PrivilegedActionException pae) {
                // this gets caught below
                throw (NoSuchMethodException)pae.getException();
            }

            java.lang.Object args[] = {parent};
            return readMethod.invoke(null, args);

        } catch (ClassNotFoundException cnfe) {
            throw wrapper.couldNotInvokeHelperReadMethod( cnfe, cls ) ;
        } catch(NoSuchMethodException nsme) {
            throw wrapper.couldNotInvokeHelperReadMethod( nsme, cls ) ;
        } catch(IllegalAccessException iae) {
            throw wrapper.couldNotInvokeHelperReadMethod( iae, cls ) ;
        } catch(InvocationTargetException ite) {
            throw wrapper.couldNotInvokeHelperReadMethod( ite, cls ) ;
        }
!!!352258.java!!!	readIDLValue(in indirection : int, inout repId : String, inout clazz : Class, inout codebase : String) : Object
        ValueFactory factory ;

        // Always try to find a ValueFactory first, as required by the spec.
        // There are some complications here in the IDL 3.0 mapping (see 1.13.8),
        // but basically we must always be able to override the DefaultFactory
        // or Helper mappings that are also used.  This appears to be the case
        // even in the boxed value cases.  The original code only did the lookup
        // in the case of class implementing either StreamableValue or CustomValue,
        // but abstract valuetypes only implement ValueBase, and really require
        // the use of the repId to find a factory (including the DefaultFactory).
        try {
            // use new-style OBV support (factory object)
            factory = Utility.getFactory(clazz, codebase, orb, repId);
        } catch (MARSHAL marshal) {
            // XXX log marshal at one of the INFO levels

            // Could not get a factory, so try alternatives
            if (!StreamableValue.class.isAssignableFrom(clazz) &&
                !CustomValue.class.isAssignableFrom(clazz) &&
                ValueBase.class.isAssignableFrom(clazz)) {
                // use old-style OBV support (helper object)
                BoxedValueHelper helper = Utility.getHelper(clazz, codebase, repId);
                if (helper instanceof ValueHelper)
                    return readIDLValueWithHelper((ValueHelper)helper, indirection);
                else
                    return helper.read_value(parent);
            } else {
                // must be a boxed IDLEntity, so make a reflective call to the
                // helper's static read method...
                return readBoxedIDLEntity(clazz, codebase);
            }
        }

        // If there was no error in getting the factory, use it.
        valueIndirection = indirection;  // for callback
        return factory.read_value(parent);
!!!352386.java!!!	readEndTag() : void
        if (isChunked) {

            // Read the end tag
            int anEndTag = read_long();

            // End tags should always be negative, and the outermost
            // enclosing chunked valuetype should have a -1 end tag.
            //
            // handleEndOfValue should have assured that we were
            // at the end tag position!
            if (anEndTag >= 0) {
                throw wrapper.positiveEndTag( CompletionStatus.COMPLETED_MAYBE,
                    new Integer(anEndTag), new Integer( get_offset() - 4 ) ) ;
            }

            // If the ORB is null, or if we're sure we're talking to
            // a foreign ORB, Merlin, or something more recent, we
            // use the updated end tag computation, and are more strenuous
            // about the values.
            if (orb == null ||
                ORBVersionFactory.getFOREIGN().equals(orb.getORBVersion()) ||
                ORBVersionFactory.getNEWER().compareTo(orb.getORBVersion()) <= 0) {

                // If the end tag we read was less than what we were expecting,
                // then the sender must think it's sent more enclosing
                // chunked valuetypes than we have.  Throw an exception.
                if (anEndTag < chunkedValueNestingLevel)
                    throw wrapper.unexpectedEnclosingValuetype(
                        CompletionStatus.COMPLETED_MAYBE, new Integer( anEndTag ),
                        new Integer( chunkedValueNestingLevel ) ) ;

                // If the end tag is bigger than what we expected, but
                // still negative, then the sender has done some end tag
                // compaction.  We back up the stream 4 bytes so that the
                // next time readEndTag is called, it will get down here
                // again.  Even with fragmentation, we'll always be able
                // to do this.
                if (anEndTag != chunkedValueNestingLevel) {
                    bbwi.position(bbwi.position() - 4);
                 }

            } else {

                // When talking to Kestrel or Ladybird, we use our old
                // end tag rules and are less strict.  If the end tag
                // isn't what we expected, we back up, assuming
                // compaction.
                if (anEndTag != end_flag) {
                    bbwi.position(bbwi.position() - 4);
                }
            }

            // This only keeps track of the enclosing chunked
            // valuetypes
            chunkedValueNestingLevel++;
        }

        // This keeps track of all enclosing valuetypes
        end_flag++;
!!!352514.java!!!	get_offset() : int
        return bbwi.position();
!!!352642.java!!!	start_block() : void

        // if (outerValueDone)
        if (!isChunked)
            return;

        // if called from alignAndCheck, need to reset blockLength
        // to avoid an infinite recursion loop on read_long() call
        blockLength = maxBlockLength;

        blockLength = read_long();

        // Must remember where we began the chunk to calculate how far
        // along we are.  See notes above about chunkBeginPos.

        if (blockLength > 0 && blockLength < maxBlockLength) {
            blockLength += get_offset();  // _REVISIT_ unsafe, should use a Java long

            // inBlock = true;
        } else {

            // System.out.println("start_block snooped a " + Integer.toHexString(blockLength));

            // not a chunk length field
            blockLength = maxBlockLength;

            bbwi.position(bbwi.position() - 4);
        }
!!!352770.java!!!	handleEndOfValue() : void

        // If we're not chunking, we don't have to worry about
        // skipping remaining chunks or finding end tags
        if (!isChunked)
            return;

        // Skip any remaining chunks
        while (blockLength != maxBlockLength) {
            end_block();
            start_block();
        }

        // Now look for the end tag

        // This is a little wasteful since we're reading
        // this long up to 3 times in the worst cases (once
        // in start_block, once here, and once in readEndTag
        //
        // Peek next long
        int nextLong = read_long();
        bbwi.position(bbwi.position() - 4);

        // We did find an end tag, so we're done.  readEndTag
        // should take care of making sure it's the correct
        // end tag, etc.  Remember that since end tags,
        // chunk lengths, and valuetags have non overlapping
        // ranges, we can tell by the value what the longs are.
        if (nextLong < 0)
            return;

        if (nextLong == 0 || nextLong >= maxBlockLength) {

            // A custom marshaled valuetype left extra data
            // on the wire, and that data had another
            // nested value inside of it.  We've just
            // read the value tag or null of that nested value.
            //
            // In an attempt to get by it, we'll try to call
            // read_value() to get the nested value off of
            // the wire.  Afterwards, we must call handleEndOfValue
            // recursively to read any further chunks that the containing
            // valuetype might still have after the nested
            // value.
            read_value();
            handleEndOfValue();
        } else {
            // This probably means that the code to skip chunks has
            // an error, and ended up setting blockLength to something
            // other than maxBlockLength even though we weren't
            // starting a new chunk.
            throw wrapper.couldNotSkipBytes( CompletionStatus.COMPLETED_MAYBE,
                new Integer( nextLong ), new Integer( get_offset() ) ) ;
        }
!!!352898.java!!!	end_block() : void

        // if in a chunk, check for underflow or overflow
        if (blockLength != maxBlockLength) {
            if (blockLength == get_offset()) {
                // Chunk ended correctly
                blockLength = maxBlockLength;
            } else {
                // Skip over anything left by bad unmarshaling code (ex:
                // a buggy custom unmarshaler).  See handleEndOfValue.
                if (blockLength > get_offset()) {
                    skipToOffset(blockLength);
                } else {
                    throw wrapper.badChunkLength( new Integer( blockLength ),
                        new Integer( get_offset() ) ) ;
                }
            }
        }
!!!353026.java!!!	readValueTag() : int
        // outerValueDone = false;
        return read_long();
!!!353154.java!!!	orb() : ORB
        return orb;
!!!353282.java!!!	read_boolean_array(inout value : boolean [[]], in offset : int, in length : int) : void
        for(int i=0; i < length; i++) {
            value[i+offset] = read_boolean();
        }
!!!353410.java!!!	read_char_array(inout value : char [[]], in offset : int, in length : int) : void
        for(int i=0; i < length; i++) {
            value[i+offset] = read_char();
        }
!!!353538.java!!!	read_wchar_array(inout value : char [[]], in offset : int, in length : int) : void
        for(int i=0; i < length; i++) {
            value[i+offset] = read_wchar();
        }
!!!353666.java!!!	read_short_array(inout value : short [[]], in offset : int, in length : int) : void
        for(int i=0; i < length; i++) {
            value[i+offset] = read_short();
        }
!!!353794.java!!!	read_ushort_array(inout value : short [[]], in offset : int, in length : int) : void
        read_short_array(value, offset, length);
!!!353922.java!!!	read_long_array(inout value : int [[]], in offset : int, in length : int) : void
        for(int i=0; i < length; i++) {
            value[i+offset] = read_long();
        }
!!!354050.java!!!	read_ulong_array(inout value : int [[]], in offset : int, in length : int) : void
        read_long_array(value, offset, length);
!!!354178.java!!!	read_longlong_array(inout value : long [[]], in offset : int, in length : int) : void
        for(int i=0; i < length; i++) {
            value[i+offset] = read_longlong();
        }
!!!354306.java!!!	read_ulonglong_array(inout value : long [[]], in offset : int, in length : int) : void
        read_longlong_array(value, offset, length);
!!!354434.java!!!	read_float_array(inout value : float [[]], in offset : int, in length : int) : void
        for(int i=0; i < length; i++) {
            value[i+offset] = read_float();
        }
!!!354562.java!!!	read_double_array(inout value : double [[]], in offset : int, in length : int) : void
        for(int i=0; i < length; i++) {
            value[i+offset] = read_double();
        }
!!!354690.java!!!	read_any_array(inout value : Any [[]], in offset : int, in length : int) : void
        for(int i=0; i < length; i++) {
            value[i+offset] = read_any();
        }
!!!354818.java!!!	read_repositoryIds() : String

        // Read # of repository ids
        int numRepIds = read_long();
        if (numRepIds == 0xffffffff) {
            int indirection = read_long() + get_offset() - 4;
            if (repositoryIdCache != null && repositoryIdCache.containsOrderedVal(indirection))
                return (String)repositoryIdCache.getKey(indirection);
            else
                throw wrapper.unableToLocateRepIdArray( new Integer( indirection ) ) ;
        } else {

            // read first array element and store it as an indirection to the whole array
            int indirection = get_offset();
            String repID = read_repositoryId();
            if (repositoryIdCache == null)
                repositoryIdCache = new CacheTable(orb,false);
            repositoryIdCache.put(repID, indirection);

            // read and ignore the subsequent array elements, but put them in the
            // indirection table in case there are later indirections back to them
            for (int i = 1; i < numRepIds; i++) {
                read_repositoryId();
            }

            return repID;
        }
!!!354946.java!!!	read_repositoryId() : String
        String result = readStringOrIndirection(true);

        if (result == null) { // Indirection
            int indirection = read_long() + get_offset() - 4;

            if (repositoryIdCache != null && repositoryIdCache.containsOrderedVal(indirection))
                return (String)repositoryIdCache.getKey(indirection);
            else
                throw wrapper.badRepIdIndirection( CompletionStatus.COMPLETED_MAYBE,
                    new Integer(bbwi.position()) ) ;
        } else {
            if (repositoryIdCache == null)
                repositoryIdCache = new CacheTable(orb,false);
            repositoryIdCache.put(result, stringIndirection);
        }

        return result ;
!!!355074.java!!!	read_codebase_URL() : String
        String result = readStringOrIndirection(true);

        if (result == null) { // Indirection
            int indirection = read_long() + get_offset() - 4;

            if (codebaseCache != null && codebaseCache.containsVal(indirection))
                return (String)codebaseCache.getKey(indirection);
            else
                throw wrapper.badCodebaseIndirection(
                    CompletionStatus.COMPLETED_MAYBE,
                    new Integer(bbwi.position()) ) ;
        } else {
            if (codebaseCache == null)
                codebaseCache = new CacheTable(orb,false);
            codebaseCache.put(result, stringIndirection);
        }

        return result;
!!!355202.java!!!	read_Abstract() : Object
        return read_abstract_interface();
!!!355330.java!!!	read_Value() : Serializable
        return read_value();
!!!355458.java!!!	read_any_array(inout seq : AnySeqHolder, in offset : int, in length : int) : void
        read_any_array(seq.value, offset, length);
!!!355586.java!!!	read_boolean_array(inout seq : BooleanSeqHolder, in offset : int, in length : int) : void
        read_boolean_array(seq.value, offset, length);
!!!355714.java!!!	read_char_array(inout seq : CharSeqHolder, in offset : int, in length : int) : void
        read_char_array(seq.value, offset, length);
!!!355842.java!!!	read_wchar_array(inout seq : WCharSeqHolder, in offset : int, in length : int) : void
        read_wchar_array(seq.value, offset, length);
!!!355970.java!!!	read_octet_array(inout seq : OctetSeqHolder, in offset : int, in length : int) : void
        read_octet_array(seq.value, offset, length);
!!!356098.java!!!	read_short_array(inout seq : ShortSeqHolder, in offset : int, in length : int) : void
        read_short_array(seq.value, offset, length);
!!!356226.java!!!	read_ushort_array(inout seq : UShortSeqHolder, in offset : int, in length : int) : void
        read_ushort_array(seq.value, offset, length);
!!!356354.java!!!	read_long_array(inout seq : LongSeqHolder, in offset : int, in length : int) : void
        read_long_array(seq.value, offset, length);
!!!356482.java!!!	read_ulong_array(inout seq : ULongSeqHolder, in offset : int, in length : int) : void
        read_ulong_array(seq.value, offset, length);
!!!356610.java!!!	read_ulonglong_array(inout seq : ULongLongSeqHolder, in offset : int, in length : int) : void
        read_ulonglong_array(seq.value, offset, length);
!!!356738.java!!!	read_longlong_array(inout seq : LongLongSeqHolder, in offset : int, in length : int) : void
        read_longlong_array(seq.value, offset, length);
!!!356866.java!!!	read_float_array(inout seq : FloatSeqHolder, in offset : int, in length : int) : void
        read_float_array(seq.value, offset, length);
!!!356994.java!!!	read_double_array(inout seq : DoubleSeqHolder, in offset : int, in length : int) : void
        read_double_array(seq.value, offset, length);
!!!357122.java!!!	read_fixed(in digits : short, in scale : short) : BigDecimal
        // digits isn't really needed here
        StringBuffer buffer = read_fixed_buffer();
        if (digits != buffer.length())
            throw wrapper.badFixed( new Integer(digits),
                new Integer(buffer.length()) ) ;
        buffer.insert(digits - scale, '.');
        return new BigDecimal(buffer.toString());
!!!357250.java!!!	read_fixed() : BigDecimal
        return new BigDecimal(read_fixed_buffer().toString());
!!!357378.java!!!	read_fixed_buffer() : StringBuffer
        StringBuffer buffer = new StringBuffer(64);
        byte doubleDigit;
        int firstDigit;
        int secondDigit;
        boolean wroteFirstDigit = false;
        boolean more = true;
        while (more) {
            doubleDigit = this.read_octet();
            firstDigit = (int)((doubleDigit & 0xf0) >> 4);
            secondDigit = (int)(doubleDigit & 0x0f);
            if (wroteFirstDigit || firstDigit != 0) {
                buffer.append(Character.forDigit(firstDigit, 10));
                wroteFirstDigit = true;
            }
            if (secondDigit == 12) {
                // positive number or zero
                if ( ! wroteFirstDigit) {
                    // zero
                    return new StringBuffer("0.0");
                } else {
                    // positive number
                    // done
                }
                more = false;
            } else if (secondDigit == 13) {
                // negative number
                buffer.insert(0, '-');
                more = false;
            } else {
                buffer.append(Character.forDigit(secondDigit, 10));
                wroteFirstDigit = true;
            }
        }
        return buffer;
!!!357506.java!!!	_truncatable_ids() : String
        if (_ids == null)
            return null;

        return (String[])_ids.clone();
!!!357634.java!!!	printBuffer() : void
        CDRInputStream_1_0.printBuffer(this.bbwi);
!!!357762.java!!!	printBuffer(inout bbwi : ByteBufferWithInfo) : void

        System.out.println("----- Input Buffer -----");
        System.out.println();
        System.out.println("Current position: " + bbwi.position());
        System.out.println("Total length : " + bbwi.buflen);
        System.out.println();

        try {

            char[] charBuf = new char[16];

            for (int i = 0; i < bbwi.buflen; i += 16) {

                int j = 0;

                // For every 16 bytes, there is one line
                // of output.  First, the hex output of
                // the 16 bytes with each byte separated
                // by a space.
                while (j < 16 && j + i < bbwi.buflen) {
                    int k = bbwi.byteBuffer.get(i + j);
                    if (k < 0)
                        k = 256 + k;
                    String hex = Integer.toHexString(k);
                    if (hex.length() == 1)
                        hex = "0" + hex;
                    System.out.print(hex + " ");
                    j++;
                }

                // Add any extra spaces to align the
                // text column in case we didn't end
                // at 16
                while (j < 16) {
                    System.out.print("   ");
                    j++;
                }

                // Now output the ASCII equivalents.  Non-ASCII
                // characters are shown as periods.
                int x = 0;
                while (x < 16 && x + i < bbwi.buflen) {
                    if (ORBUtility.isPrintable((char)bbwi.byteBuffer.get(i + x)))
                        charBuf[x] = (char)bbwi.byteBuffer.get(i + x);
                    else
                        charBuf[x] = '.';
                    x++;
                }
                System.out.println(new String(charBuf, 0, x));
            }

        } catch (Throwable t) {
            t.printStackTrace();
        }

        System.out.println("------------------------");
!!!357890.java!!!	getByteBuffer() : ByteBuffer
        ByteBuffer result = null;
        if (bbwi != null) {
            result = bbwi.byteBuffer;
        }
        return result;
!!!358018.java!!!	getBufferLength() : int
        return bbwi.buflen;
!!!358146.java!!!	setBufferLength(in value : int) : void
        bbwi.buflen = value;
        bbwi.byteBuffer.limit(bbwi.buflen);
!!!358274.java!!!	setByteBufferWithInfo(inout bbwi : ByteBufferWithInfo) : void
        this.bbwi = bbwi;
!!!358402.java!!!	setByteBuffer(inout byteBuffer : ByteBuffer) : void
        bbwi.byteBuffer = byteBuffer;
!!!358530.java!!!	getIndex() : int
        return bbwi.position();
!!!358658.java!!!	setIndex(in value : int) : void
        bbwi.position(value);
!!!358786.java!!!	isLittleEndian() : boolean
        return littleEndian;
!!!358914.java!!!	orb(inout orb : ORB) : void
        this.orb = (ORB)orb;
!!!359042.java!!!	getBufferManager() : BufferManagerRead
        return bufferManagerRead;
!!!359170.java!!!	skipToOffset(in offset : int) : void

        // Number of bytes to skip
        int len = offset - get_offset();

        int n = 0;

        while (n < len) {
            int avail;
            int bytes;
            int wanted;

            avail = bbwi.buflen - bbwi.position();
            if (avail <= 0) {
                grow(1, 1);
                avail = bbwi.buflen - bbwi.position();
            }

            wanted = len - n;
            bytes = (wanted < avail) ? wanted : avail;
            bbwi.position(bbwi.position() + bytes);
            n += bytes;
        }
!!!359426.java!!!	createStreamMemento() : Object
        return new StreamMemento();
!!!359554.java!!!	restoreInternalState(inout streamMemento : Object) : void

        StreamMemento mem = (StreamMemento)streamMemento;

        blockLength = mem.blockLength_;
        end_flag = mem.end_flag_;
        chunkedValueNestingLevel = mem.chunkedValueNestingLevel_;
        valueIndirection = mem.valueIndirection_;
        stringIndirection = mem.stringIndirection_;
        isChunked = mem.isChunked_;
        valueHandler = mem.valueHandler_;
        specialNoOptionalDataState = mem.specialNoOptionalDataState_;
        bbwi = mem.bbwi_;
!!!359682.java!!!	getPosition() : int
        return get_offset();
!!!359810.java!!!	mark(in readlimit : int) : void
        markAndResetHandler.mark(this);
!!!359938.java!!!	reset() : void
        markAndResetHandler.reset();
!!!360066.java!!!	getCodeBase() : CodeBase
        return parent.getCodeBase();
!!!360194.java!!!	getClassFromString(inout repositoryIDString : String, inout codebaseURL : String, inout expectedType : Class) : Class
        RepositoryIdInterface repositoryID
            = repIdStrs.getFromString(repositoryIDString);

        try {
            try {
                // First try to load the class locally, then use
                // the provided URL (if it isn't null)
                return repositoryID.getClassFromType(expectedType,
                                                     codebaseURL);
            } catch (ClassNotFoundException cnfeOuter) {

                try {

                    if (getCodeBase() == null) {
                        return null; // class cannot be loaded remotely.
                    }

                    // Get a URL from the remote CodeBase and retry
                    codebaseURL = getCodeBase().implementation(repositoryIDString);

                    // Don't bother trying to find it locally again if
                    // we got a null URL
                    if (codebaseURL == null)
                        return null;

                    return repositoryID.getClassFromType(expectedType,
                                                         codebaseURL);
                } catch (ClassNotFoundException cnfeInner) {
                    dprintThrowable(cnfeInner);
                    // Failed to load the class
                    return null;
                }
            }
        } catch (MalformedURLException mue) {
            // Always report a bad URL
            throw wrapper.malformedUrl( CompletionStatus.COMPLETED_MAYBE,
                mue, repositoryIDString, codebaseURL ) ;
        }
!!!360322.java!!!	getClassFromString(inout repositoryIDString : String, inout codebaseURL : String) : Class
        RepositoryIdInterface repositoryID
            = repIdStrs.getFromString(repositoryIDString);

        for (int i = 0; i < 3; i++) {

            try {

                switch (i)
                {
                    case 0:
                        // First try to load the class locally
                        return repositoryID.getClassFromType();
                    case 1:
                        // Try to load the class using the provided
                        // codebase URL (falls out below)
                        break;
                    case 2:
                        // Try to load the class using a URL from the
                        // remote CodeBase
                        codebaseURL = getCodeBase().implementation(repositoryIDString);
                        break;
                }

                // Don't bother if the codebaseURL is null
                if (codebaseURL == null)
                    continue;

                return repositoryID.getClassFromType(codebaseURL);

            } catch(ClassNotFoundException cnfe) {
                // Will ultimately return null if all three
                // attempts fail, but don't do anything here.
            } catch (MalformedURLException mue) {
                throw wrapper.malformedUrl( CompletionStatus.COMPLETED_MAYBE,
                    mue, repositoryIDString, codebaseURL ) ;
            }
        }

        // If we get here, we have failed to load the class
        dprint("getClassFromString failed with rep id "
               + repositoryIDString
               + " and codebase "
               + codebaseURL);

        return null;
!!!360450.java!!!	getConvertedChars(in numBytes : int, inout converter : CodeSetConversion::BTCConverter) : char

        // REVISIT - Look at CodeSetConversion.BTCConverter to see
        //           if it can work with an NIO ByteBuffer. We should
        //           avoid getting the bytes into an array if possible.

        // To be honest, I doubt this saves much real time
        if (bbwi.buflen - bbwi.position() >= numBytes) {
            // If the entire string is in this buffer,
            // just convert directly from the bbwi rather than
            // allocating and copying.
            byte[] tmpBuf;
            if (bbwi.byteBuffer.hasArray())
            {
                tmpBuf = bbwi.byteBuffer.array();
            }
            else
            {
                 tmpBuf = new byte[bbwi.buflen];
                 // Microbenchmarks are showing a loop of ByteBuffer.get(int)
                 // being faster than ByteBuffer.get(byte[], int, int).
                 for (int i = 0; i < bbwi.buflen; i++)
                     tmpBuf[i] = bbwi.byteBuffer.get(i);
            }
            char[] result = converter.getChars(tmpBuf,bbwi.position(),numBytes);

            bbwi.position(bbwi.position() + numBytes);
            return result;
        } else {
            // Stretches across buffers.  Unless we provide an
            // incremental conversion interface, allocate and
            // copy the bytes.
            byte[] bytes = new byte[numBytes];
            read_octet_array(bytes, 0, bytes.length);

            return converter.getChars(bytes, 0, numBytes);
        }
!!!360578.java!!!	getCharConverter() : CodeSetConversion::BTCConverter
        if (charConverter == null)
            charConverter = parent.createCharBTCConverter();

        return charConverter;
!!!360706.java!!!	getWCharConverter() : CodeSetConversion::BTCConverter
        if (wcharConverter == null)
            wcharConverter = parent.createWCharBTCConverter();

        return wcharConverter;
!!!360834.java!!!	dprintThrowable(inout t : Throwable) : void
        if (debug && t != null)
            t.printStackTrace();
!!!360962.java!!!	dprint(inout msg : String) : void
        if (debug) {
            ORBUtility.dprint(this, msg);
        }
!!!361090.java!!!	alignOnBoundary(in octetBoundary : int) : void
        int needed = computeAlignment(bbwi.position(), octetBoundary);

        if (bbwi.position() + needed <= bbwi.buflen)
        {
            bbwi.position(bbwi.position() + needed);
        }
!!!361218.java!!!	resetCodeSetConverters() : void
        charConverter = null;
        wcharConverter = null;
!!!361346.java!!!	start_value() : void
        // Read value tag
        int vType = readValueTag();

        if (vType == 0) {
            // Stream needs to go into a state where it
            // throws standard exception until end_value
            // is called.  This means the sender didn't
            // send any custom data.  If the reader here
            // tries to read more, we need to throw an
            // exception before reading beyond where
            // we're supposed to
            specialNoOptionalDataState = true;

            return;
        }

        if (vType == 0xffffffff) {
            // One should never indirect to a custom wrapper
            throw wrapper.customWrapperIndirection(
                CompletionStatus.COMPLETED_MAYBE);
        }

        if (repIdUtil.isCodeBasePresent(vType)) {
            throw wrapper.customWrapperWithCodebase(
                CompletionStatus.COMPLETED_MAYBE);
        }

        if (repIdUtil.getTypeInfo(vType)
            != RepositoryIdUtility.SINGLE_REP_TYPE_INFO) {
            throw wrapper.customWrapperNotSingleRepid(
                CompletionStatus.COMPLETED_MAYBE);
        }


        // REVISIT - Could verify repository ID even though
        // it isn't used elsewhere
        read_repositoryId();

        // Note: isChunked should be true here.  Should have
        // been set to true in the containing value's read_value
        // method.

        start_block();
        end_flag--;
        chunkedValueNestingLevel--;
!!!361474.java!!!	end_value() : void

        if (specialNoOptionalDataState) {
            specialNoOptionalDataState = false;
            return;
        }

        handleEndOfValue();
        readEndTag();

        // Note that isChunked should still be true here.
        // If the containing valuetype is the highest
        // chunked value, it will get set to false
        // at the end of read_value.

        // allow for possible continuation chunk
        start_block();
!!!361602.java!!!	close() : void

        // tell BufferManagerRead to release any ByteBuffers
        getBufferManager().close(bbwi);

        // It's possible bbwi.byteBuffer is shared between
        // this InputStream and an OutputStream. Thus, we check
        // if the Input/Output streams are using the same ByteBuffer.
        // If they sharing the same ByteBuffer we need to ensure only
        // one of those ByteBuffers are released to the ByteBufferPool.

        if (bbwi != null && getByteBuffer() != null)
        {
            MessageMediator messageMediator = parent.getMessageMediator();
            if (messageMediator != null)
            {
                CDROutputObject outputObj =
                             (CDROutputObject)messageMediator.getOutputObject();
                if (outputObj != null)
                {
                    if (outputObj.isSharing(getByteBuffer()))
                    {
                        // Set OutputStream's ByteBuffer and bbwi to null
                        // so its ByteBuffer cannot be released to the pool
                        outputObj.setByteBuffer(null);
                        outputObj.setByteBufferWithInfo(null);
                    }
                }
            }

            // release this stream's ByteBuffer to the pool
            ByteBufferPool byteBufferPool = orb.getByteBufferPool();
            if (debug)
            {
                // print address of ByteBuffer being released
                int bbAddress = System.identityHashCode(bbwi.byteBuffer);
                StringBuffer sb = new StringBuffer(80);
                sb.append(".close - releasing ByteBuffer id (");
                sb.append(bbAddress).append(") to ByteBufferPool.");
                String msg = sb.toString();
                dprint(msg);
            }
            byteBufferPool.releaseByteBuffer(bbwi.byteBuffer);
            bbwi.byteBuffer = null;
            bbwi = null;
        }
