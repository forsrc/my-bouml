class ToTextStream
!!!5614082.java!!!	ToTextStream()
    super();
!!!5614210.java!!!	startDocumentInternal() : void
    super.startDocumentInternal();

    m_needToCallStartDocument = false;

    // No action for the moment.
!!!5614338.java!!!	endDocument() : void
    flushPending();
    flushWriter();
    if (m_tracer != null)
        super.fireEndDoc();
!!!5614466.java!!!	startElement(inout namespaceURI : String, inout localName : String, inout name : String, inout atts : Attributes) : void
    // time to fire off startElement event
    if (m_tracer != null) {
        super.fireStartElem(name);
        this.firePseudoAttributes();
    }
    return;
!!!5614594.java!!!	endElement(inout namespaceURI : String, inout localName : String, inout name : String) : void
        if (m_tracer != null)
            super.fireEndElem(name);
!!!5614722.java!!!	characters(inout ch : char [[]], in start : int, in length : int) : void

    flushPending();

    try
    {
        if (inTemporaryOutputState()) {
            /* leave characters un-processed as we are
             * creating temporary output, the output generated by
             * this serializer will be input to a final serializer
             * later on and it will do the processing in final
             * output state (not temporary output state).
             *
             * A "temporary" ToTextStream serializer is used to
             * evaluate attribute value templates (for example),
             * and the result of evaluating such a thing
             * is fed into a final serializer later on.
             */
            m_writer.write(ch, start, length);
        }
        else {
            // In final output state we do process the characters!
            writeNormalizedChars(ch, start, length, m_lineSepUse);
        }

        if (m_tracer != null)
            super.fireCharEvent(ch, start, length);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
!!!5614850.java!!!	charactersRaw(inout ch : char [[]], in start : int, in length : int) : void

    try
    {
      writeNormalizedChars(ch, start, length, m_lineSepUse);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
!!!5614978.java!!!	writeNormalizedChars(in ch : char [[]], in start : int, in length : int, in useLineSep : boolean) : void
        final String encoding = getEncoding();
        final java.io.Writer writer = m_writer;
        final int end = start + length;

        /* copy a few "constants" before the loop for performance */
        final char S_LINEFEED = CharInfo.S_LINEFEED;

        // This for() loop always increments i by one at the end
        // of the loop.  Additional increments of i adjust for when
        // two input characters (a high/low UTF16 surrogate pair)
        // are processed.
        for (int i = start; i < end; i++) {
            final char c = ch[i];

            if (S_LINEFEED == c && useLineSep) {
                writer.write(m_lineSep, 0, m_lineSepLen);
                // one input char processed
            } else if (m_encodingInfo.isInEncoding(c)) {
                writer.write(c);
                // one input char processed
            } else if (Encodings.isHighUTF16Surrogate(c)) {
                final int codePoint = writeUTF16Surrogate(c, ch, i, end);
                if (codePoint != 0) {
                    // I think we can just emit the message,
                    // not crash and burn.
                    final String integralValue = Integer.toString(codePoint);
                    final String msg = Utils.messages.createMessage(
                        MsgKey.ER_ILLEGAL_CHARACTER,
                        new Object[] { integralValue, encoding });

                    //Older behavior was to throw the message,
                    //but newer gentler behavior is to write a message to System.err
                    //throw new SAXException(msg);
                    System.err.println(msg);

                }
                i++; // two input chars processed
            } else {
                // Don't know what to do with this char, it is
                // not in the encoding and not a high char in
                // a surrogate pair, so write out as an entity ref
                if (encoding != null) {
                    /* The output encoding is known,
                     * so somthing is wrong.
                     */

                    // not in the encoding, so write out a character reference
                    writer.write('&');
                    writer.write('#');
                    writer.write(Integer.toString(c));
                    writer.write(';');

                    // I think we can just emit the message,
                    // not crash and burn.
                    final String integralValue = Integer.toString(c);
                    final String msg = Utils.messages.createMessage(
                        MsgKey.ER_ILLEGAL_CHARACTER,
                        new Object[] { integralValue, encoding });

                    //Older behavior was to throw the message,
                    //but newer gentler behavior is to write a message to System.err
                    //throw new SAXException(msg);
                    System.err.println(msg);
                } else {
                    /* The output encoding is not known,
                     * so just write it out as-is.
                     */
                    writer.write(c);
                }

                // one input char was processed
            }
        }
!!!5615106.java!!!	cdata(inout ch : char [[]], in start : int, in length : int) : void
    try
    {
        writeNormalizedChars(ch, start, length, m_lineSepUse);
        if (m_tracer != null)
            super.fireCDATAEvent(ch, start, length);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
!!!5615234.java!!!	ignorableWhitespace(inout ch : char [[]], in start : int, in length : int) : void

    try
    {
      writeNormalizedChars(ch, start, length, m_lineSepUse);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
!!!5615362.java!!!	processingInstruction(inout target : String, inout data : String) : void
    // flush anything pending first
    flushPending();

    if (m_tracer != null)
        super.fireEscapingEvent(target, data);
!!!5615490.java!!!	comment(inout data : String) : void
      final int length = data.length();
      if (length > m_charsBuff.length)
      {
          m_charsBuff = new char[length*2 + 1];
      }
      data.getChars(0, length, m_charsBuff, 0);
      comment(m_charsBuff, 0, length);
!!!5615618.java!!!	comment(inout ch : char [[]], in start : int, in length : int) : void

    flushPending();
    if (m_tracer != null)
        super.fireCommentEvent(ch, start, length);
!!!5615746.java!!!	entityReference(inout name : String) : void
        if (m_tracer != null)
            super.fireEntityReference(name);
!!!5615874.java!!!	addAttribute(inout uri : String, inout localName : String, inout rawName : String, inout type : String, inout value : String, inout XSLAttribute : boolean) : void
        // do nothing, just forget all about the attribute
!!!5616002.java!!!	endCDATA() : void
        // do nothing
!!!5616130.java!!!	endElement(inout elemName : String) : void
        if (m_tracer != null)
            super.fireEndElem(elemName);
!!!5616258.java!!!	startElement(inout elementNamespaceURI : String, inout elementLocalName : String, inout elementName : String) : void
        if (m_needToCallStartDocument)
            startDocumentInternal();
        // time to fire off startlement event.
        if (m_tracer != null) {
            super.fireStartElem(elementName);
            this.firePseudoAttributes();
        }

        return;
!!!5616386.java!!!	characters(inout characters : String) : void
        final int length = characters.length();
        if (length > m_charsBuff.length)
        {
            m_charsBuff = new char[length*2 + 1];
        }
        characters.getChars(0, length, m_charsBuff, 0);
        characters(m_charsBuff, 0, length);
!!!5616514.java!!!	addAttribute(inout name : String, inout value : String) : void
        // do nothing, forget about the attribute
!!!5616642.java!!!	addUniqueAttribute(inout qName : String, inout value : String, in flags : int) : void
        // do nothing, forget about the attribute
!!!5616770.java!!!	startPrefixMapping(inout prefix : String, inout uri : String, inout shouldFlush : boolean) : boolean
        // no namespace support for HTML
        return false;
!!!5616898.java!!!	startPrefixMapping(inout prefix : String, inout uri : String) : void
        // no namespace support for HTML
!!!5617026.java!!!	namespaceAfterStartElement(in prefix : String, in uri : String) : void
        // no namespace support for HTML
!!!5617154.java!!!	flushPending() : void
            if (m_needToCallStartDocument)
            {
                startDocumentInternal();
                m_needToCallStartDocument = false;
            }
