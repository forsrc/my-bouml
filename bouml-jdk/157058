format 222
"locks" // jdk1.8::java::util::concurrent::locks
  revision 3
  modified_by 2 "forsrc"
  // class settings
  
  classdiagramsettings member_max_width 0 end
  
  classcompositediagramsettings end
  
  usecasediagramsettings end
  
  sequencediagramsettings end
  
  collaborationdiagramsettings end
  
  objectdiagramsettings end
  
  objectcompositediagramsettings end
  
  componentdiagramsettings
   end
  
  deploymentdiagramsettings
   end
  
  statediagramsettings
   end
  
  activitydiagramsettings
   end
  
  java_dir "/Volumes/My/My/git/MyGit/my-bouml/jdk1.8/java/util/concurrent/locks/"
  java_package "java.util.concurrent.locks"
  classview 152194 "locks"
    
    classdiagramsettings member_max_width 0 end
    
    classcompositediagramsettings end
    
    collaborationdiagramsettings end
    
    objectdiagramsettings end
    
    objectcompositediagramsettings end
    
    sequencediagramsettings end
    
    statediagramsettings
     end
    
    
    activitydiagramsettings
     end
    class 489090 "ReentrantReadWriteLock"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "An implementation of {@link ReadWriteLock} supporting similar
semantics to {@link ReentrantLock}.
<p>This class has the following properties:

<ul>
<li><b>Acquisition order</b>

<p>This class does not impose a reader or writer preference
ordering for lock access.  However, it does support an optional
<em>fairness</em> policy.

<dl>
<dt><b><i>Non-fair mode (default)</i></b>
<dd>When constructed as non-fair (the default), the order of entry
to the read and write lock is unspecified, subject to reentrancy
constraints.  A nonfair lock that is continuously contended may
indefinitely postpone one or more reader or writer threads, but
will normally have higher throughput than a fair lock.

<dt><b><i>Fair mode</i></b>
<dd>When constructed as fair, threads contend for entry using an
approximately arrival-order policy. When the currently held lock
is released, either the longest-waiting single writer thread will
be assigned the write lock, or if there is a group of reader threads
waiting longer than all waiting writer threads, that group will be
assigned the read lock.

<p>A thread that tries to acquire a fair read lock (non-reentrantly)
will block if either the write lock is held, or there is a waiting
writer thread. The thread will not acquire the read lock until
after the oldest currently waiting writer thread has acquired and
released the write lock. Of course, if a waiting writer abandons
its wait, leaving one or more reader threads as the longest waiters
in the queue with the write lock free, then those readers will be
assigned the read lock.

<p>A thread that tries to acquire a fair write lock (non-reentrantly)
will block unless both the read lock and write lock are free (which
implies there are no waiting threads).  (Note that the non-blocking
{@link ReadLock#tryLock()} and {@link WriteLock#tryLock()} methods
do not honor this fair setting and will immediately acquire the lock
if it is possible, regardless of waiting threads.)
<p>
</dl>

<li><b>Reentrancy</b>

<p>This lock allows both readers and writers to reacquire read or
write locks in the style of a {@link ReentrantLock}. Non-reentrant
readers are not allowed until all write locks held by the writing
thread have been released.

<p>Additionally, a writer can acquire the read lock, but not
vice-versa.  Among other applications, reentrancy can be useful
when write locks are held during calls or callbacks to methods that
perform reads under read locks.  If a reader tries to acquire the
write lock it will never succeed.

<li><b>Lock downgrading</b>
<p>Reentrancy also allows downgrading from the write lock to a read lock,
by acquiring the write lock, then the read lock and then releasing the
write lock. However, upgrading from a read lock to the write lock is
<b>not</b> possible.

<li><b>Interruption of lock acquisition</b>
<p>The read lock and write lock both support interruption during lock
acquisition.

<li><b>{@link Condition} support</b>
<p>The write lock provides a {@link Condition} implementation that
behaves in the same way, with respect to the write lock, as the
{@link Condition} implementation provided by
{@link ReentrantLock#newCondition} does for {@link ReentrantLock}.
This {@link Condition} can, of course, only be used with the write lock.

<p>The read lock does not support a {@link Condition} and
{@code readLock().newCondition()} throws
{@code UnsupportedOperationException}.

<li><b>Instrumentation</b>
<p>This class supports methods to determine whether locks
are held or contended. These methods are designed for monitoring
system state, not for synchronization control.
</ul>

<p>Serialization of this class behaves in the same way as built-in
locks: a deserialized lock is in the unlocked state, regardless of
its state when serialized.

<p><b>Sample usages</b>. Here is a code sketch showing how to perform
lock downgrading after updating a cache (exception handling is
particularly tricky when handling multiple locks in a non-nested
fashion):

<pre> {@code
class CachedData {
  Object data;
  volatile boolean cacheValid;
  final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

  void processCachedData() {
    rwl.readLock().lock();
    if (!cacheValid) {
      // Must release read lock before acquiring write lock
      rwl.readLock().unlock();
      rwl.writeLock().lock();
      try {
        // Recheck state because another thread might have
        // acquired write lock and changed state before we did.
        if (!cacheValid) {
          data = ...
          cacheValid = true;
        }
        // Downgrade by acquiring read lock before releasing write lock
        rwl.readLock().lock();
      } finally {
        rwl.writeLock().unlock(); // Unlock write, still hold read
      }
    }

    try {
      use(data);
    } finally {
      rwl.readLock().unlock();
    }
  }
}}</pre>

ReentrantReadWriteLocks can be used to improve concurrency in some
uses of some kinds of Collections. This is typically worthwhile
only when the collections are expected to be large, accessed by
more reader threads than writer threads, and entail operations with
overhead that outweighs synchronization overhead. For example, here
is a class using a TreeMap that is expected to be large and
concurrently accessed.

 <pre> {@code
class RWDictionary {
  private final Map<String, Data> m = new TreeMap<String, Data>();
  private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
  private final Lock r = rwl.readLock();
  private final Lock w = rwl.writeLock();

  public Data get(String key) {
    r.lock();
    try { return m.get(key); }
    finally { r.unlock(); }
  }
  public String[] allKeys() {
    r.lock();
    try { return m.keySet().toArray(); }
    finally { r.unlock(); }
  }
  public Data put(String key, Data value) {
    w.lock();
    try { return m.put(key, value); }
    finally { w.unlock(); }
  }
  public void clear() {
    w.lock();
    try { m.clear(); }
    finally { w.unlock(); }
  }
}}</pre>

<h3>Implementation Notes</h3>

<p>This lock supports a maximum of 65535 recursive write locks
and 65535 read locks. Attempts to exceed these limits result in
{@link Error} throws from locking methods.

@since 1.5
@author Doug Lea
"
      classrelation 3649922 // <realization>
	relation 3649922 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3649922 // <realization>
	  b parent class_ref 1131010 // ReadWriteLock
      end

      classrelation 3650050 // <realization>
	relation 3650050 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3650050 // <realization>
	  b parent class_ref 136578 // Serializable
      end

      attribute 2165378 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " -6992448646407690164L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      class 1131138 "ReadLock"
	visibility public 
	cpp_decl ""
	static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3651458 // <realization>
	  relation 3651458 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 3651458 // <realization>
	    b parent class_ref 864642 // Lock
	end

	classrelation 3651586 // <realization>
	  relation 3651586 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 3651586 // <realization>
	    b parent class_ref 136578 // Serializable
	end

	attribute 2166786 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " -5992448646407690164L"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	classrelation 3651714 // sync (<unidirectional association>)
	  relation 3651714 --->
	    a role_name "sync" const_relation private
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3651714 // sync (<unidirectional association>)
	    b parent class_ref 1131394 // Sync
	end

	operation 9307906 "ReadLock"
	  protected explicit_return_type ""
	  nparams 1
	    param inout name "lock" type class_ref 489090 // ReentrantReadWriteLock
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Constructor for use by subclasses

@param lock the outer lock object
@throws NullPointerException if the lock is null
"
	end

	operation 9308034 "lock"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the read lock.

<p>Acquires the read lock if the write lock is not held by
another thread and returns immediately.

<p>If the write lock is held by another thread then
the current thread becomes disabled for thread scheduling
purposes and lies dormant until the read lock has been acquired.
"
	end

	operation 9308162 "lockInterruptibly"
	  public explicit_return_type "void"
	  nparams 0
	  nexceptions 1
	    exception class_ref 129666 // InterruptedException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the read lock unless the current thread is
{@linkplain Thread#interrupt interrupted}.

<p>Acquires the read lock if the write lock is not held
by another thread and returns immediately.

<p>If the write lock is held by another thread then the
current thread becomes disabled for thread scheduling
purposes and lies dormant until one of two things happens:

<ul>

<li>The read lock is acquired by the current thread; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread.

</ul>

<p>If the current thread:

<ul>

<li>has its interrupted status set on entry to this method; or

<li>is {@linkplain Thread#interrupt interrupted} while
acquiring the read lock,

</ul>

then {@link InterruptedException} is thrown and the current
thread's interrupted status is cleared.

<p>In this implementation, as this method is an explicit
interruption point, preference is given to responding to
the interrupt over normal or reentrant acquisition of the
lock.

@throws InterruptedException if the current thread is interrupted
"
	end

	operation 9308290 "tryLock"
	  public explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the read lock only if the write lock is not held by
another thread at the time of invocation.

<p>Acquires the read lock if the write lock is not held by
another thread and returns immediately with the value
{@code true}. Even when this lock has been set to use a
fair ordering policy, a call to {@code tryLock()}
<em>will</em> immediately acquire the read lock if it is
available, whether or not other threads are currently
waiting for the read lock.  This &quot;barging&quot; behavior
can be useful in certain circumstances, even though it
breaks fairness. If you want to honor the fairness setting
for this lock, then use {@link #tryLock(long, TimeUnit)
tryLock(0, TimeUnit.SECONDS) } which is almost equivalent
(it also detects interruption).

<p>If the write lock is held by another thread then
this method will return immediately with the value
{@code false}.

@return {@code true} if the read lock was acquired
"
	end

	operation 9308418 "tryLock"
	  public explicit_return_type "boolean"
	  nparams 2
	    param in name "timeout" explicit_type "long"
	    param inout name "unit" type class_ref 935938 // TimeUnit
	  nexceptions 1
	    exception class_ref 129666 // InterruptedException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the read lock if the write lock is not held by
another thread within the given waiting time and the
current thread has not been {@linkplain Thread#interrupt
interrupted}.

<p>Acquires the read lock if the write lock is not held by
another thread and returns immediately with the value
{@code true}. If this lock has been set to use a fair
ordering policy then an available lock <em>will not</em> be
acquired if any other threads are waiting for the
lock. This is in contrast to the {@link #tryLock()}
method. If you want a timed {@code tryLock} that does
permit barging on a fair lock then combine the timed and
un-timed forms together:

 <pre> {@code
if (lock.tryLock() ||
    lock.tryLock(timeout, unit)) {
  ...
}}</pre>

<p>If the write lock is held by another thread then the
current thread becomes disabled for thread scheduling
purposes and lies dormant until one of three things happens:

<ul>

<li>The read lock is acquired by the current thread; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread; or

<li>The specified waiting time elapses.

</ul>

<p>If the read lock is acquired then the value {@code true} is
returned.

<p>If the current thread:

<ul>

<li>has its interrupted status set on entry to this method; or

<li>is {@linkplain Thread#interrupt interrupted} while
acquiring the read lock,

</ul> then {@link InterruptedException} is thrown and the
current thread's interrupted status is cleared.

<p>If the specified waiting time elapses then the value
{@code false} is returned.  If the time is less than or
equal to zero, the method will not wait at all.

<p>In this implementation, as this method is an explicit
interruption point, preference is given to responding to
the interrupt over normal or reentrant acquisition of the
lock, and over reporting the elapse of the waiting time.

@param timeout the time to wait for the read lock
@param unit the time unit of the timeout argument
@return {@code true} if the read lock was acquired
@throws InterruptedException if the current thread is interrupted
@throws NullPointerException if the time unit is null
"
	end

	operation 9308546 "unlock"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Attempts to release this lock.

<p>If the number of readers is now zero then the lock
is made available for write lock attempts.
"
	end

	operation 9308674 "newCondition"
	  public return_type class_ref 864770 // Condition
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Throws {@code UnsupportedOperationException} because
{@code ReadLocks} do not support conditions.

@throws UnsupportedOperationException always
"
	end

	operation 9308802 "toString"
	  public return_type class_ref 128130 // String
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns a string identifying this lock, as well as its lock state.
The state, in brackets, includes the String {@code \"Read locks =\"}
followed by the number of held read locks.

@return a string identifying this lock, as well as its lock state
"
	end
      end

      classrelation 3650178 // readerLock (<unidirectional association>)
	relation 3650178 --->
	  a role_name "readerLock" const_relation private
	    comment " Inner class providing readlock 
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 3650178 // readerLock (<unidirectional association>)
	  b parent class_ref 1131138 // ReadLock
      end

      class 1131266 "WriteLock"
	visibility public 
	cpp_decl ""
	static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3651842 // <realization>
	  relation 3651842 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 3651842 // <realization>
	    b parent class_ref 864642 // Lock
	end

	classrelation 3651970 // <realization>
	  relation 3651970 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 3651970 // <realization>
	    b parent class_ref 136578 // Serializable
	end

	attribute 2166914 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " -4992448646407690164L"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	classrelation 3652098 // sync (<unidirectional association>)
	  relation 3652098 --->
	    a role_name "sync" const_relation private
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3652098 // sync (<unidirectional association>)
	    b parent class_ref 1131394 // Sync
	end

	operation 9308930 "WriteLock"
	  protected explicit_return_type ""
	  nparams 1
	    param inout name "lock" type class_ref 489090 // ReentrantReadWriteLock
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Constructor for use by subclasses

@param lock the outer lock object
@throws NullPointerException if the lock is null
"
	end

	operation 9309058 "lock"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the write lock.

<p>Acquires the write lock if neither the read nor write lock
are held by another thread
and returns immediately, setting the write lock hold count to
one.

<p>If the current thread already holds the write lock then the
hold count is incremented by one and the method returns
immediately.

<p>If the lock is held by another thread then the current
thread becomes disabled for thread scheduling purposes and
lies dormant until the write lock has been acquired, at which
time the write lock hold count is set to one.
"
	end

	operation 9309186 "lockInterruptibly"
	  public explicit_return_type "void"
	  nparams 0
	  nexceptions 1
	    exception class_ref 129666 // InterruptedException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the write lock unless the current thread is
{@linkplain Thread#interrupt interrupted}.

<p>Acquires the write lock if neither the read nor write lock
are held by another thread
and returns immediately, setting the write lock hold count to
one.

<p>If the current thread already holds this lock then the
hold count is incremented by one and the method returns
immediately.

<p>If the lock is held by another thread then the current
thread becomes disabled for thread scheduling purposes and
lies dormant until one of two things happens:

<ul>

<li>The write lock is acquired by the current thread; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread.

</ul>

<p>If the write lock is acquired by the current thread then the
lock hold count is set to one.

<p>If the current thread:

<ul>

<li>has its interrupted status set on entry to this method;
or

<li>is {@linkplain Thread#interrupt interrupted} while
acquiring the write lock,

</ul>

then {@link InterruptedException} is thrown and the current
thread's interrupted status is cleared.

<p>In this implementation, as this method is an explicit
interruption point, preference is given to responding to
the interrupt over normal or reentrant acquisition of the
lock.

@throws InterruptedException if the current thread is interrupted
"
	end

	operation 9309314 "tryLock"
	  public explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the write lock only if it is not held by another thread
at the time of invocation.

<p>Acquires the write lock if neither the read nor write lock
are held by another thread
and returns immediately with the value {@code true},
setting the write lock hold count to one. Even when this lock has
been set to use a fair ordering policy, a call to
{@code tryLock()} <em>will</em> immediately acquire the
lock if it is available, whether or not other threads are
currently waiting for the write lock.  This &quot;barging&quot;
behavior can be useful in certain circumstances, even
though it breaks fairness. If you want to honor the
fairness setting for this lock, then use {@link
#tryLock(long, TimeUnit) tryLock(0, TimeUnit.SECONDS) }
which is almost equivalent (it also detects interruption).

<p>If the current thread already holds this lock then the
hold count is incremented by one and the method returns
{@code true}.

<p>If the lock is held by another thread then this method
will return immediately with the value {@code false}.

@return {@code true} if the lock was free and was acquired
by the current thread, or the write lock was already held
by the current thread; and {@code false} otherwise.
"
	end

	operation 9309442 "tryLock"
	  public explicit_return_type "boolean"
	  nparams 2
	    param in name "timeout" explicit_type "long"
	    param inout name "unit" type class_ref 935938 // TimeUnit
	  nexceptions 1
	    exception class_ref 129666 // InterruptedException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires the write lock if it is not held by another thread
within the given waiting time and the current thread has
not been {@linkplain Thread#interrupt interrupted}.

<p>Acquires the write lock if neither the read nor write lock
are held by another thread
and returns immediately with the value {@code true},
setting the write lock hold count to one. If this lock has been
set to use a fair ordering policy then an available lock
<em>will not</em> be acquired if any other threads are
waiting for the write lock. This is in contrast to the {@link
#tryLock()} method. If you want a timed {@code tryLock}
that does permit barging on a fair lock then combine the
timed and un-timed forms together:

 <pre> {@code
if (lock.tryLock() ||
    lock.tryLock(timeout, unit)) {
  ...
}}</pre>

<p>If the current thread already holds this lock then the
hold count is incremented by one and the method returns
{@code true}.

<p>If the lock is held by another thread then the current
thread becomes disabled for thread scheduling purposes and
lies dormant until one of three things happens:

<ul>

<li>The write lock is acquired by the current thread; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread; or

<li>The specified waiting time elapses

</ul>

<p>If the write lock is acquired then the value {@code true} is
returned and the write lock hold count is set to one.

<p>If the current thread:

<ul>

<li>has its interrupted status set on entry to this method;
or

<li>is {@linkplain Thread#interrupt interrupted} while
acquiring the write lock,

</ul>

then {@link InterruptedException} is thrown and the current
thread's interrupted status is cleared.

<p>If the specified waiting time elapses then the value
{@code false} is returned.  If the time is less than or
equal to zero, the method will not wait at all.

<p>In this implementation, as this method is an explicit
interruption point, preference is given to responding to
the interrupt over normal or reentrant acquisition of the
lock, and over reporting the elapse of the waiting time.

@param timeout the time to wait for the write lock
@param unit the time unit of the timeout argument

@return {@code true} if the lock was free and was acquired
by the current thread, or the write lock was already held by the
current thread; and {@code false} if the waiting time
elapsed before the lock could be acquired.

@throws InterruptedException if the current thread is interrupted
@throws NullPointerException if the time unit is null
"
	end

	operation 9309570 "unlock"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Attempts to release this lock.

<p>If the current thread is the holder of this lock then
the hold count is decremented. If the hold count is now
zero then the lock is released.  If the current thread is
not the holder of this lock then {@link
IllegalMonitorStateException} is thrown.

@throws IllegalMonitorStateException if the current thread does not
hold this lock
"
	end

	operation 9309698 "newCondition"
	  public return_type class_ref 864770 // Condition
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns a {@link Condition} instance for use with this
{@link Lock} instance.
<p>The returned {@link Condition} instance supports the same
usages as do the {@link Object} monitor methods ({@link
Object#wait() wait}, {@link Object#notify notify}, and {@link
Object#notifyAll notifyAll}) when used with the built-in
monitor lock.

<ul>

<li>If this write lock is not held when any {@link
Condition} method is called then an {@link
IllegalMonitorStateException} is thrown.  (Read locks are
held independently of write locks, so are not checked or
affected. However it is essentially always an error to
invoke a condition waiting method when the current thread
has also acquired read locks, since other threads that
could unblock it will not be able to acquire the write
lock.)

<li>When the condition {@linkplain Condition#await() waiting}
methods are called the write lock is released and, before
they return, the write lock is reacquired and the lock hold
count restored to what it was when the method was called.

<li>If a thread is {@linkplain Thread#interrupt interrupted} while
waiting then the wait will terminate, an {@link
InterruptedException} will be thrown, and the thread's
interrupted status will be cleared.

<li> Waiting threads are signalled in FIFO order.

<li>The ordering of lock reacquisition for threads returning
from waiting methods is the same as for threads initially
acquiring the lock, which is in the default case not specified,
but for <em>fair</em> locks favors those threads that have been
waiting the longest.

</ul>

@return the Condition object
"
	end

	operation 9309826 "toString"
	  public return_type class_ref 128130 // String
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns a string identifying this lock, as well as its lock
state.  The state, in brackets includes either the String
{@code \"Unlocked\"} or the String {@code \"Locked by\"}
followed by the {@linkplain Thread#getName name} of the owning thread.

@return a string identifying this lock, as well as its lock state
"
	end

	operation 9309954 "isHeldByCurrentThread"
	  public explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Queries if this write lock is held by the current thread.
Identical in effect to {@link
ReentrantReadWriteLock#isWriteLockedByCurrentThread}.

@return {@code true} if the current thread holds this lock and
        {@code false} otherwise
@since 1.6
"
	end

	operation 9310082 "getHoldCount"
	  public explicit_return_type "int"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Queries the number of holds on this write lock by the current
thread.  A thread has a hold on a lock for each lock action
that is not matched by an unlock action.  Identical in effect
to {@link ReentrantReadWriteLock#getWriteHoldCount}.

@return the number of holds on this lock by the current thread,
        or zero if this lock is not held by the current thread
@since 1.6
"
	end
      end

      classrelation 3650306 // writerLock (<unidirectional association>)
	relation 3650306 --->
	  a role_name "writerLock" const_relation private
	    comment " Inner class providing writelock 
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 3650306 // writerLock (<unidirectional association>)
	  b parent class_ref 1131266 // WriteLock
      end

      class 1131394 "Sync"
	abstract visibility package 
	cpp_decl ""
	static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3650562 // <generalisation>
	  relation 3650562 ---|>
	    a public
	      java "${type}"
	      classrelation_ref 3650562 // <generalisation>
	    b parent class_ref 1106050 // AbstractQueuedSynchronizer
	end

	attribute 2165506 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " 6317671515068378041L"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	attribute 2165634 "SHARED_SHIFT"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " 16"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment "Read vs write count extraction constants and functions.
Lock state is logically divided into two unsigned shorts:
The lower one representing the exclusive (writer) lock hold count,
and the upper the shared (reader) hold count.

"
	end

	attribute 2165762 "SHARED_UNIT"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " (1 << SHARED_SHIFT)"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	attribute 2165890 "MAX_COUNT"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " (1 << SHARED_SHIFT) - 1"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	attribute 2166018 "EXCLUSIVE_MASK"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " (1 << SHARED_SHIFT) - 1"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	operation 9304450 "sharedCount"
	  class_operation package explicit_return_type "int"
	  nparams 1
	    param in name "c" explicit_type "int"
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " Returns the number of shared holds represented in count  "
	end

	operation 9304578 "exclusiveCount"
	  class_operation package explicit_return_type "int"
	  nparams 1
	    param in name "c" explicit_type "int"
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " Returns the number of exclusive holds represented in count  "
	end

	class 1131522 "HoldCounter"
	  visibility package 
	  cpp_decl ""
	  final static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	  php_decl ""
	  python_2_2 python_decl ""
	  idl_decl ""
	  explicit_switch_type ""
	  mysql_decl ""
	  
	  attribute 2166146 "count"
	    package explicit_type "int"
	    init_value " 0"
	    cpp_decl ""
	    java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    php_decl ""
	    python_decl ""
	    idl_decl ""
	    mysql_decl ""
	    MysqlColumn
	  end

	  attribute 2166274 "tid"
	    const_attribute package explicit_type "long"
	    init_value " getThreadId(Thread.currentThread())"
	    cpp_decl ""
	    java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    php_decl ""
	    python_decl ""
	    idl_decl ""
	    mysql_decl ""
	    MysqlColumn
	    comment " Use id, not reference, to avoid garbage retention
"
	  end
	end

	class 1131650 "ThreadLocalHoldCounter"
	  visibility package 
	  nactuals 1
	  actual class class_ref 129282 // ThreadLocal
	    rank 0 explicit_value ""
	  cpp_decl ""
	  final static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	  php_decl ""
	  python_2_2 python_decl ""
	  idl_decl ""
	  explicit_switch_type ""
	  mysql_decl ""
	  
	  classrelation 3650690 // <realization>
	    relation 3650690 -_-|>
	      stereotype "bind"
	      a public
		java "${type}"
		classrelation_ref 3650690 // <realization>
	      b parent class_ref 129282 // ThreadLocal
	  end

	  operation 9304706 "initialValue"
	    public return_type class_ref 1131522 // HoldCounter
	    nparams 0
	    
	    preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	    
	    
	    
	  end
	end

	classrelation 3650818 // readHolds (<unidirectional association>)
	  relation 3650818 --->
	    a role_name "readHolds" private
	      comment "
The number of reentrant read locks held by current thread.
Initialized only in constructor and readObject.
Removed whenever a thread's read hold count drops to 0.

"
	      transient
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3650818 // readHolds (<unidirectional association>)
	    b parent class_ref 1131650 // ThreadLocalHoldCounter
	end

	classrelation 3650946 // cachedHoldCounter (<unidirectional association>)
	  relation 3650946 --->
	    a role_name "cachedHoldCounter" private
	      comment "
The hold count of the last thread to successfully acquire
readLock. This saves ThreadLocal lookup in the common case
where the next thread to release is the last one to
acquire. This is non-volatile since it is just used
as a heuristic, and would be great for threads to cache.

<p>Can outlive the Thread for which it is caching the read
hold count, but avoids garbage retention by not retaining a
reference to the Thread.

<p>Accessed via a benign data race; relies on the memory
model's final field and out-of-thin-air guarantees.

"
	      transient
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3650946 // cachedHoldCounter (<unidirectional association>)
	    b parent class_ref 1131522 // HoldCounter
	end

	classrelation 3651074 // firstReader (<unidirectional association>)
	  relation 3651074 --->
	    a role_name "firstReader" init_value " null" private
	      comment "
firstReader is the first thread to have acquired the read lock.
firstReaderHoldCount is firstReader's hold count.

<p>More precisely, firstReader is the unique thread that last
changed the shared count from 0 to 1, and has not released the
read lock since then; null if there is no such thread.

<p>Cannot cause garbage retention unless the thread terminated
without relinquishing its read locks, since tryReleaseShared
sets it to null.

<p>Accessed via a benign data race; relies on the memory
model's out-of-thin-air guarantees for references.

<p>This allows tracking of read holds for uncontended read
locks to be very cheap.

"
	      transient
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3651074 // firstReader (<unidirectional association>)
	    b parent class_ref 128642 // Thread
	end

	attribute 2166402 "firstReaderHoldCount"
	  private explicit_type "int"
	  cpp_decl ""
	  transient java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	operation 9304834 "Sync"
	  package explicit_return_type ""
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9304962 "readerShouldBlock"
	  abstract package explicit_return_type "boolean"
	  nparams 0
	  
	  java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Acquires and releases use the same code for fair and
nonfair locks, but differ in whether/how they allow barging
when queues are non-empty.


Returns true if the current thread, when trying to acquire
the read lock, and otherwise eligible to do so, should block
because of policy for overtaking other waiting threads.
"
	end

	operation 9305090 "writerShouldBlock"
	  abstract package explicit_return_type "boolean"
	  nparams 0
	  
	  java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns true if the current thread, when trying to acquire
the write lock, and otherwise eligible to do so, should block
because of policy for overtaking other waiting threads.
"
	end

	operation 9305218 "tryRelease"
	  protected explicit_return_type "boolean"
	  nparams 1
	    param in name "releases" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Note that tryRelease and tryAcquire can be called by
Conditions. So it is possible that their arguments contain
both read and write holds that are all released during a
condition wait and re-established in tryAcquire.
"
	end

	operation 9305346 "tryAcquire"
	  protected explicit_return_type "boolean"
	  nparams 1
	    param in name "acquires" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9305474 "tryReleaseShared"
	  protected explicit_return_type "boolean"
	  nparams 1
	    param in name "unused" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9305602 "unmatchedUnlockException"
	  private return_type class_ref 933250 // IllegalMonitorStateException
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9305730 "tryAcquireShared"
	  protected explicit_return_type "int"
	  nparams 1
	    param in name "unused" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9305858 "fullTryAcquireShared"
	  package explicit_return_type "int"
	  nparams 1
	    param inout name "current" type class_ref 128642 // Thread
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Full version of acquire for reads, that handles CAS misses
and reentrant reads not dealt with in tryAcquireShared.
"
	end

	operation 9305986 "tryWriteLock"
	  package explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Performs tryLock for write, enabling barging in both modes.
This is identical in effect to tryAcquire except for lack
of calls to writerShouldBlock.
"
	end

	operation 9306114 "tryReadLock"
	  package explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Performs tryLock for read, enabling barging in both modes.
This is identical in effect to tryAcquireShared except for
lack of calls to readerShouldBlock.
"
	end

	operation 9306242 "isHeldExclusively"
	  protected explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9306370 "newCondition"
	  package return_type class_ref 1106434 // ConditionObject
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " Methods relayed to outer class"
	end

	operation 9306498 "getOwner"
	  package return_type class_ref 128642 // Thread
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9306626 "getReadLockCount"
	  package explicit_return_type "int"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9306754 "isWriteLocked"
	  package explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9306882 "getWriteHoldCount"
	  package explicit_return_type "int"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9307010 "getReadHoldCount"
	  package explicit_return_type "int"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9307138 "readObject"
	  private explicit_return_type "void"
	  nparams 1
	    param inout name "s" type class_ref 168962 // ObjectInputStream
	  nexceptions 2
	    exception class_ref 146818 // IOException
	    exception class_ref 169730 // ClassNotFoundException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Reconstitutes the instance from a stream (that is, deserializes it).
"
	end

	operation 9307266 "getCount"
	  package explicit_return_type "int"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      classrelation 3650434 // sync (<unidirectional association>)
	relation 3650434 --->
	  a role_name "sync" const_relation package
	    comment " Performs all synchronization mechanics 
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 3650434 // sync (<unidirectional association>)
	  b parent class_ref 1131394 // Sync
      end

      operation 9303938 "ReentrantReadWriteLock"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates a new {@code ReentrantReadWriteLock} with
default (nonfair) ordering properties.
"
      end

      operation 9304066 "ReentrantReadWriteLock"
	public explicit_return_type ""
	nparams 1
	  param inout name "fair" explicit_type "boolean"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates a new {@code ReentrantReadWriteLock} with
the given fairness policy.

@param fair {@code true} if this lock should use a fair ordering policy
"
      end

      operation 9304194 "writeLock"
	public return_type class_ref 1131266 // WriteLock
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 9304322 "readLock"
	public return_type class_ref 1131138 // ReadLock
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      class 1131778 "NonfairSync"
	visibility package 
	cpp_decl ""
	final static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3651202 // <generalisation>
	  relation 3651202 ---|>
	    a public
	      java "${type}"
	      classrelation_ref 3651202 // <generalisation>
	    b parent class_ref 1131394 // Sync
	end

	attribute 2166530 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " -8159625535654395037L"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	operation 9307394 "writerShouldBlock"
	  package explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9307522 "readerShouldBlock"
	  package explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      class 1131906 "FairSync"
	visibility package 
	cpp_decl ""
	final static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3651330 // <generalisation>
	  relation 3651330 ---|>
	    a public
	      java "${type}"
	      classrelation_ref 3651330 // <generalisation>
	    b parent class_ref 1131394 // Sync
	end

	attribute 2166658 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " -2274990926593161451L"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	operation 9307650 "writerShouldBlock"
	  package explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9307778 "readerShouldBlock"
	  package explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      operation 9310210 "isFair"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Instrumentation and status

Returns {@code true} if this lock has fairness set true.

@return {@code true} if this lock has fairness set true
"
      end

      operation 9310338 "getOwner"
	protected return_type class_ref 128642 // Thread
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the thread that currently owns the write lock, or
{@code null} if not owned. When this method is called by a
thread that is not the owner, the return value reflects a
best-effort approximation of current lock status. For example,
the owner may be momentarily {@code null} even if there are
threads trying to acquire the lock but have not yet done so.
This method is designed to facilitate construction of
subclasses that provide more extensive lock monitoring
facilities.

@return the owner, or {@code null} if not owned
"
      end

      operation 9310466 "getReadLockCount"
	public explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries the number of read locks held for this lock. This
method is designed for use in monitoring system state, not for
synchronization control.
@return the number of read locks held
"
      end

      operation 9310594 "isWriteLocked"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries if the write lock is held by any thread. This method is
designed for use in monitoring system state, not for
synchronization control.

@return {@code true} if any thread holds the write lock and
        {@code false} otherwise
"
      end

      operation 9310722 "isWriteLockedByCurrentThread"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries if the write lock is held by the current thread.

@return {@code true} if the current thread holds the write lock and
        {@code false} otherwise
"
      end

      operation 9310850 "getWriteHoldCount"
	public explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries the number of reentrant write holds on this lock by the
current thread.  A writer thread has a hold on a lock for
each lock action that is not matched by an unlock action.

@return the number of holds on the write lock by the current thread,
        or zero if the write lock is not held by the current thread
"
      end

      operation 9310978 "getReadHoldCount"
	public explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries the number of reentrant read holds on this lock by the
current thread.  A reader thread has a hold on a lock for
each lock action that is not matched by an unlock action.

@return the number of holds on the read lock by the current thread,
        or zero if the read lock is not held by the current thread
@since 1.6
"
      end

      operation 9311106 "getQueuedWriterThreads"
	protected return_type class_ref 184194 // Collection
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire the write lock.  Because the actual set of threads may
change dynamically while constructing this result, the returned
collection is only a best-effort estimate.  The elements of the
returned collection are in no particular order.  This method is
designed to facilitate construction of subclasses that provide
more extensive lock monitoring facilities.

@return the collection of threads
"
      end

      operation 9311234 "getQueuedReaderThreads"
	protected return_type class_ref 184194 // Collection
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire the read lock.  Because the actual set of threads may
change dynamically while constructing this result, the returned
collection is only a best-effort estimate.  The elements of the
returned collection are in no particular order.  This method is
designed to facilitate construction of subclasses that provide
more extensive lock monitoring facilities.

@return the collection of threads
"
      end

      operation 9311362 "hasQueuedThreads"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads are waiting to acquire the read or
write lock. Note that because cancellations may occur at any
time, a {@code true} return does not guarantee that any other
thread will ever acquire a lock.  This method is designed
primarily for use in monitoring of the system state.

@return {@code true} if there may be other threads waiting to
        acquire the lock
"
      end

      operation 9311490 "hasQueuedThread"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "thread" type class_ref 128642 // Thread
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether the given thread is waiting to acquire either
the read or write lock. Note that because cancellations may
occur at any time, a {@code true} return does not guarantee
that this thread will ever acquire a lock.  This method is
designed primarily for use in monitoring of the system state.

@param thread the thread
@return {@code true} if the given thread is queued waiting for this lock
@throws NullPointerException if the thread is null
"
      end

      operation 9311618 "getQueueLength"
	public explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an estimate of the number of threads waiting to acquire
either the read or write lock.  The value is only an estimate
because the number of threads may change dynamically while this
method traverses internal data structures.  This method is
designed for use in monitoring of the system state, not for
synchronization control.

@return the estimated number of threads waiting for this lock
"
      end

      operation 9311746 "getQueuedThreads"
	protected return_type class_ref 184194 // Collection
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire either the read or write lock.  Because the actual set
of threads may change dynamically while constructing this
result, the returned collection is only a best-effort estimate.
The elements of the returned collection are in no particular
order.  This method is designed to facilitate construction of
subclasses that provide more extensive monitoring facilities.

@return the collection of threads
"
      end

      operation 9311874 "hasWaiters"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "condition" type class_ref 864770 // Condition
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads are waiting on the given condition
associated with the write lock. Note that because timeouts and
interrupts may occur at any time, a {@code true} return does
not guarantee that a future {@code signal} will awaken any
threads.  This method is designed primarily for use in
monitoring of the system state.

@param condition the condition
@return {@code true} if there are any waiting threads
@throws IllegalMonitorStateException if this lock is not held
@throws IllegalArgumentException if the given condition is
        not associated with this lock
@throws NullPointerException if the condition is null
"
      end

      operation 9312002 "getWaitQueueLength"
	public explicit_return_type "int"
	nparams 1
	  param inout name "condition" type class_ref 864770 // Condition
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an estimate of the number of threads waiting on the
given condition associated with the write lock. Note that because
timeouts and interrupts may occur at any time, the estimate
serves only as an upper bound on the actual number of waiters.
This method is designed for use in monitoring of the system
state, not for synchronization control.

@param condition the condition
@return the estimated number of waiting threads
@throws IllegalMonitorStateException if this lock is not held
@throws IllegalArgumentException if the given condition is
        not associated with this lock
@throws NullPointerException if the condition is null
"
      end

      operation 9312130 "getWaitingThreads"
	protected return_type class_ref 184194 // Collection
	nparams 1
	  param inout name "condition" type class_ref 864770 // Condition
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing those threads that may be
waiting on the given condition associated with the write lock.
Because the actual set of threads may change dynamically while
constructing this result, the returned collection is only a
best-effort estimate. The elements of the returned collection
are in no particular order.  This method is designed to
facilitate construction of subclasses that provide more
extensive condition monitoring facilities.

@param condition the condition
@return the collection of threads
@throws IllegalMonitorStateException if this lock is not held
@throws IllegalArgumentException if the given condition is
        not associated with this lock
@throws NullPointerException if the condition is null
"
      end

      operation 9312258 "toString"
	public return_type class_ref 128130 // String
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a string identifying this lock, as well as its lock state.
The state, in brackets, includes the String {@code \"Write locks =\"}
followed by the number of reentrantly held write locks, and the
String {@code \"Read locks =\"} followed by the number of held
read locks.

@return a string identifying this lock, as well as its lock state
"
      end

      operation 9312386 "getThreadId"
	class_operation package explicit_return_type "long"
	nparams 1
	  param inout name "thread" type class_ref 128642 // Thread
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the thread id for the given thread.  We must access
this directly rather than via method Thread.getId() because
getId() is not final, and has been known to be overridden in
ways that do not preserve unique mappings.
"
      end

      attribute 2167042 "UNSAFE"
	class_attribute const_attribute private explicit_type "sun.misc.Unsafe"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Unsafe mechanics
"
      end

      attribute 2167170 "TID_OFFSET"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      extra_member 177410 "initialization"
	
	cpp "" ""
	java "  static {
        try {
            UNSAFE = sun.misc.Unsafe.getUnsafe();
            Class<?> tk = Thread.class;
            TID_OFFSET = UNSAFE.objectFieldOffset
                (tk.getDeclaredField(\"tid\"));
        } catch (Exception e) {
            throw new Error(e);
        }
    }"
	php ""
	python ""
	idl ""
	mysql ""
      end
    end

    class 864642 "Lock"
      visibility public stereotype "interface"
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "{@code Lock} implementations provide more extensive locking
operations than can be obtained using {@code synchronized} methods
and statements.  They allow more flexible structuring, may have
quite different properties, and may support multiple associated
{@link Condition} objects.

<p>A lock is a tool for controlling access to a shared resource by
multiple threads. Commonly, a lock provides exclusive access to a
shared resource: only one thread at a time can acquire the lock and
all access to the shared resource requires that the lock be
acquired first. However, some locks may allow concurrent access to
a shared resource, such as the read lock of a {@link ReadWriteLock}.

<p>The use of {@code synchronized} methods or statements provides
access to the implicit monitor lock associated with every object, but
forces all lock acquisition and release to occur in a block-structured way:
when multiple locks are acquired they must be released in the opposite
order, and all locks must be released in the same lexical scope in which
they were acquired.

<p>While the scoping mechanism for {@code synchronized} methods
and statements makes it much easier to program with monitor locks,
and helps avoid many common programming errors involving locks,
there are occasions where you need to work with locks in a more
flexible way. For example, some algorithms for traversing
concurrently accessed data structures require the use of
&quot;hand-over-hand&quot; or &quot;chain locking&quot;: you
acquire the lock of node A, then node B, then release A and acquire
C, then release B and acquire D and so on.  Implementations of the
{@code Lock} interface enable the use of such techniques by
allowing a lock to be acquired and released in different scopes,
and allowing multiple locks to be acquired and released in any
order.

<p>With this increased flexibility comes additional
responsibility. The absence of block-structured locking removes the
automatic release of locks that occurs with {@code synchronized}
methods and statements. In most cases, the following idiom
should be used:

 <pre> {@code
Lock l = ...;
l.lock();
try {
  // access the resource protected by this lock
} finally {
  l.unlock();
}}</pre>

When locking and unlocking occur in different scopes, care must be
taken to ensure that all code that is executed while the lock is
held is protected by try-finally or try-catch to ensure that the
lock is released when necessary.

<p>{@code Lock} implementations provide additional functionality
over the use of {@code synchronized} methods and statements by
providing a non-blocking attempt to acquire a lock ({@link
#tryLock()}), an attempt to acquire the lock that can be
interrupted ({@link #lockInterruptibly}, and an attempt to acquire
the lock that can timeout ({@link #tryLock(long, TimeUnit)}).

<p>A {@code Lock} class can also provide behavior and semantics
that is quite different from that of the implicit monitor lock,
such as guaranteed ordering, non-reentrant usage, or deadlock
detection. If an implementation provides such specialized semantics
then the implementation must document those semantics.

<p>Note that {@code Lock} instances are just normal objects and can
themselves be used as the target in a {@code synchronized} statement.
Acquiring the
monitor lock of a {@code Lock} instance has no specified relationship
with invoking any of the {@link #lock} methods of that instance.
It is recommended that to avoid confusion you never use {@code Lock}
instances in this way, except within their own implementation.

<p>Except where noted, passing a {@code null} value for any
parameter will result in a {@link NullPointerException} being
thrown.

<h3>Memory Synchronization</h3>

<p>All {@code Lock} implementations <em>must</em> enforce the same
memory synchronization semantics as provided by the built-in monitor
lock, as described in
<a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4\">
The Java Language Specification (17.4 Memory Model)</a>:
<ul>
<li>A successful {@code lock} operation has the same memory
synchronization effects as a successful <em>Lock</em> action.
<li>A successful {@code unlock} operation has the same
memory synchronization effects as a successful <em>Unlock</em> action.
</ul>

Unsuccessful locking and unlocking operations, and reentrant
locking/unlocking operations, do not require any memory
synchronization effects.

<h3>Implementation Considerations</h3>

<p>The three forms of lock acquisition (interruptible,
non-interruptible, and timed) may differ in their performance
characteristics, ordering guarantees, or other implementation
qualities.  Further, the ability to interrupt the <em>ongoing</em>
acquisition of a lock may not be available in a given {@code Lock}
class.  Consequently, an implementation is not required to define
exactly the same guarantees or semantics for all three forms of
lock acquisition, nor is it required to support interruption of an
ongoing lock acquisition.  An implementation is required to clearly
document the semantics and guarantees provided by each of the
locking methods. It must also obey the interruption semantics as
defined in this interface, to the extent that interruption of lock
acquisition is supported: which is either totally, or only on
method entry.

<p>As interruption generally implies cancellation, and checks for
interruption are often infrequent, an implementation can favor responding
to an interrupt over normal method return. This is true even if it can be
shown that the interrupt occurred after another action may have unblocked
the thread. An implementation should document this behavior.

@see ReentrantLock
@see Condition
@see ReadWriteLock

@since 1.5
@author Doug Lea
"
      operation 9039106 "lock"
	public explicit_return_type "void"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock.

<p>If the lock is not available then the current thread becomes
disabled for thread scheduling purposes and lies dormant until the
lock has been acquired.

<p><b>Implementation Considerations</b>

<p>A {@code Lock} implementation may be able to detect erroneous use
of the lock, such as an invocation that would cause deadlock, and
may throw an (unchecked) exception in such circumstances.  The
circumstances and the exception type must be documented by that
{@code Lock} implementation.
"
      end

      operation 9039234 "lockInterruptibly"
	public explicit_return_type "void"
	nparams 0
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock unless the current thread is
{@linkplain Thread#interrupt interrupted}.

<p>Acquires the lock if it is available and returns immediately.

<p>If the lock is not available then the current thread becomes
disabled for thread scheduling purposes and lies dormant until
one of two things happens:

<ul>
<li>The lock is acquired by the current thread; or
<li>Some other thread {@linkplain Thread#interrupt interrupts} the
current thread, and interruption of lock acquisition is supported.
</ul>

<p>If the current thread:
<ul>
<li>has its interrupted status set on entry to this method; or
<li>is {@linkplain Thread#interrupt interrupted} while acquiring the
lock, and interruption of lock acquisition is supported,
</ul>
then {@link InterruptedException} is thrown and the current thread's
interrupted status is cleared.

<p><b>Implementation Considerations</b>

<p>The ability to interrupt a lock acquisition in some
implementations may not be possible, and if possible may be an
expensive operation.  The programmer should be aware that this
may be the case. An implementation should document when this is
the case.

<p>An implementation can favor responding to an interrupt over
normal method return.

<p>A {@code Lock} implementation may be able to detect
erroneous use of the lock, such as an invocation that would
cause deadlock, and may throw an (unchecked) exception in such
circumstances.  The circumstances and the exception type must
be documented by that {@code Lock} implementation.

@throws InterruptedException if the current thread is
        interrupted while acquiring the lock (and interruption
        of lock acquisition is supported)
"
      end

      operation 9039362 "tryLock"
	public explicit_return_type "boolean"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock only if it is free at the time of invocation.

<p>Acquires the lock if it is available and returns immediately
with the value {@code true}.
If the lock is not available then this method will return
immediately with the value {@code false}.

<p>A typical usage idiom for this method would be:
 <pre> {@code
Lock lock = ...;
if (lock.tryLock()) {
  try {
    // manipulate protected state
  } finally {
    lock.unlock();
  }
} else {
  // perform alternative actions
}}</pre>

This usage ensures that the lock is unlocked if it was acquired, and
doesn't try to unlock if the lock was not acquired.

@return {@code true} if the lock was acquired and
        {@code false} otherwise
"
      end

      operation 9039490 "tryLock"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "time" explicit_type "long"
	  param inout name "unit" type class_ref 935938 // TimeUnit
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock if it is free within the given waiting time and the
current thread has not been {@linkplain Thread#interrupt interrupted}.

<p>If the lock is available this method returns immediately
with the value {@code true}.
If the lock is not available then
the current thread becomes disabled for thread scheduling
purposes and lies dormant until one of three things happens:
<ul>
<li>The lock is acquired by the current thread; or
<li>Some other thread {@linkplain Thread#interrupt interrupts} the
current thread, and interruption of lock acquisition is supported; or
<li>The specified waiting time elapses
</ul>

<p>If the lock is acquired then the value {@code true} is returned.

<p>If the current thread:
<ul>
<li>has its interrupted status set on entry to this method; or
<li>is {@linkplain Thread#interrupt interrupted} while acquiring
the lock, and interruption of lock acquisition is supported,
</ul>
then {@link InterruptedException} is thrown and the current thread's
interrupted status is cleared.

<p>If the specified waiting time elapses then the value {@code false}
is returned.
If the time is
less than or equal to zero, the method will not wait at all.

<p><b>Implementation Considerations</b>

<p>The ability to interrupt a lock acquisition in some implementations
may not be possible, and if possible may
be an expensive operation.
The programmer should be aware that this may be the case. An
implementation should document when this is the case.

<p>An implementation can favor responding to an interrupt over normal
method return, or reporting a timeout.

<p>A {@code Lock} implementation may be able to detect
erroneous use of the lock, such as an invocation that would cause
deadlock, and may throw an (unchecked) exception in such circumstances.
The circumstances and the exception type must be documented by that
{@code Lock} implementation.

@param time the maximum time to wait for the lock
@param unit the time unit of the {@code time} argument
@return {@code true} if the lock was acquired and {@code false}
        if the waiting time elapsed before the lock was acquired

@throws InterruptedException if the current thread is interrupted
        while acquiring the lock (and interruption of lock
        acquisition is supported)
"
      end

      operation 9039618 "unlock"
	public explicit_return_type "void"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Releases the lock.

<p><b>Implementation Considerations</b>

<p>A {@code Lock} implementation will usually impose
restrictions on which thread can release a lock (typically only the
holder of the lock can release it) and may throw
an (unchecked) exception if the restriction is violated.
Any restrictions and the exception
type must be documented by that {@code Lock} implementation.
"
      end

      operation 9039746 "newCondition"
	public return_type class_ref 864770 // Condition
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a new {@link Condition} instance that is bound to this
{@code Lock} instance.

<p>Before waiting on the condition the lock must be held by the
current thread.
A call to {@link Condition#await()} will atomically release the lock
before waiting and re-acquire the lock before the wait returns.

<p><b>Implementation Considerations</b>

<p>The exact operation of the {@link Condition} instance depends on
the {@code Lock} implementation and must be documented by that
implementation.

@return A new {@link Condition} instance for this {@code Lock} instance
@throws UnsupportedOperationException if this {@code Lock}
        implementation does not support conditions
"
      end
    end

    class 864770 "Condition"
      visibility public stereotype "interface"
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "{@code Condition} factors out the {@code Object} monitor
methods ({@link Object#wait() wait}, {@link Object#notify notify}
and {@link Object#notifyAll notifyAll}) into distinct objects to
give the effect of having multiple wait-sets per object, by
combining them with the use of arbitrary {@link Lock} implementations.
Where a {@code Lock} replaces the use of {@code synchronized} methods
and statements, a {@code Condition} replaces the use of the Object
monitor methods.

<p>Conditions (also known as <em>condition queues</em> or
<em>condition variables</em>) provide a means for one thread to
suspend execution (to &quot;wait&quot;) until notified by another
thread that some state condition may now be true.  Because access
to this shared state information occurs in different threads, it
must be protected, so a lock of some form is associated with the
condition. The key property that waiting for a condition provides
is that it <em>atomically</em> releases the associated lock and
suspends the current thread, just like {@code Object.wait}.

<p>A {@code Condition} instance is intrinsically bound to a lock.
To obtain a {@code Condition} instance for a particular {@link Lock}
instance use its {@link Lock#newCondition newCondition()} method.

<p>As an example, suppose we have a bounded buffer which supports
{@code put} and {@code take} methods.  If a
{@code take} is attempted on an empty buffer, then the thread will block
until an item becomes available; if a {@code put} is attempted on a
full buffer, then the thread will block until a space becomes available.
We would like to keep waiting {@code put} threads and {@code take}
threads in separate wait-sets so that we can use the optimization of
only notifying a single thread at a time when items or spaces become
available in the buffer. This can be achieved using two
{@link Condition} instances.
<pre>
class BoundedBuffer {
  <b>final Lock lock = new ReentrantLock();</b>
  final Condition notFull  = <b>lock.newCondition(); </b>
  final Condition notEmpty = <b>lock.newCondition(); </b>

  final Object[] items = new Object[100];
  int putptr, takeptr, count;

  public void put(Object x) throws InterruptedException {
    <b>lock.lock();
    try {</b>
      while (count == items.length)
        <b>notFull.await();</b>
      items[putptr] = x;
      if (++putptr == items.length) putptr = 0;
      ++count;
      <b>notEmpty.signal();</b>
    <b>} finally {
      lock.unlock();
    }</b>
  }

  public Object take() throws InterruptedException {
    <b>lock.lock();
    try {</b>
      while (count == 0)
        <b>notEmpty.await();</b>
      Object x = items[takeptr];
      if (++takeptr == items.length) takeptr = 0;
      --count;
      <b>notFull.signal();</b>
      return x;
    <b>} finally {
      lock.unlock();
    }</b>
  }
}
</pre>

(The {@link java.util.concurrent.ArrayBlockingQueue} class provides
this functionality, so there is no reason to implement this
sample usage class.)

<p>A {@code Condition} implementation can provide behavior and semantics
that is
different from that of the {@code Object} monitor methods, such as
guaranteed ordering for notifications, or not requiring a lock to be held
when performing notifications.
If an implementation provides such specialized semantics then the
implementation must document those semantics.

<p>Note that {@code Condition} instances are just normal objects and can
themselves be used as the target in a {@code synchronized} statement,
and can have their own monitor {@link Object#wait wait} and
{@link Object#notify notification} methods invoked.
Acquiring the monitor lock of a {@code Condition} instance, or using its
monitor methods, has no specified relationship with acquiring the
{@link Lock} associated with that {@code Condition} or the use of its
{@linkplain #await waiting} and {@linkplain #signal signalling} methods.
It is recommended that to avoid confusion you never use {@code Condition}
instances in this way, except perhaps within their own implementation.

<p>Except where noted, passing a {@code null} value for any parameter
will result in a {@link NullPointerException} being thrown.

<h3>Implementation Considerations</h3>

<p>When waiting upon a {@code Condition}, a &quot;<em>spurious
wakeup</em>&quot; is permitted to occur, in
general, as a concession to the underlying platform semantics.
This has little practical impact on most application programs as a
{@code Condition} should always be waited upon in a loop, testing
the state predicate that is being waited for.  An implementation is
free to remove the possibility of spurious wakeups but it is
recommended that applications programmers always assume that they can
occur and so always wait in a loop.

<p>The three forms of condition waiting
(interruptible, non-interruptible, and timed) may differ in their ease of
implementation on some platforms and in their performance characteristics.
In particular, it may be difficult to provide these features and maintain
specific semantics such as ordering guarantees.
Further, the ability to interrupt the actual suspension of the thread may
not always be feasible to implement on all platforms.

<p>Consequently, an implementation is not required to define exactly the
same guarantees or semantics for all three forms of waiting, nor is it
required to support interruption of the actual suspension of the thread.

<p>An implementation is required to
clearly document the semantics and guarantees provided by each of the
waiting methods, and when an implementation does support interruption of
thread suspension then it must obey the interruption semantics as defined
in this interface.

<p>As interruption generally implies cancellation, and checks for
interruption are often infrequent, an implementation can favor responding
to an interrupt over normal method return. This is true even if it can be
shown that the interrupt occurred after another action that may have
unblocked the thread. An implementation should document this behavior.

@since 1.5
@author Doug Lea
"
      operation 9047810 "await"
	public explicit_return_type "void"
	nparams 0
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Causes the current thread to wait until it is signalled or
{@linkplain Thread#interrupt interrupted}.

<p>The lock associated with this {@code Condition} is atomically
released and the current thread becomes disabled for thread scheduling
purposes and lies dormant until <em>one</em> of four things happens:
<ul>
<li>Some other thread invokes the {@link #signal} method for this
{@code Condition} and the current thread happens to be chosen as the
thread to be awakened; or
<li>Some other thread invokes the {@link #signalAll} method for this
{@code Condition}; or
<li>Some other thread {@linkplain Thread#interrupt interrupts} the
current thread, and interruption of thread suspension is supported; or
<li>A &quot;<em>spurious wakeup</em>&quot; occurs.
</ul>

<p>In all cases, before this method can return the current thread must
re-acquire the lock associated with this condition. When the
thread returns it is <em>guaranteed</em> to hold this lock.

<p>If the current thread:
<ul>
<li>has its interrupted status set on entry to this method; or
<li>is {@linkplain Thread#interrupt interrupted} while waiting
and interruption of thread suspension is supported,
</ul>
then {@link InterruptedException} is thrown and the current thread's
interrupted status is cleared. It is not specified, in the first
case, whether or not the test for interruption occurs before the lock
is released.

<p><b>Implementation Considerations</b>

<p>The current thread is assumed to hold the lock associated with this
{@code Condition} when this method is called.
It is up to the implementation to determine if this is
the case and if not, how to respond. Typically, an exception will be
thrown (such as {@link IllegalMonitorStateException}) and the
implementation must document that fact.

<p>An implementation can favor responding to an interrupt over normal
method return in response to a signal. In that case the implementation
must ensure that the signal is redirected to another waiting thread, if
there is one.

@throws InterruptedException if the current thread is interrupted
        (and interruption of thread suspension is supported)
"
      end

      operation 9047938 "awaitUninterruptibly"
	public explicit_return_type "void"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Causes the current thread to wait until it is signalled.

<p>The lock associated with this condition is atomically
released and the current thread becomes disabled for thread scheduling
purposes and lies dormant until <em>one</em> of three things happens:
<ul>
<li>Some other thread invokes the {@link #signal} method for this
{@code Condition} and the current thread happens to be chosen as the
thread to be awakened; or
<li>Some other thread invokes the {@link #signalAll} method for this
{@code Condition}; or
<li>A &quot;<em>spurious wakeup</em>&quot; occurs.
</ul>

<p>In all cases, before this method can return the current thread must
re-acquire the lock associated with this condition. When the
thread returns it is <em>guaranteed</em> to hold this lock.

<p>If the current thread's interrupted status is set when it enters
this method, or it is {@linkplain Thread#interrupt interrupted}
while waiting, it will continue to wait until signalled. When it finally
returns from this method its interrupted status will still
be set.

<p><b>Implementation Considerations</b>

<p>The current thread is assumed to hold the lock associated with this
{@code Condition} when this method is called.
It is up to the implementation to determine if this is
the case and if not, how to respond. Typically, an exception will be
thrown (such as {@link IllegalMonitorStateException}) and the
implementation must document that fact.
"
      end

      operation 9048066 "awaitNanos"
	public explicit_return_type "long"
	nparams 1
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Causes the current thread to wait until it is signalled or interrupted,
or the specified waiting time elapses.

<p>The lock associated with this condition is atomically
released and the current thread becomes disabled for thread scheduling
purposes and lies dormant until <em>one</em> of five things happens:
<ul>
<li>Some other thread invokes the {@link #signal} method for this
{@code Condition} and the current thread happens to be chosen as the
thread to be awakened; or
<li>Some other thread invokes the {@link #signalAll} method for this
{@code Condition}; or
<li>Some other thread {@linkplain Thread#interrupt interrupts} the
current thread, and interruption of thread suspension is supported; or
<li>The specified waiting time elapses; or
<li>A &quot;<em>spurious wakeup</em>&quot; occurs.
</ul>

<p>In all cases, before this method can return the current thread must
re-acquire the lock associated with this condition. When the
thread returns it is <em>guaranteed</em> to hold this lock.

<p>If the current thread:
<ul>
<li>has its interrupted status set on entry to this method; or
<li>is {@linkplain Thread#interrupt interrupted} while waiting
and interruption of thread suspension is supported,
</ul>
then {@link InterruptedException} is thrown and the current thread's
interrupted status is cleared. It is not specified, in the first
case, whether or not the test for interruption occurs before the lock
is released.

<p>The method returns an estimate of the number of nanoseconds
remaining to wait given the supplied {@code nanosTimeout}
value upon return, or a value less than or equal to zero if it
timed out. This value can be used to determine whether and how
long to re-wait in cases where the wait returns but an awaited
condition still does not hold. Typical uses of this method take
the following form:

 <pre> {@code
boolean aMethod(long timeout, TimeUnit unit) {
  long nanos = unit.toNanos(timeout);
  lock.lock();
  try {
    while (!conditionBeingWaitedFor()) {
      if (nanos <= 0L)
        return false;
      nanos = theCondition.awaitNanos(nanos);
    }
    // ...
  } finally {
    lock.unlock();
  }
}}</pre>

<p>Design note: This method requires a nanosecond argument so
as to avoid truncation errors in reporting remaining times.
Such precision loss would make it difficult for programmers to
ensure that total waiting times are not systematically shorter
than specified when re-waits occur.

<p><b>Implementation Considerations</b>

<p>The current thread is assumed to hold the lock associated with this
{@code Condition} when this method is called.
It is up to the implementation to determine if this is
the case and if not, how to respond. Typically, an exception will be
thrown (such as {@link IllegalMonitorStateException}) and the
implementation must document that fact.

<p>An implementation can favor responding to an interrupt over normal
method return in response to a signal, or over indicating the elapse
of the specified waiting time. In either case the implementation
must ensure that the signal is redirected to another waiting thread, if
there is one.

@param nanosTimeout the maximum time to wait, in nanoseconds
@return an estimate of the {@code nanosTimeout} value minus
        the time spent waiting upon return from this method.
        A positive value may be used as the argument to a
        subsequent call to this method to finish waiting out
        the desired time.  A value less than or equal to zero
        indicates that no time remains.
@throws InterruptedException if the current thread is interrupted
        (and interruption of thread suspension is supported)
"
      end

      operation 9048194 "await"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "time" explicit_type "long"
	  param inout name "unit" type class_ref 935938 // TimeUnit
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Causes the current thread to wait until it is signalled or interrupted,
or the specified waiting time elapses. This method is behaviorally
equivalent to:
 <pre> {@code awaitNanos(unit.toNanos(time)) > 0}</pre>

@param time the maximum time to wait
@param unit the time unit of the {@code time} argument
@return {@code false} if the waiting time detectably elapsed
        before return from the method, else {@code true}
@throws InterruptedException if the current thread is interrupted
        (and interruption of thread suspension is supported)
"
      end

      operation 9048322 "awaitUntil"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "deadline" type class_ref 521474 // Date
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Causes the current thread to wait until it is signalled or interrupted,
or the specified deadline elapses.

<p>The lock associated with this condition is atomically
released and the current thread becomes disabled for thread scheduling
purposes and lies dormant until <em>one</em> of five things happens:
<ul>
<li>Some other thread invokes the {@link #signal} method for this
{@code Condition} and the current thread happens to be chosen as the
thread to be awakened; or
<li>Some other thread invokes the {@link #signalAll} method for this
{@code Condition}; or
<li>Some other thread {@linkplain Thread#interrupt interrupts} the
current thread, and interruption of thread suspension is supported; or
<li>The specified deadline elapses; or
<li>A &quot;<em>spurious wakeup</em>&quot; occurs.
</ul>

<p>In all cases, before this method can return the current thread must
re-acquire the lock associated with this condition. When the
thread returns it is <em>guaranteed</em> to hold this lock.


<p>If the current thread:
<ul>
<li>has its interrupted status set on entry to this method; or
<li>is {@linkplain Thread#interrupt interrupted} while waiting
and interruption of thread suspension is supported,
</ul>
then {@link InterruptedException} is thrown and the current thread's
interrupted status is cleared. It is not specified, in the first
case, whether or not the test for interruption occurs before the lock
is released.


<p>The return value indicates whether the deadline has elapsed,
which can be used as follows:
 <pre> {@code
boolean aMethod(Date deadline) {
  boolean stillWaiting = true;
  lock.lock();
  try {
    while (!conditionBeingWaitedFor()) {
      if (!stillWaiting)
        return false;
      stillWaiting = theCondition.awaitUntil(deadline);
    }
    // ...
  } finally {
    lock.unlock();
  }
}}</pre>

<p><b>Implementation Considerations</b>

<p>The current thread is assumed to hold the lock associated with this
{@code Condition} when this method is called.
It is up to the implementation to determine if this is
the case and if not, how to respond. Typically, an exception will be
thrown (such as {@link IllegalMonitorStateException}) and the
implementation must document that fact.

<p>An implementation can favor responding to an interrupt over normal
method return in response to a signal, or over indicating the passing
of the specified deadline. In either case the implementation
must ensure that the signal is redirected to another waiting thread, if
there is one.

@param deadline the absolute time to wait until
@return {@code false} if the deadline has elapsed upon return, else
        {@code true}
@throws InterruptedException if the current thread is interrupted
        (and interruption of thread suspension is supported)
"
      end

      operation 9048450 "signal"
	public explicit_return_type "void"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Wakes up one waiting thread.

<p>If any threads are waiting on this condition then one
is selected for waking up. That thread must then re-acquire the
lock before returning from {@code await}.

<p><b>Implementation Considerations</b>

<p>An implementation may (and typically does) require that the
current thread hold the lock associated with this {@code
Condition} when this method is called. Implementations must
document this precondition and any actions taken if the lock is
not held. Typically, an exception such as {@link
IllegalMonitorStateException} will be thrown.
"
      end

      operation 9048578 "signalAll"
	public explicit_return_type "void"
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Wakes up all waiting threads.

<p>If any threads are waiting on this condition then they are
all woken up. Each thread must re-acquire the lock before it can
return from {@code await}.

<p><b>Implementation Considerations</b>

<p>An implementation may (and typically does) require that the
current thread hold the lock associated with this {@code
Condition} when this method is called. Implementations must
document this precondition and any actions taken if the lock is
not held. Typically, an exception such as {@link
IllegalMonitorStateException} will be thrown.
"
      end
    end

    class 968706 "ReentrantLock"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A reentrant mutual exclusion {@link Lock} with the same basic
behavior and semantics as the implicit monitor lock accessed using
{@code synchronized} methods and statements, but with extended
capabilities.

<p>A {@code ReentrantLock} is <em>owned</em> by the thread last
successfully locking, but not yet unlocking it. A thread invoking
{@code lock} will return, successfully acquiring the lock, when
the lock is not owned by another thread. The method will return
immediately if the current thread already owns the lock. This can
be checked using methods {@link #isHeldByCurrentThread}, and {@link
#getHoldCount}.

<p>The constructor for this class accepts an optional
<em>fairness</em> parameter.  When set {@code true}, under
contention, locks favor granting access to the longest-waiting
thread.  Otherwise this lock does not guarantee any particular
access order.  Programs using fair locks accessed by many threads
may display lower overall throughput (i.e., are slower; often much
slower) than those using the default setting, but have smaller
variances in times to obtain locks and guarantee lack of
starvation. Note however, that fairness of locks does not guarantee
fairness of thread scheduling. Thus, one of many threads using a
fair lock may obtain it multiple times in succession while other
active threads are not progressing and not currently holding the
lock.
Also note that the untimed {@link #tryLock()} method does not
honor the fairness setting. It will succeed if the lock
is available even if other threads are waiting.

<p>It is recommended practice to <em>always</em> immediately
follow a call to {@code lock} with a {@code try} block, most
typically in a before/after construction such as:

 <pre> {@code
class X {
  private final ReentrantLock lock = new ReentrantLock();
  // ...

  public void m() {
    lock.lock();  // block until condition holds
    try {
      // ... method body
    } finally {
      lock.unlock()
    }
  }
}}</pre>

<p>In addition to implementing the {@link Lock} interface, this
class defines a number of {@code public} and {@code protected}
methods for inspecting the state of the lock.  Some of these
methods are only useful for instrumentation and monitoring.

<p>Serialization of this class behaves in the same way as built-in
locks: a deserialized lock is in the unlocked state, regardless of
its state when serialized.

<p>This lock supports a maximum of 2147483647 recursive locks by
the same thread. Attempts to exceed this limit result in
{@link Error} throws from locking methods.

@since 1.5
@author Doug Lea
"
      classrelation 3574914 // <realization>
	relation 3574914 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3574914 // <realization>
	  b parent class_ref 864642 // Lock
      end

      classrelation 3575042 // <realization>
	relation 3575042 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3575042 // <realization>
	  b parent class_ref 136578 // Serializable
      end

      attribute 2108290 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 7373984872572414699L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      class 1105922 "Sync"
	abstract visibility package 
	cpp_decl ""
	static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3577346 // <generalisation>
	  relation 3577346 ---|>
	    a public
	      java "${type}"
	      classrelation_ref 3577346 // <generalisation>
	    b parent class_ref 1106050 // AbstractQueuedSynchronizer
	end

	attribute 2110722 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " -5179523762034025860L"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	operation 9051522 "lock"
	  abstract package explicit_return_type "void"
	  nparams 0
	  
	  java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Performs {@link Lock#lock}. The main reason for subclassing
is to allow fast path for nonfair version.
"
	end

	operation 9051650 "nonfairTryAcquire"
	  package explicit_return_type "boolean"
	  nparams 1
	    param in name "acquires" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Performs non-fair tryLock.  tryAcquire is implemented in
subclasses, but both need nonfair try for trylock method.
"
	end

	operation 9051778 "tryRelease"
	  protected explicit_return_type "boolean"
	  nparams 1
	    param in name "releases" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9051906 "isHeldExclusively"
	  protected explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9052034 "newCondition"
	  package return_type class_ref 1106434 // ConditionObject
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9052162 "getOwner"
	  package return_type class_ref 128642 // Thread
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " Methods relayed from outer class"
	end

	operation 9052290 "getHoldCount"
	  package explicit_return_type "int"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9052418 "isLocked"
	  package explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9052546 "readObject"
	  private explicit_return_type "void"
	  nparams 1
	    param inout name "s" type class_ref 168962 // ObjectInputStream
	  nexceptions 2
	    exception class_ref 146818 // IOException
	    exception class_ref 169730 // ClassNotFoundException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Reconstitutes the instance from a stream (that is, deserializes it).
"
	end
      end

      classrelation 3575170 // sync (<unidirectional association>)
	relation 3575170 --->
	  a role_name "sync" const_relation private
	    comment " Synchronizer providing all implementation mechanics 
"
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 3575170 // sync (<unidirectional association>)
	  b parent class_ref 1105922 // Sync
      end

      class 1106562 "NonfairSync"
	visibility package 
	cpp_decl ""
	final static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3577474 // <generalisation>
	  relation 3577474 ---|>
	    a public
	      java "${type}"
	      classrelation_ref 3577474 // <generalisation>
	    b parent class_ref 1105922 // Sync
	end

	attribute 2110850 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " 7316153563782823691L"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	operation 9052674 "lock"
	  package explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Performs lock.  Try immediate barge, backing up to normal
acquire on failure.
"
	end

	operation 9052802 "tryAcquire"
	  protected explicit_return_type "boolean"
	  nparams 1
	    param in name "acquires" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      class 1106690 "FairSync"
	visibility package 
	cpp_decl ""
	final static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3577602 // <generalisation>
	  relation 3577602 ---|>
	    a public
	      java "${type}"
	      classrelation_ref 3577602 // <generalisation>
	    b parent class_ref 1105922 // Sync
	end

	attribute 2110978 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " -3000897897090466540L"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	operation 9052930 "lock"
	  package explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9053058 "tryAcquire"
	  protected explicit_return_type "boolean"
	  nparams 1
	    param in name "acquires" explicit_type "int"
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Fair version of tryAcquire.  Don't grant access unless
recursive call or no waiters or is first.
"
	end
      end

      operation 9053186 "ReentrantLock"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates an instance of {@code ReentrantLock}.
This is equivalent to using {@code ReentrantLock(false)}.
"
      end

      operation 9053314 "ReentrantLock"
	public explicit_return_type ""
	nparams 1
	  param inout name "fair" explicit_type "boolean"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates an instance of {@code ReentrantLock} with the
given fairness policy.

@param fair {@code true} if this lock should use a fair ordering policy
"
      end

      operation 9053442 "lock"
	public explicit_return_type "void"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock.

<p>Acquires the lock if it is not held by another thread and returns
immediately, setting the lock hold count to one.

<p>If the current thread already holds the lock then the hold
count is incremented by one and the method returns immediately.

<p>If the lock is held by another thread then the
current thread becomes disabled for thread scheduling
purposes and lies dormant until the lock has been acquired,
at which time the lock hold count is set to one.
"
      end

      operation 9053570 "lockInterruptibly"
	public explicit_return_type "void"
	nparams 0
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock unless the current thread is
{@linkplain Thread#interrupt interrupted}.

<p>Acquires the lock if it is not held by another thread and returns
immediately, setting the lock hold count to one.

<p>If the current thread already holds this lock then the hold count
is incremented by one and the method returns immediately.

<p>If the lock is held by another thread then the
current thread becomes disabled for thread scheduling
purposes and lies dormant until one of two things happens:

<ul>

<li>The lock is acquired by the current thread; or

<li>Some other thread {@linkplain Thread#interrupt interrupts} the
current thread.

</ul>

<p>If the lock is acquired by the current thread then the lock hold
count is set to one.

<p>If the current thread:

<ul>

<li>has its interrupted status set on entry to this method; or

<li>is {@linkplain Thread#interrupt interrupted} while acquiring
the lock,

</ul>

then {@link InterruptedException} is thrown and the current thread's
interrupted status is cleared.

<p>In this implementation, as this method is an explicit
interruption point, preference is given to responding to the
interrupt over normal or reentrant acquisition of the lock.

@throws InterruptedException if the current thread is interrupted
"
      end

      operation 9053698 "tryLock"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock only if it is not held by another thread at the time
of invocation.

<p>Acquires the lock if it is not held by another thread and
returns immediately with the value {@code true}, setting the
lock hold count to one. Even when this lock has been set to use a
fair ordering policy, a call to {@code tryLock()} <em>will</em>
immediately acquire the lock if it is available, whether or not
other threads are currently waiting for the lock.
This &quot;barging&quot; behavior can be useful in certain
circumstances, even though it breaks fairness. If you want to honor
the fairness setting for this lock, then use
{@link #tryLock(long, TimeUnit) tryLock(0, TimeUnit.SECONDS) }
which is almost equivalent (it also detects interruption).

<p>If the current thread already holds this lock then the hold
count is incremented by one and the method returns {@code true}.

<p>If the lock is held by another thread then this method will return
immediately with the value {@code false}.

@return {@code true} if the lock was free and was acquired by the
        current thread, or the lock was already held by the current
        thread; and {@code false} otherwise
"
      end

      operation 9053826 "tryLock"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "timeout" explicit_type "long"
	  param inout name "unit" type class_ref 935938 // TimeUnit
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires the lock if it is not held by another thread within the given
waiting time and the current thread has not been
{@linkplain Thread#interrupt interrupted}.

<p>Acquires the lock if it is not held by another thread and returns
immediately with the value {@code true}, setting the lock hold count
to one. If this lock has been set to use a fair ordering policy then
an available lock <em>will not</em> be acquired if any other threads
are waiting for the lock. This is in contrast to the {@link #tryLock()}
method. If you want a timed {@code tryLock} that does permit barging on
a fair lock then combine the timed and un-timed forms together:

 <pre> {@code
if (lock.tryLock() ||
    lock.tryLock(timeout, unit)) {
  ...
}}</pre>

<p>If the current thread
already holds this lock then the hold count is incremented by one and
the method returns {@code true}.

<p>If the lock is held by another thread then the
current thread becomes disabled for thread scheduling
purposes and lies dormant until one of three things happens:

<ul>

<li>The lock is acquired by the current thread; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread; or

<li>The specified waiting time elapses

</ul>

<p>If the lock is acquired then the value {@code true} is returned and
the lock hold count is set to one.

<p>If the current thread:

<ul>

<li>has its interrupted status set on entry to this method; or

<li>is {@linkplain Thread#interrupt interrupted} while
acquiring the lock,

</ul>
then {@link InterruptedException} is thrown and the current thread's
interrupted status is cleared.

<p>If the specified waiting time elapses then the value {@code false}
is returned.  If the time is less than or equal to zero, the method
will not wait at all.

<p>In this implementation, as this method is an explicit
interruption point, preference is given to responding to the
interrupt over normal or reentrant acquisition of the lock, and
over reporting the elapse of the waiting time.

@param timeout the time to wait for the lock
@param unit the time unit of the timeout argument
@return {@code true} if the lock was free and was acquired by the
        current thread, or the lock was already held by the current
        thread; and {@code false} if the waiting time elapsed before
        the lock could be acquired
@throws InterruptedException if the current thread is interrupted
@throws NullPointerException if the time unit is null
"
      end

      operation 9053954 "unlock"
	public explicit_return_type "void"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to release this lock.

<p>If the current thread is the holder of this lock then the hold
count is decremented.  If the hold count is now zero then the lock
is released.  If the current thread is not the holder of this
lock then {@link IllegalMonitorStateException} is thrown.

@throws IllegalMonitorStateException if the current thread does not
        hold this lock
"
      end

      operation 9054082 "newCondition"
	public return_type class_ref 864770 // Condition
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a {@link Condition} instance for use with this
{@link Lock} instance.

<p>The returned {@link Condition} instance supports the same
usages as do the {@link Object} monitor methods ({@link
Object#wait() wait}, {@link Object#notify notify}, and {@link
Object#notifyAll notifyAll}) when used with the built-in
monitor lock.

<ul>

<li>If this lock is not held when any of the {@link Condition}
{@linkplain Condition#await() waiting} or {@linkplain
Condition#signal signalling} methods are called, then an {@link
IllegalMonitorStateException} is thrown.

<li>When the condition {@linkplain Condition#await() waiting}
methods are called the lock is released and, before they
return, the lock is reacquired and the lock hold count restored
to what it was when the method was called.

<li>If a thread is {@linkplain Thread#interrupt interrupted}
while waiting then the wait will terminate, an {@link
InterruptedException} will be thrown, and the thread's
interrupted status will be cleared.

<li> Waiting threads are signalled in FIFO order.

<li>The ordering of lock reacquisition for threads returning
from waiting methods is the same as for threads initially
acquiring the lock, which is in the default case not specified,
but for <em>fair</em> locks favors those threads that have been
waiting the longest.

</ul>

@return the Condition object
"
      end

      operation 9054210 "getHoldCount"
	public explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries the number of holds on this lock by the current thread.

<p>A thread has a hold on a lock for each lock action that is not
matched by an unlock action.

<p>The hold count information is typically only used for testing and
debugging purposes. For example, if a certain section of code should
not be entered with the lock already held then we can assert that
fact:

 <pre> {@code
class X {
  ReentrantLock lock = new ReentrantLock();
  // ...
  public void m() {
    assert lock.getHoldCount() == 0;
    lock.lock();
    try {
      // ... method body
    } finally {
      lock.unlock();
    }
  }
}}</pre>

@return the number of holds on this lock by the current thread,
        or zero if this lock is not held by the current thread
"
      end

      operation 9054338 "isHeldByCurrentThread"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries if this lock is held by the current thread.

<p>Analogous to the {@link Thread#holdsLock(Object)} method for
built-in monitor locks, this method is typically used for
debugging and testing. For example, a method that should only be
called while a lock is held can assert that this is the case:

 <pre> {@code
class X {
  ReentrantLock lock = new ReentrantLock();
  // ...

  public void m() {
      assert lock.isHeldByCurrentThread();
      // ... method body
  }
}}</pre>

<p>It can also be used to ensure that a reentrant lock is used
in a non-reentrant manner, for example:

 <pre> {@code
class X {
  ReentrantLock lock = new ReentrantLock();
  // ...

  public void m() {
      assert !lock.isHeldByCurrentThread();
      lock.lock();
      try {
          // ... method body
      } finally {
          lock.unlock();
      }
  }
}}</pre>

@return {@code true} if current thread holds this lock and
        {@code false} otherwise
"
      end

      operation 9054466 "isLocked"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries if this lock is held by any thread. This method is
designed for use in monitoring of the system state,
not for synchronization control.

@return {@code true} if any thread holds this lock and
        {@code false} otherwise
"
      end

      operation 9054594 "isFair"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns {@code true} if this lock has fairness set true.

@return {@code true} if this lock has fairness set true
"
      end

      operation 9054722 "getOwner"
	protected return_type class_ref 128642 // Thread
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the thread that currently owns this lock, or
{@code null} if not owned. When this method is called by a
thread that is not the owner, the return value reflects a
best-effort approximation of current lock status. For example,
the owner may be momentarily {@code null} even if there are
threads trying to acquire the lock but have not yet done so.
This method is designed to facilitate construction of
subclasses that provide more extensive lock monitoring
facilities.

@return the owner, or {@code null} if not owned
"
      end

      operation 9054850 "hasQueuedThreads"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads are waiting to acquire this lock. Note that
because cancellations may occur at any time, a {@code true}
return does not guarantee that any other thread will ever
acquire this lock.  This method is designed primarily for use in
monitoring of the system state.

@return {@code true} if there may be other threads waiting to
        acquire the lock
"
      end

      operation 9054978 "hasQueuedThread"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "thread" type class_ref 128642 // Thread
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether the given thread is waiting to acquire this
lock. Note that because cancellations may occur at any time, a
{@code true} return does not guarantee that this thread
will ever acquire this lock.  This method is designed primarily for use
in monitoring of the system state.

@param thread the thread
@return {@code true} if the given thread is queued waiting for this lock
@throws NullPointerException if the thread is null
"
      end

      operation 9055106 "getQueueLength"
	public explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an estimate of the number of threads waiting to
acquire this lock.  The value is only an estimate because the number of
threads may change dynamically while this method traverses
internal data structures.  This method is designed for use in
monitoring of the system state, not for synchronization
control.

@return the estimated number of threads waiting for this lock
"
      end

      operation 9055234 "getQueuedThreads"
	protected return_type class_ref 184194 // Collection
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire this lock.  Because the actual set of threads may change
dynamically while constructing this result, the returned
collection is only a best-effort estimate.  The elements of the
returned collection are in no particular order.  This method is
designed to facilitate construction of subclasses that provide
more extensive monitoring facilities.

@return the collection of threads
"
      end

      operation 9055362 "hasWaiters"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "condition" type class_ref 864770 // Condition
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads are waiting on the given condition
associated with this lock. Note that because timeouts and
interrupts may occur at any time, a {@code true} return does
not guarantee that a future {@code signal} will awaken any
threads.  This method is designed primarily for use in
monitoring of the system state.

@param condition the condition
@return {@code true} if there are any waiting threads
@throws IllegalMonitorStateException if this lock is not held
@throws IllegalArgumentException if the given condition is
        not associated with this lock
@throws NullPointerException if the condition is null
"
      end

      operation 9055490 "getWaitQueueLength"
	public explicit_return_type "int"
	nparams 1
	  param inout name "condition" type class_ref 864770 // Condition
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an estimate of the number of threads waiting on the
given condition associated with this lock. Note that because
timeouts and interrupts may occur at any time, the estimate
serves only as an upper bound on the actual number of waiters.
This method is designed for use in monitoring of the system
state, not for synchronization control.

@param condition the condition
@return the estimated number of waiting threads
@throws IllegalMonitorStateException if this lock is not held
@throws IllegalArgumentException if the given condition is
        not associated with this lock
@throws NullPointerException if the condition is null
"
      end

      operation 9055618 "getWaitingThreads"
	protected return_type class_ref 184194 // Collection
	nparams 1
	  param inout name "condition" type class_ref 864770 // Condition
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing those threads that may be
waiting on the given condition associated with this lock.
Because the actual set of threads may change dynamically while
constructing this result, the returned collection is only a
best-effort estimate. The elements of the returned collection
are in no particular order.  This method is designed to
facilitate construction of subclasses that provide more
extensive condition monitoring facilities.

@param condition the condition
@return the collection of threads
@throws IllegalMonitorStateException if this lock is not held
@throws IllegalArgumentException if the given condition is
        not associated with this lock
@throws NullPointerException if the condition is null
"
      end

      operation 9055746 "toString"
	public return_type class_ref 128130 // String
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a string identifying this lock, as well as its lock state.
The state, in brackets, includes either the String {@code \"Unlocked\"}
or the String {@code \"Locked by\"} followed by the
{@linkplain Thread#getName name} of the owning thread.

@return a string identifying this lock, as well as its lock state
"
      end
    end

    class 1106050 "AbstractQueuedSynchronizer"
      abstract visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Provides a framework for implementing blocking locks and related
synchronizers (semaphores, events, etc) that rely on
first-in-first-out (FIFO) wait queues.  This class is designed to
be a useful basis for most kinds of synchronizers that rely on a
single atomic {@code int} value to represent state. Subclasses
must define the protected methods that change this state, and which
define what that state means in terms of this object being acquired
or released.  Given these, the other methods in this class carry
out all queuing and blocking mechanics. Subclasses can maintain
other state fields, but only the atomically updated {@code int}
value manipulated using methods {@link #getState}, {@link
#setState} and {@link #compareAndSetState} is tracked with respect
to synchronization.

<p>Subclasses should be defined as non-public internal helper
classes that are used to implement the synchronization properties
of their enclosing class.  Class
{@code AbstractQueuedSynchronizer} does not implement any
synchronization interface.  Instead it defines methods such as
{@link #acquireInterruptibly} that can be invoked as
appropriate by concrete locks and related synchronizers to
implement their public methods.

<p>This class supports either or both a default <em>exclusive</em>
mode and a <em>shared</em> mode. When acquired in exclusive mode,
attempted acquires by other threads cannot succeed. Shared mode
acquires by multiple threads may (but need not) succeed. This class
does not &quot;understand&quot; these differences except in the
mechanical sense that when a shared mode acquire succeeds, the next
waiting thread (if one exists) must also determine whether it can
acquire as well. Threads waiting in the different modes share the
same FIFO queue. Usually, implementation subclasses support only
one of these modes, but both can come into play for example in a
{@link ReadWriteLock}. Subclasses that support only exclusive or
only shared modes need not define the methods supporting the unused mode.

<p>This class defines a nested {@link ConditionObject} class that
can be used as a {@link Condition} implementation by subclasses
supporting exclusive mode for which method {@link
#isHeldExclusively} reports whether synchronization is exclusively
held with respect to the current thread, method {@link #release}
invoked with the current {@link #getState} value fully releases
this object, and {@link #acquire}, given this saved state value,
eventually restores this object to its previous acquired state.  No
{@code AbstractQueuedSynchronizer} method otherwise creates such a
condition, so if this constraint cannot be met, do not use it.  The
behavior of {@link ConditionObject} depends of course on the
semantics of its synchronizer implementation.

<p>This class provides inspection, instrumentation, and monitoring
methods for the internal queue, as well as similar methods for
condition objects. These can be exported as desired into classes
using an {@code AbstractQueuedSynchronizer} for their
synchronization mechanics.

<p>Serialization of this class stores only the underlying atomic
integer maintaining state, so deserialized objects have empty
thread queues. Typical subclasses requiring serializability will
define a {@code readObject} method that restores this to a known
initial state upon deserialization.

<h3>Usage</h3>

<p>To use this class as the basis of a synchronizer, redefine the
following methods, as applicable, by inspecting and/or modifying
the synchronization state using {@link #getState}, {@link
#setState} and/or {@link #compareAndSetState}:

<ul>
<li> {@link #tryAcquire}
<li> {@link #tryRelease}
<li> {@link #tryAcquireShared}
<li> {@link #tryReleaseShared}
<li> {@link #isHeldExclusively}
</ul>

Each of these methods by default throws {@link
UnsupportedOperationException}.  Implementations of these methods
must be internally thread-safe, and should in general be short and
not block. Defining these methods is the <em>only</em> supported
means of using this class. All other methods are declared
{@code final} because they cannot be independently varied.

<p>You may also find the inherited methods from {@link
AbstractOwnableSynchronizer} useful to keep track of the thread
owning an exclusive synchronizer.  You are encouraged to use them
-- this enables monitoring and diagnostic tools to assist users in
determining which threads hold locks.

<p>Even though this class is based on an internal FIFO queue, it
does not automatically enforce FIFO acquisition policies.  The core
of exclusive synchronization takes the form:

<pre>
Acquire:
    while (!tryAcquire(arg)) {
       <em>enqueue thread if it is not already queued</em>;
       <em>possibly block current thread</em>;
    }

Release:
    if (tryRelease(arg))
       <em>unblock the first queued thread</em>;
</pre>

(Shared mode is similar but may involve cascading signals.)

<p id=\"barging\">Because checks in acquire are invoked before
enqueuing, a newly acquiring thread may <em>barge</em> ahead of
others that are blocked and queued.  However, you can, if desired,
define {@code tryAcquire} and/or {@code tryAcquireShared} to
disable barging by internally invoking one or more of the inspection
methods, thereby providing a <em>fair</em> FIFO acquisition order.
In particular, most fair synchronizers can define {@code tryAcquire}
to return {@code false} if {@link #hasQueuedPredecessors} (a method
specifically designed to be used by fair synchronizers) returns
{@code true}.  Other variations are possible.

<p>Throughput and scalability are generally highest for the
default barging (also known as <em>greedy</em>,
<em>renouncement</em>, and <em>convoy-avoidance</em>) strategy.
While this is not guaranteed to be fair or starvation-free, earlier
queued threads are allowed to recontend before later queued
threads, and each recontention has an unbiased chance to succeed
against incoming threads.  Also, while acquires do not
&quot;spin&quot; in the usual sense, they may perform multiple
invocations of {@code tryAcquire} interspersed with other
computations before blocking.  This gives most of the benefits of
spins when exclusive synchronization is only briefly held, without
most of the liabilities when it isn't. If so desired, you can
augment this by preceding calls to acquire methods with
\"fast-path\" checks, possibly prechecking {@link #hasContended}
and/or {@link #hasQueuedThreads} to only do so if the synchronizer
is likely not to be contended.

<p>This class provides an efficient and scalable basis for
synchronization in part by specializing its range of use to
synchronizers that can rely on {@code int} state, acquire, and
release parameters, and an internal FIFO wait queue. When this does
not suffice, you can build synchronizers from a lower level using
{@link java.util.concurrent.atomic atomic} classes, your own custom
{@link java.util.Queue} classes, and {@link LockSupport} blocking
support.

<h3>Usage Examples</h3>

<p>Here is a non-reentrant mutual exclusion lock class that uses
the value zero to represent the unlocked state, and one to
represent the locked state. While a non-reentrant lock
does not strictly require recording of the current owner
thread, this class does so anyway to make usage easier to monitor.
It also supports conditions and exposes
one of the instrumentation methods:

 <pre> {@code
class Mutex implements Lock, java.io.Serializable {

  // Our internal helper class
  private static class Sync extends AbstractQueuedSynchronizer {
    // Reports whether in locked state
    protected boolean isHeldExclusively() {
      return getState() == 1;
    }

    // Acquires the lock if state is zero
    public boolean tryAcquire(int acquires) {
      assert acquires == 1; // Otherwise unused
      if (compareAndSetState(0, 1)) {
        setExclusiveOwnerThread(Thread.currentThread());
        return true;
      }
      return false;
    }

    // Releases the lock by setting state to zero
    protected boolean tryRelease(int releases) {
      assert releases == 1; // Otherwise unused
      if (getState() == 0) throw new IllegalMonitorStateException();
      setExclusiveOwnerThread(null);
      setState(0);
      return true;
    }

    // Provides a Condition
    Condition newCondition() { return new ConditionObject(); }

    // Deserializes properly
    private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException {
      s.defaultReadObject();
      setState(0); // reset to unlocked state
    }
  }

  // The sync object does all the hard work. We just forward to it.
  private final Sync sync = new Sync();

  public void lock()                { sync.acquire(1); }
  public boolean tryLock()          { return sync.tryAcquire(1); }
  public void unlock()              { sync.release(1); }
  public Condition newCondition()   { return sync.newCondition(); }
  public boolean isLocked()         { return sync.isHeldExclusively(); }
  public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }
  public void lockInterruptibly() throws InterruptedException {
    sync.acquireInterruptibly(1);
  }
  public boolean tryLock(long timeout, TimeUnit unit)
      throws InterruptedException {
    return sync.tryAcquireNanos(1, unit.toNanos(timeout));
  }
}}</pre>

<p>Here is a latch class that is like a
{@link java.util.concurrent.CountDownLatch CountDownLatch}
except that it only requires a single {@code signal} to
fire. Because a latch is non-exclusive, it uses the {@code shared}
acquire and release methods.

 <pre> {@code
class BooleanLatch {

  private static class Sync extends AbstractQueuedSynchronizer {
    boolean isSignalled() { return getState() != 0; }

    protected int tryAcquireShared(int ignore) {
      return isSignalled() ? 1 : -1;
    }

    protected boolean tryReleaseShared(int ignore) {
      setState(1);
      return true;
    }
  }

  private final Sync sync = new Sync();
  public boolean isSignalled() { return sync.isSignalled(); }
  public void signal()         { sync.releaseShared(1); }
  public void await() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
  }
}}</pre>

@since 1.5
@author Doug Lea
"
      classrelation 3575554 // <generalisation>
	relation 3575554 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3575554 // <generalisation>
	  b parent class_ref 1106178 // AbstractOwnableSynchronizer
      end

      classrelation 3575682 // <realization>
	relation 3575682 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3575682 // <realization>
	  b parent class_ref 136578 // Serializable
      end

      attribute 2108546 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 7373984972572414691L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 9040258 "AbstractQueuedSynchronizer"
	protected explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates a new {@code AbstractQueuedSynchronizer} instance
with initial synchronization state of zero.
"
      end

      class 1106306 "Node"
	visibility package 
	cpp_decl ""
	final static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3575810 // SHARED (<unidirectional association>)
	  relation 3575810 --->
	    a role_name "SHARED" init_value " new Node()" class_relation const_relation package
	      comment " Marker to indicate a node is waiting in shared mode 
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3575810 // SHARED (<unidirectional association>)
	    b parent class_ref 1106306 // Node
	end

	classrelation 3575938 // EXCLUSIVE (<unidirectional association>)
	  relation 3575938 --->
	    a role_name "EXCLUSIVE" init_value " null" class_relation const_relation package
	      comment " Marker to indicate a node is waiting in exclusive mode 
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3575938 // EXCLUSIVE (<unidirectional association>)
	    b parent class_ref 1106306 // Node
	end

	attribute 2108674 "CANCELLED"
	  class_attribute const_attribute package explicit_type "int"
	  init_value "  1"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment " waitStatus value to indicate thread has cancelled 
"
	end

	attribute 2108802 "SIGNAL"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " -1"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment " waitStatus value to indicate successor's thread needs unparking 
"
	end

	attribute 2108930 "CONDITION"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " -2"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment " waitStatus value to indicate thread is waiting on condition 
"
	end

	attribute 2109058 "PROPAGATE"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " -3"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment "waitStatus value to indicate the next acquireShared should
unconditionally propagate

"
	end

	attribute 2109186 "waitStatus"
	  volatile package explicit_type "int"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment "Status field, taking on only the values:
  SIGNAL:     The successor of this node is (or will soon be)
              blocked (via park), so the current node must
              unpark its successor when it releases or
              cancels. To avoid races, acquire methods must
              first indicate they need a signal,
              then retry the atomic acquire, and then,
              on failure, block.
  CANCELLED:  This node is cancelled due to timeout or interrupt.
              Nodes never leave this state. In particular,
              a thread with cancelled node never again blocks.
  CONDITION:  This node is currently on a condition queue.
              It will not be used as a sync queue node
              until transferred, at which time the status
              will be set to 0. (Use of this value here has
              nothing to do with the other uses of the
              field, but simplifies mechanics.)
  PROPAGATE:  A releaseShared should be propagated to other
              nodes. This is set (for head node only) in
              doReleaseShared to ensure propagation
              continues, even if other operations have
              since intervened.
  0:          None of the above

The values are arranged numerically to simplify use.
Non-negative values mean that a node doesn't need to
signal. So, most code doesn't need to check for particular
values, just for sign.

The field is initialized to 0 for normal sync nodes, and
CONDITION for condition nodes.  It is modified using CAS
(or when possible, unconditional volatile writes).

"
	end

	classrelation 3576066 // prev (<unidirectional association>)
	  relation 3576066 --->
	    a role_name "prev" volatile package
	      comment "
Link to predecessor node that current node/thread relies on
for checking waitStatus. Assigned during enqueuing, and nulled
out (for sake of GC) only upon dequeuing.  Also, upon
cancellation of a predecessor, we short-circuit while
finding a non-cancelled one, which will always exist
because the head node is never cancelled: A node becomes
head only as a result of successful acquire. A
cancelled thread never succeeds in acquiring, and a thread only
cancels itself, not any other node.

"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3576066 // prev (<unidirectional association>)
	    b parent class_ref 1106306 // Node
	end

	classrelation 3576194 // next (<unidirectional association>)
	  relation 3576194 --->
	    a role_name "next" volatile package
	      comment "
Link to the successor node that the current node/thread
unparks upon release. Assigned during enqueuing, adjusted
when bypassing cancelled predecessors, and nulled out (for
sake of GC) when dequeued.  The enq operation does not
assign next field of a predecessor until after attachment,
so seeing a null next field does not necessarily mean that
node is at end of queue. However, if a next field appears
to be null, we can scan prev's from the tail to
double-check.  The next field of cancelled nodes is set to
point to the node itself instead of null, to make life
easier for isOnSyncQueue.

"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3576194 // next (<unidirectional association>)
	    b parent class_ref 1106306 // Node
	end

	classrelation 3576322 // thread (<unidirectional association>)
	  relation 3576322 --->
	    a role_name "thread" volatile package
	      comment "
The thread that enqueued this node.  Initialized on
construction and nulled out after use.

"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3576322 // thread (<unidirectional association>)
	    b parent class_ref 128642 // Thread
	end

	classrelation 3576450 // nextWaiter (<unidirectional association>)
	  relation 3576450 --->
	    a role_name "nextWaiter" package
	      comment "
Link to next node waiting on condition, or the special
value SHARED.  Because condition queues are accessed only
when holding in exclusive mode, we just need a simple
linked queue to hold nodes while they are waiting on
conditions. They are then transferred to the queue to
re-acquire. And because conditions can only be exclusive,
we save a field by using special value to indicate shared
mode.

"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3576450 // nextWaiter (<unidirectional association>)
	    b parent class_ref 1106306 // Node
	end

	operation 9040386 "isShared"
	  package explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns true if node is waiting in shared mode.
"
	end

	operation 9040514 "predecessor"
	  package return_type class_ref 1106306 // Node
	  nparams 0
	  nexceptions 1
	    exception class_ref 521346 // NullPointerException
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns previous node, or throws NullPointerException if null.
Use when predecessor cannot be null.  The null check could
be elided, but is present to help the VM.

@return the predecessor of this node
"
	end

	operation 9040642 "Node"
	  package explicit_return_type ""
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9040770 "Node"
	  package explicit_return_type ""
	  nparams 2
	    param inout name "thread" type class_ref 128642 // Thread
	    param inout name "mode" type class_ref 1106306 // Node
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9040898 "Node"
	  package explicit_return_type ""
	  nparams 2
	    param inout name "thread" type class_ref 128642 // Thread
	    param in name "waitStatus" explicit_type "int"
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      classrelation 3576578 // head (<unidirectional association>)
	relation 3576578 --->
	  a role_name "head" volatile private
	    comment "
Head of the wait queue, lazily initialized.  Except for
initialization, it is modified only via method setHead.  Note:
If head exists, its waitStatus is guaranteed not to be
CANCELLED.

"
	    transient
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 3576578 // head (<unidirectional association>)
	  b parent class_ref 1106306 // Node
      end

      classrelation 3576706 // tail (<unidirectional association>)
	relation 3576706 --->
	  a role_name "tail" volatile private
	    comment "
Tail of the wait queue, lazily initialized.  Modified only via
method enq to add new wait node.

"
	    transient
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 3576706 // tail (<unidirectional association>)
	  b parent class_ref 1106306 // Node
      end

      attribute 2109314 "state"
	volatile private explicit_type "int"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "The synchronization state.

"
      end

      operation 9041026 "getState"
	protected explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the current value of synchronization state.
This operation has memory semantics of a {@code volatile} read.
@return current state value
"
      end

      operation 9041154 "setState"
	protected explicit_return_type "void"
	nparams 1
	  param in name "newState" explicit_type "int"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sets the value of synchronization state.
This operation has memory semantics of a {@code volatile} write.
@param newState the new state value
"
      end

      operation 9041282 "compareAndSetState"
	protected explicit_return_type "boolean"
	nparams 2
	  param in name "expect" explicit_type "int"
	  param in name "update" explicit_type "int"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Atomically sets synchronization state to the given updated
value if the current state value equals the expected value.
This operation has memory semantics of a {@code volatile} read
and write.

@param expect the expected value
@param update the new value
@return {@code true} if successful. False return indicates that the actual
        value was not equal to the expected value.
"
      end

      attribute 2109442 "spinForTimeoutThreshold"
	class_attribute const_attribute package explicit_type "long"
	init_value " 1000L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Queuing utilities

The number of nanoseconds for which it is faster to spin
rather than to use timed park. A rough estimate suffices
to improve responsiveness with very short timeouts.

"
      end

      operation 9041410 "enq"
	private return_type class_ref 1106306 // Node
	nparams 1
	  param in name "node" type class_ref 1106306 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}final ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Inserts node into queue, initializing if necessary. See picture above.
@param node the node to insert
@return node's predecessor
"
      end

      operation 9041538 "addWaiter"
	private return_type class_ref 1106306 // Node
	nparams 1
	  param inout name "mode" type class_ref 1106306 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates and enqueues node for current thread and given mode.

@param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared
@return the new node
"
      end

      operation 9041666 "setHead"
	private explicit_return_type "void"
	nparams 1
	  param inout name "node" type class_ref 1106306 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sets head of queue to be node, thus dequeuing. Called only by
acquire methods.  Also nulls out unused fields for sake of GC
and to suppress unnecessary signals and traversals.

@param node the node
"
      end

      operation 9041794 "unparkSuccessor"
	private explicit_return_type "void"
	nparams 1
	  param inout name "node" type class_ref 1106306 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Wakes up node's successor, if one exists.

@param node the node
"
      end

      operation 9041922 "doReleaseShared"
	private explicit_return_type "void"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Release action for shared mode -- signals successor and ensures
propagation. (Note: For exclusive mode, release just amounts
to calling unparkSuccessor of head if it needs signal.)
"
      end

      operation 9042050 "setHeadAndPropagate"
	private explicit_return_type "void"
	nparams 2
	  param inout name "node" type class_ref 1106306 // Node
	  param in name "propagate" explicit_type "int"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sets head of queue, and checks if successor may be waiting
in shared mode, if so propagating if either propagate > 0 or
PROPAGATE status was set.

@param node the node
@param propagate the return value from a tryAcquireShared
"
      end

      operation 9042178 "cancelAcquire"
	private explicit_return_type "void"
	nparams 1
	  param inout name "node" type class_ref 1106306 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Utilities for various versions of acquire

Cancels an ongoing attempt to acquire.

@param node the node
"
      end

      operation 9042306 "shouldParkAfterFailedAcquire"
	class_operation private explicit_return_type "boolean"
	nparams 2
	  param inout name "pred" type class_ref 1106306 // Node
	  param inout name "node" type class_ref 1106306 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Checks and updates status for a node that failed to acquire.
Returns true if thread should block. This is the main signal
control in all acquire loops.  Requires that pred == node.prev.

@param pred node's predecessor holding status
@param node the node
@return {@code true} if thread should block
"
      end

      operation 9042434 "selfInterrupt"
	class_operation package explicit_return_type "void"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Convenience method to interrupt current thread.
"
      end

      operation 9042562 "parkAndCheckInterrupt"
	private explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Convenience method to park and then check if interrupted

@return {@code true} if interrupted
"
      end

      operation 9042690 "acquireQueued"
	package explicit_return_type "boolean"
	nparams 2
	  param in name "node" type class_ref 1106306 // Node
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}final ${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Various flavors of acquire, varying in exclusive/shared and
control modes.  Each is mostly the same, but annoyingly
different.  Only a little bit of factoring is possible due to
interactions of exception mechanics (including ensuring that we
cancel if tryAcquire throws exception) and other control, at
least not without hurting performance too much.


Acquires in exclusive uninterruptible mode for thread already in
queue. Used by condition wait methods as well as acquire.

@param node the node
@param arg the acquire argument
@return {@code true} if interrupted while waiting
"
      end

      operation 9042818 "doAcquireInterruptibly"
	private explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in exclusive interruptible mode.
@param arg the acquire argument
"
      end

      operation 9042946 "doAcquireNanos"
	private explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "int"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in exclusive timed mode.

@param arg the acquire argument
@param nanosTimeout max wait time
@return {@code true} if acquired
"
      end

      operation 9043074 "doAcquireShared"
	private explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared uninterruptible mode.
@param arg the acquire argument
"
      end

      operation 9043202 "doAcquireSharedInterruptibly"
	private explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared interruptible mode.
@param arg the acquire argument
"
      end

      operation 9043330 "doAcquireSharedNanos"
	private explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "int"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared timed mode.

@param arg the acquire argument
@param nanosTimeout max wait time
@return {@code true} if acquired
"
      end

      operation 9043458 "tryAcquire"
	protected explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Main exported methods

Attempts to acquire in exclusive mode. This method should query
if the state of the object permits it to be acquired in the
exclusive mode, and if so to acquire it.

<p>This method is always invoked by the thread performing
acquire.  If this method reports failure, the acquire method
may queue the thread, if it is not already queued, until it is
signalled by a release from some other thread. This can be used
to implement method {@link Lock#tryLock()}.

<p>The default
implementation throws {@link UnsupportedOperationException}.

@param arg the acquire argument. This value is always the one
       passed to an acquire method, or is the value saved on entry
       to a condition wait.  The value is otherwise uninterpreted
       and can represent anything you like.
@return {@code true} if successful. Upon success, this object has
        been acquired.
@throws IllegalMonitorStateException if acquiring would place this
        synchronizer in an illegal state. This exception must be
        thrown in a consistent fashion for synchronization to work
        correctly.
@throws UnsupportedOperationException if exclusive mode is not supported
"
      end

      operation 9043586 "tryRelease"
	protected explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to set the state to reflect a release in exclusive
mode.

<p>This method is always invoked by the thread performing release.

<p>The default implementation throws
{@link UnsupportedOperationException}.

@param arg the release argument. This value is always the one
       passed to a release method, or the current state value upon
       entry to a condition wait.  The value is otherwise
       uninterpreted and can represent anything you like.
@return {@code true} if this object is now in a fully released
        state, so that any waiting threads may attempt to acquire;
        and {@code false} otherwise.
@throws IllegalMonitorStateException if releasing would place this
        synchronizer in an illegal state. This exception must be
        thrown in a consistent fashion for synchronization to work
        correctly.
@throws UnsupportedOperationException if exclusive mode is not supported
"
      end

      operation 9043714 "tryAcquireShared"
	protected explicit_return_type "int"
	nparams 1
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to acquire in shared mode. This method should query if
the state of the object permits it to be acquired in the shared
mode, and if so to acquire it.

<p>This method is always invoked by the thread performing
acquire.  If this method reports failure, the acquire method
may queue the thread, if it is not already queued, until it is
signalled by a release from some other thread.

<p>The default implementation throws {@link
UnsupportedOperationException}.

@param arg the acquire argument. This value is always the one
       passed to an acquire method, or is the value saved on entry
       to a condition wait.  The value is otherwise uninterpreted
       and can represent anything you like.
@return a negative value on failure; zero if acquisition in shared
        mode succeeded but no subsequent shared-mode acquire can
        succeed; and a positive value if acquisition in shared
        mode succeeded and subsequent shared-mode acquires might
        also succeed, in which case a subsequent waiting thread
        must check availability. (Support for three different
        return values enables this method to be used in contexts
        where acquires only sometimes act exclusively.)  Upon
        success, this object has been acquired.
@throws IllegalMonitorStateException if acquiring would place this
        synchronizer in an illegal state. This exception must be
        thrown in a consistent fashion for synchronization to work
        correctly.
@throws UnsupportedOperationException if shared mode is not supported
"
      end

      operation 9043842 "tryReleaseShared"
	protected explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to set the state to reflect a release in shared mode.

<p>This method is always invoked by the thread performing release.

<p>The default implementation throws
{@link UnsupportedOperationException}.

@param arg the release argument. This value is always the one
       passed to a release method, or the current state value upon
       entry to a condition wait.  The value is otherwise
       uninterpreted and can represent anything you like.
@return {@code true} if this release of shared mode may permit a
        waiting acquire (shared or exclusive) to succeed; and
        {@code false} otherwise
@throws IllegalMonitorStateException if releasing would place this
        synchronizer in an illegal state. This exception must be
        thrown in a consistent fashion for synchronization to work
        correctly.
@throws UnsupportedOperationException if shared mode is not supported
"
      end

      operation 9043970 "isHeldExclusively"
	protected explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns {@code true} if synchronization is held exclusively with
respect to the current (calling) thread.  This method is invoked
upon each call to a non-waiting {@link ConditionObject} method.
(Waiting methods instead invoke {@link #release}.)

<p>The default implementation throws {@link
UnsupportedOperationException}. This method is invoked
internally only within {@link ConditionObject} methods, so need
not be defined if conditions are not used.

@return {@code true} if synchronization is held exclusively;
        {@code false} otherwise
@throws UnsupportedOperationException if conditions are not supported
"
      end

      operation 9044098 "acquire"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in exclusive mode, ignoring interrupts.  Implemented
by invoking at least once {@link #tryAcquire},
returning on success.  Otherwise the thread is queued, possibly
repeatedly blocking and unblocking, invoking {@link
#tryAcquire} until success.  This method can be used
to implement method {@link Lock#lock}.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquire} but is otherwise uninterpreted and
       can represent anything you like.
"
      end

      operation 9044226 "acquireInterruptibly"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in exclusive mode, aborting if interrupted.
Implemented by first checking interrupt status, then invoking
at least once {@link #tryAcquire}, returning on
success.  Otherwise the thread is queued, possibly repeatedly
blocking and unblocking, invoking {@link #tryAcquire}
until success or the thread is interrupted.  This method can be
used to implement method {@link Lock#lockInterruptibly}.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquire} but is otherwise uninterpreted and
       can represent anything you like.
@throws InterruptedException if the current thread is interrupted
"
      end

      operation 9044354 "tryAcquireNanos"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "int"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to acquire in exclusive mode, aborting if interrupted,
and failing if the given timeout elapses.  Implemented by first
checking interrupt status, then invoking at least once {@link
#tryAcquire}, returning on success.  Otherwise, the thread is
queued, possibly repeatedly blocking and unblocking, invoking
{@link #tryAcquire} until success or the thread is interrupted
or the timeout elapses.  This method can be used to implement
method {@link Lock#tryLock(long, TimeUnit)}.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquire} but is otherwise uninterpreted and
       can represent anything you like.
@param nanosTimeout the maximum number of nanoseconds to wait
@return {@code true} if acquired; {@code false} if timed out
@throws InterruptedException if the current thread is interrupted
"
      end

      operation 9044482 "release"
	public explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Releases in exclusive mode.  Implemented by unblocking one or
more threads if {@link #tryRelease} returns true.
This method can be used to implement method {@link Lock#unlock}.

@param arg the release argument.  This value is conveyed to
       {@link #tryRelease} but is otherwise uninterpreted and
       can represent anything you like.
@return the value returned from {@link #tryRelease}
"
      end

      operation 9044610 "acquireShared"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared mode, ignoring interrupts.  Implemented by
first invoking at least once {@link #tryAcquireShared},
returning on success.  Otherwise the thread is queued, possibly
repeatedly blocking and unblocking, invoking {@link
#tryAcquireShared} until success.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquireShared} but is otherwise uninterpreted
       and can represent anything you like.
"
      end

      operation 9044738 "acquireSharedInterruptibly"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "int"
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared mode, aborting if interrupted.  Implemented
by first checking interrupt status, then invoking at least once
{@link #tryAcquireShared}, returning on success.  Otherwise the
thread is queued, possibly repeatedly blocking and unblocking,
invoking {@link #tryAcquireShared} until success or the thread
is interrupted.
@param arg the acquire argument.
This value is conveyed to {@link #tryAcquireShared} but is
otherwise uninterpreted and can represent anything
you like.
@throws InterruptedException if the current thread is interrupted
"
      end

      operation 9044866 "tryAcquireSharedNanos"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "int"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to acquire in shared mode, aborting if interrupted, and
failing if the given timeout elapses.  Implemented by first
checking interrupt status, then invoking at least once {@link
#tryAcquireShared}, returning on success.  Otherwise, the
thread is queued, possibly repeatedly blocking and unblocking,
invoking {@link #tryAcquireShared} until success or the thread
is interrupted or the timeout elapses.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquireShared} but is otherwise uninterpreted
       and can represent anything you like.
@param nanosTimeout the maximum number of nanoseconds to wait
@return {@code true} if acquired; {@code false} if timed out
@throws InterruptedException if the current thread is interrupted
"
      end

      operation 9044994 "releaseShared"
	public explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "int"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Releases in shared mode.  Implemented by unblocking one or more
threads if {@link #tryReleaseShared} returns true.

@param arg the release argument.  This value is conveyed to
       {@link #tryReleaseShared} but is otherwise uninterpreted
       and can represent anything you like.
@return the value returned from {@link #tryReleaseShared}
"
      end

      operation 9045122 "hasQueuedThreads"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Queue inspection methods

Queries whether any threads are waiting to acquire. Note that
because cancellations due to interrupts and timeouts may occur
at any time, a {@code true} return does not guarantee that any
other thread will ever acquire.

<p>In this implementation, this operation returns in
constant time.

@return {@code true} if there may be other threads waiting to acquire
"
      end

      operation 9045250 "hasContended"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads have ever contended to acquire this
synchronizer; that is if an acquire method has ever blocked.

<p>In this implementation, this operation returns in
constant time.

@return {@code true} if there has ever been contention
"
      end

      operation 9045378 "getFirstQueuedThread"
	public return_type class_ref 128642 // Thread
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the first (longest-waiting) thread in the queue, or
{@code null} if no threads are currently queued.

<p>In this implementation, this operation normally returns in
constant time, but may iterate upon contention if other threads are
concurrently modifying the queue.

@return the first (longest-waiting) thread in the queue, or
        {@code null} if no threads are currently queued
"
      end

      operation 9045506 "fullGetFirstQueuedThread"
	private return_type class_ref 128642 // Thread
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Version of getFirstQueuedThread called when fastpath fails
"
      end

      operation 9045634 "isQueued"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "thread" type class_ref 128642 // Thread
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns true if the given thread is currently queued.

<p>This implementation traverses the queue to determine
presence of the given thread.

@param thread the thread
@return {@code true} if the given thread is on the queue
@throws NullPointerException if the thread is null
"
      end

      operation 9045762 "apparentlyFirstQueuedIsExclusive"
	package explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns {@code true} if the apparent first queued thread, if one
exists, is waiting in exclusive mode.  If this method returns
{@code true}, and the current thread is attempting to acquire in
shared mode (that is, this method is invoked from {@link
#tryAcquireShared}) then it is guaranteed that the current thread
is not the first queued thread.  Used only as a heuristic in
ReentrantReadWriteLock.
"
      end

      operation 9045890 "hasQueuedPredecessors"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads have been waiting to acquire longer
than the current thread.

<p>An invocation of this method is equivalent to (but may be
more efficient than):
 <pre> {@code
getFirstQueuedThread() != Thread.currentThread() &&
hasQueuedThreads()}</pre>

<p>Note that because cancellations due to interrupts and
timeouts may occur at any time, a {@code true} return does not
guarantee that some other thread will acquire before the current
thread.  Likewise, it is possible for another thread to win a
race to enqueue after this method has returned {@code false},
due to the queue being empty.

<p>This method is designed to be used by a fair synchronizer to
avoid <a href=\"AbstractQueuedSynchronizer#barging\">barging</a>.
Such a synchronizer's {@link #tryAcquire} method should return
{@code false}, and its {@link #tryAcquireShared} method should
return a negative value, if this method returns {@code true}
(unless this is a reentrant acquire).  For example, the {@code
tryAcquire} method for a fair, reentrant, exclusive mode
synchronizer might look like this:

 <pre> {@code
protected boolean tryAcquire(int arg) {
  if (isHeldExclusively()) {
    // A reentrant acquire; increment hold count
    return true;
  } else if (hasQueuedPredecessors()) {
    return false;
  } else {
    // try to acquire normally
  }
}}</pre>

@return {@code true} if there is a queued thread preceding the
        current thread, and {@code false} if the current thread
        is at the head of the queue or the queue is empty
@since 1.7
"
      end

      operation 9046018 "getQueueLength"
	public explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Instrumentation and monitoring methods

Returns an estimate of the number of threads waiting to
acquire.  The value is only an estimate because the number of
threads may change dynamically while this method traverses
internal data structures.  This method is designed for use in
monitoring system state, not for synchronization
control.

@return the estimated number of threads waiting to acquire
"
      end

      operation 9046146 "getQueuedThreads"
	public return_type class_ref 184194 // Collection
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire.  Because the actual set of threads may change
dynamically while constructing this result, the returned
collection is only a best-effort estimate.  The elements of the
returned collection are in no particular order.  This method is
designed to facilitate construction of subclasses that provide
more extensive monitoring facilities.

@return the collection of threads
"
      end

      operation 9046274 "getExclusiveQueuedThreads"
	public return_type class_ref 184194 // Collection
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire in exclusive mode. This has the same properties
as {@link #getQueuedThreads} except that it only returns
those threads waiting due to an exclusive acquire.

@return the collection of threads
"
      end

      operation 9046402 "getSharedQueuedThreads"
	public return_type class_ref 184194 // Collection
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire in shared mode. This has the same properties
as {@link #getQueuedThreads} except that it only returns
those threads waiting due to a shared acquire.

@return the collection of threads
"
      end

      operation 9046530 "toString"
	public return_type class_ref 128130 // String
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a string identifying this synchronizer, as well as its state.
The state, in brackets, includes the String {@code \"State =\"}
followed by the current value of {@link #getState}, and either
{@code \"nonempty\"} or {@code \"empty\"} depending on whether the
queue is empty.

@return a string identifying this synchronizer, as well as its state
"
      end

      operation 9046658 "isOnSyncQueue"
	package explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 1106306 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Internal support methods for Conditions

Returns true if a node, always one that was initially placed on
a condition queue, is now waiting to reacquire on sync queue.
@param node the node
@return true if is reacquiring
"
      end

      operation 9046786 "findNodeFromTail"
	private explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 1106306 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns true if node is on sync queue by searching backwards from tail.
Called only when needed by isOnSyncQueue.
@return true if present
"
      end

      operation 9046914 "transferForSignal"
	package explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 1106306 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Transfers a node from a condition queue onto sync queue.
Returns true if successful.
@param node the node
@return true if successfully transferred (else the node was
cancelled before signal)
"
      end

      operation 9047042 "transferAfterCancelledWait"
	package explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 1106306 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Transfers node, if necessary, to sync queue after a cancelled wait.
Returns true if thread was cancelled before being signalled.

@param node the node
@return true if cancelled before the node was signalled
"
      end

      operation 9047170 "fullyRelease"
	package explicit_return_type "int"
	nparams 1
	  param inout name "node" type class_ref 1106306 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Invokes release with current state value; returns saved state.
Cancels node and throws exception on failure.
@param node the condition node for this wait
@return previous sync state
"
      end

      operation 9047298 "owns"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "condition" type class_ref 1106434 // ConditionObject
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Instrumentation methods for conditions

Queries whether the given ConditionObject
uses this synchronizer as its lock.

@param condition the condition
@return {@code true} if owned
@throws NullPointerException if the condition is null
"
      end

      class 1106434 "ConditionObject"
	visibility public 
	cpp_decl ""
	java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3576834 // <realization>
	  relation 3576834 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 3576834 // <realization>
	    b parent class_ref 864770 // Condition
	end

	classrelation 3576962 // <realization>
	  relation 3576962 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 3576962 // <realization>
	    b parent class_ref 136578 // Serializable
	end

	attribute 2109570 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " 1173984872572414699L"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	classrelation 3577090 // firstWaiter (<unidirectional association>)
	  relation 3577090 --->
	    a role_name "firstWaiter" private
	      comment " First node of condition queue. 
"
	      transient
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3577090 // firstWaiter (<unidirectional association>)
	    b parent class_ref 1106306 // Node
	end

	classrelation 3577218 // lastWaiter (<unidirectional association>)
	  relation 3577218 --->
	    a role_name "lastWaiter" private
	      comment " Last node of condition queue. 
"
	      transient
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3577218 // lastWaiter (<unidirectional association>)
	    b parent class_ref 1106306 // Node
	end

	operation 9048706 "ConditionObject"
	  public explicit_return_type ""
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Creates a new {@code ConditionObject} instance.
"
	end

	operation 9048834 "addConditionWaiter"
	  private return_type class_ref 1106306 // Node
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " Internal methods

Adds a new waiter to wait queue.
@return its new wait node
"
	end

	operation 9048962 "doSignal"
	  private explicit_return_type "void"
	  nparams 1
	    param inout name "first" type class_ref 1106306 // Node
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Removes and transfers nodes until hit non-cancelled one or
null. Split out from signal in part to encourage compilers
to inline the case of no waiters.
@param first (non-null) the first node on condition queue
"
	end

	operation 9049090 "doSignalAll"
	  private explicit_return_type "void"
	  nparams 1
	    param inout name "first" type class_ref 1106306 // Node
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Removes and transfers all nodes.
@param first (non-null) the first node on condition queue
"
	end

	operation 9049218 "unlinkCancelledWaiters"
	  private explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Unlinks cancelled waiter nodes from condition queue.
Called only while holding lock. This is called when
cancellation occurred during condition wait, and upon
insertion of a new waiter when lastWaiter is seen to have
been cancelled. This method is needed to avoid garbage
retention in the absence of signals. So even though it may
require a full traversal, it comes into play only when
timeouts or cancellations occur in the absence of
signals. It traverses all nodes rather than stopping at a
particular target to unlink all pointers to garbage nodes
without requiring many re-traversals during cancellation
storms.
"
	end

	operation 9049346 "signal"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " public methods

Moves the longest-waiting thread, if one exists, from the
wait queue for this condition to the wait queue for the
owning lock.

@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}
"
	end

	operation 9049474 "signalAll"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Moves all threads from the wait queue for this condition to
the wait queue for the owning lock.

@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}
"
	end

	operation 9049602 "awaitUninterruptibly"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements uninterruptible condition wait.
<ol>
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with saved state as argument,
     throwing IllegalMonitorStateException if it fails.
<li> Block until signalled.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
</ol>
"
	end

	attribute 2109698 "REINTERRUPT"
	  class_attribute const_attribute private explicit_type "int"
	  init_value "  1"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment "For interruptible waits, we need to track whether to throw
InterruptedException, if interrupted while blocked on
condition, versus reinterrupt current thread, if
interrupted while blocked waiting to re-acquire.

 Mode meaning to reinterrupt on exit from wait 
"
	end

	attribute 2109826 "THROW_IE"
	  class_attribute const_attribute private explicit_type "int"
	  init_value " -1"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment " Mode meaning to throw InterruptedException on exit from wait 
"
	end

	operation 9049730 "checkInterruptWhileWaiting"
	  private explicit_return_type "int"
	  nparams 1
	    param inout name "node" type class_ref 1106306 // Node
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Checks for interrupt, returning THROW_IE if interrupted
before signalled, REINTERRUPT if after signalled, or
0 if not interrupted.
"
	end

	operation 9049858 "reportInterruptAfterWait"
	  private explicit_return_type "void"
	  nparams 1
	    param in name "interruptMode" explicit_type "int"
	  nexceptions 1
	    exception class_ref 129666 // InterruptedException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Throws InterruptedException, reinterrupts current thread, or
does nothing, depending on mode.
"
	end

	operation 9049986 "await"
	  public explicit_return_type "void"
	  nparams 0
	  nexceptions 1
	    exception class_ref 129666 // InterruptedException
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements interruptible condition wait.
<ol>
<li> If current thread is interrupted, throw InterruptedException.
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with saved state as argument,
     throwing IllegalMonitorStateException if it fails.
<li> Block until signalled or interrupted.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw InterruptedException.
</ol>
"
	end

	operation 9050114 "awaitNanos"
	  public explicit_return_type "long"
	  nparams 1
	    param in name "nanosTimeout" explicit_type "long"
	  nexceptions 1
	    exception class_ref 129666 // InterruptedException
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements timed condition wait.
<ol>
<li> If current thread is interrupted, throw InterruptedException.
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with saved state as argument,
     throwing IllegalMonitorStateException if it fails.
<li> Block until signalled, interrupted, or timed out.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw InterruptedException.
</ol>
"
	end

	operation 9050242 "awaitUntil"
	  public explicit_return_type "boolean"
	  nparams 1
	    param inout name "deadline" type class_ref 521474 // Date
	  nexceptions 1
	    exception class_ref 129666 // InterruptedException
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements absolute timed condition wait.
<ol>
<li> If current thread is interrupted, throw InterruptedException.
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with saved state as argument,
     throwing IllegalMonitorStateException if it fails.
<li> Block until signalled, interrupted, or timed out.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw InterruptedException.
<li> If timed out while blocked in step 4, return false, else true.
</ol>
"
	end

	operation 9050370 "await"
	  public explicit_return_type "boolean"
	  nparams 2
	    param in name "time" explicit_type "long"
	    param inout name "unit" type class_ref 935938 // TimeUnit
	  nexceptions 1
	    exception class_ref 129666 // InterruptedException
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements timed condition wait.
<ol>
<li> If current thread is interrupted, throw InterruptedException.
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with saved state as argument,
     throwing IllegalMonitorStateException if it fails.
<li> Block until signalled, interrupted, or timed out.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw InterruptedException.
<li> If timed out while blocked in step 4, return false, else true.
</ol>
"
	end

	operation 9050498 "isOwnedBy"
	  package explicit_return_type "boolean"
	  nparams 1
	    param inout name "sync" type class_ref 1106050 // AbstractQueuedSynchronizer
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "  support for instrumentation

Returns true if this condition was created by the given
synchronization object.

@return {@code true} if owned
"
	end

	operation 9050626 "hasWaiters"
	  protected explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Queries whether any threads are waiting on this condition.
Implements {@link AbstractQueuedSynchronizer#hasWaiters(ConditionObject)}.

@return {@code true} if there are any waiting threads
@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}
"
	end

	operation 9050754 "getWaitQueueLength"
	  protected explicit_return_type "int"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns an estimate of the number of threads waiting on
this condition.
Implements {@link AbstractQueuedSynchronizer#getWaitQueueLength(ConditionObject)}.

@return the estimated number of waiting threads
@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}
"
	end

	operation 9050882 "getWaitingThreads"
	  protected return_type class_ref 184194 // Collection
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns a collection containing those threads that may be
waiting on this Condition.
Implements {@link AbstractQueuedSynchronizer#getWaitingThreads(ConditionObject)}.

@return the collection of threads
@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}
"
	end
      end

      operation 9047426 "hasWaiters"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "condition" type class_ref 1106434 // ConditionObject
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads are waiting on the given condition
associated with this synchronizer. Note that because timeouts
and interrupts may occur at any time, a {@code true} return
does not guarantee that a future {@code signal} will awaken
any threads.  This method is designed primarily for use in
monitoring of the system state.

@param condition the condition
@return {@code true} if there are any waiting threads
@throws IllegalMonitorStateException if exclusive synchronization
        is not held
@throws IllegalArgumentException if the given condition is
        not associated with this synchronizer
@throws NullPointerException if the condition is null
"
      end

      operation 9047554 "getWaitQueueLength"
	public explicit_return_type "int"
	nparams 1
	  param inout name "condition" type class_ref 1106434 // ConditionObject
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an estimate of the number of threads waiting on the
given condition associated with this synchronizer. Note that
because timeouts and interrupts may occur at any time, the
estimate serves only as an upper bound on the actual number of
waiters.  This method is designed for use in monitoring of the
system state, not for synchronization control.

@param condition the condition
@return the estimated number of waiting threads
@throws IllegalMonitorStateException if exclusive synchronization
        is not held
@throws IllegalArgumentException if the given condition is
        not associated with this synchronizer
@throws NullPointerException if the condition is null
"
      end

      operation 9047682 "getWaitingThreads"
	public return_type class_ref 184194 // Collection
	nparams 1
	  param inout name "condition" type class_ref 1106434 // ConditionObject
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing those threads that may be
waiting on the given condition associated with this
synchronizer.  Because the actual set of threads may change
dynamically while constructing this result, the returned
collection is only a best-effort estimate. The elements of the
returned collection are in no particular order.

@param condition the condition
@return the collection of threads
@throws IllegalMonitorStateException if exclusive synchronization
        is not held
@throws IllegalArgumentException if the given condition is
        not associated with this synchronizer
@throws NullPointerException if the condition is null
"
      end

      attribute 2109954 "unsafe"
	class_attribute const_attribute private explicit_type "Unsafe"
	init_value " Unsafe.getUnsafe()"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "Setup to support compareAndSet. We need to natively implement
this here: For the sake of permitting future enhancements, we
cannot explicitly subclass AtomicInteger, which would be
efficient and useful otherwise. So, as the lesser of evils, we
natively implement using hotspot intrinsics API. And while we
are at it, we do the same for other CASable fields (which could
otherwise be done with atomic field updaters).

"
      end

      attribute 2110082 "stateOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2110210 "headOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2110338 "tailOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2110466 "waitStatusOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2110594 "nextOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      extra_member 173058 "initialization"
	
	cpp "" ""
	java "  static {
        try {
            stateOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(\"state\"));
            headOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(\"head\"));
            tailOffset = unsafe.objectFieldOffset
                (AbstractQueuedSynchronizer.class.getDeclaredField(\"tail\"));
            waitStatusOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField(\"waitStatus\"));
            nextOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField(\"next\"));

        } catch (Exception ex) { throw new Error(ex); }
    }"
	php ""
	python ""
	idl ""
	mysql ""
      end

      operation 9051010 "compareAndSetHead"
	private explicit_return_type "boolean"
	nparams 1
	  param inout name "update" type class_ref 1106306 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS head field. Used only by enq.
"
      end

      operation 9051138 "compareAndSetTail"
	private explicit_return_type "boolean"
	nparams 2
	  param inout name "expect" type class_ref 1106306 // Node
	  param inout name "update" type class_ref 1106306 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS tail field. Used only by enq.
"
      end

      operation 9051266 "compareAndSetWaitStatus"
	class_operation private explicit_return_type "boolean"
	nparams 3
	  param inout name "node" type class_ref 1106306 // Node
	  param in name "expect" explicit_type "int"
	  param in name "update" explicit_type "int"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS waitStatus field of a node.
"
      end

      operation 9051394 "compareAndSetNext"
	class_operation private explicit_return_type "boolean"
	nparams 3
	  param inout name "node" type class_ref 1106306 // Node
	  param inout name "expect" type class_ref 1106306 // Node
	  param inout name "update" type class_ref 1106306 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS next field of a node.
"
      end
    end

    class 1106178 "AbstractOwnableSynchronizer"
      abstract visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A synchronizer that may be exclusively owned by a thread.  This
class provides a basis for creating locks and related synchronizers
that may entail a notion of ownership.  The
{@code AbstractOwnableSynchronizer} class itself does not manage or
use this information. However, subclasses and tools may use
appropriately maintained values to help control and monitor access
and provide diagnostics.

@since 1.6
@author Doug Lea
"
      classrelation 3575298 // <realization>
	relation 3575298 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3575298 // <realization>
	  b parent class_ref 136578 // Serializable
      end

      attribute 2108418 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 3737899427754241961L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Use serial ID even though all fields transient. 
"
      end

      operation 9039874 "AbstractOwnableSynchronizer"
	protected explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Empty constructor for use by subclasses.
"
      end

      classrelation 3575426 // exclusiveOwnerThread (<unidirectional association>)
	relation 3575426 --->
	  a role_name "exclusiveOwnerThread" private
	    comment "
The current owner of exclusive mode synchronization.

"
	    transient
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 3575426 // exclusiveOwnerThread (<unidirectional association>)
	  b parent class_ref 128642 // Thread
      end

      operation 9040002 "setExclusiveOwnerThread"
	protected explicit_return_type "void"
	nparams 1
	  param inout name "thread" type class_ref 128642 // Thread
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sets the thread that currently owns exclusive access.
A {@code null} argument indicates that no thread owns access.
This method does not otherwise impose any synchronization or
{@code volatile} field accesses.
@param thread the owner thread
"
      end

      operation 9040130 "getExclusiveOwnerThread"
	protected return_type class_ref 128642 // Thread
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the thread last set by {@code setExclusiveOwnerThread},
or {@code null} if never set.  This method does not otherwise
impose any synchronization or {@code volatile} field accesses.
@return the owner thread
"
      end
    end

    class 1130498 "AbstractQueuedLongSynchronizer"
      abstract visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A version of {@link AbstractQueuedSynchronizer} in
which synchronization state is maintained as a {@code long}.
This class has exactly the same structure, properties, and methods
as {@code AbstractQueuedSynchronizer} with the exception
that all state-related parameters and results are defined
as {@code long} rather than {@code int}. This class
may be useful when creating synchronizers such as
multilevel locks and barriers that require
64 bits of state.

<p>See {@link AbstractQueuedSynchronizer} for usage
notes and examples.

@since 1.6
@author Doug Lea
"
      classrelation 3648130 // <generalisation>
	relation 3648130 ---|>
	  a public
	    java "${type}"
	    classrelation_ref 3648130 // <generalisation>
	  b parent class_ref 1106178 // AbstractOwnableSynchronizer
      end

      classrelation 3648258 // <realization>
	relation 3648258 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3648258 // <realization>
	  b parent class_ref 136578 // Serializable
      end

      attribute 2162562 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " 7373984972572414692L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      operation 9291906 "AbstractQueuedLongSynchronizer"
	protected explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "To keep sources in sync, the remainder of this source file is
exactly cloned from AbstractQueuedSynchronizer, replacing class
name and changing ints related with sync state to longs. Please
keep it that way.


Creates a new {@code AbstractQueuedLongSynchronizer} instance
with initial synchronization state of zero.
"
      end

      class 1130626 "Node"
	visibility package 
	cpp_decl ""
	final static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3648386 // SHARED (<unidirectional association>)
	  relation 3648386 --->
	    a role_name "SHARED" init_value " new Node()" class_relation const_relation package
	      comment " Marker to indicate a node is waiting in shared mode 
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3648386 // SHARED (<unidirectional association>)
	    b parent class_ref 1130626 // Node
	end

	classrelation 3648514 // EXCLUSIVE (<unidirectional association>)
	  relation 3648514 --->
	    a role_name "EXCLUSIVE" init_value " null" class_relation const_relation package
	      comment " Marker to indicate a node is waiting in exclusive mode 
"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3648514 // EXCLUSIVE (<unidirectional association>)
	    b parent class_ref 1130626 // Node
	end

	attribute 2162690 "CANCELLED"
	  class_attribute const_attribute package explicit_type "int"
	  init_value "  1"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment " waitStatus value to indicate thread has cancelled 
"
	end

	attribute 2162818 "SIGNAL"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " -1"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment " waitStatus value to indicate successor's thread needs unparking 
"
	end

	attribute 2162946 "CONDITION"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " -2"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment " waitStatus value to indicate thread is waiting on condition 
"
	end

	attribute 2163074 "PROPAGATE"
	  class_attribute const_attribute package explicit_type "int"
	  init_value " -3"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment "waitStatus value to indicate the next acquireShared should
unconditionally propagate

"
	end

	attribute 2163202 "waitStatus"
	  volatile package explicit_type "int"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment "Status field, taking on only the values:
  SIGNAL:     The successor of this node is (or will soon be)
              blocked (via park), so the current node must
              unpark its successor when it releases or
              cancels. To avoid races, acquire methods must
              first indicate they need a signal,
              then retry the atomic acquire, and then,
              on failure, block.
  CANCELLED:  This node is cancelled due to timeout or interrupt.
              Nodes never leave this state. In particular,
              a thread with cancelled node never again blocks.
  CONDITION:  This node is currently on a condition queue.
              It will not be used as a sync queue node
              until transferred, at which time the status
              will be set to 0. (Use of this value here has
              nothing to do with the other uses of the
              field, but simplifies mechanics.)
  PROPAGATE:  A releaseShared should be propagated to other
              nodes. This is set (for head node only) in
              doReleaseShared to ensure propagation
              continues, even if other operations have
              since intervened.
  0:          None of the above

The values are arranged numerically to simplify use.
Non-negative values mean that a node doesn't need to
signal. So, most code doesn't need to check for particular
values, just for sign.

The field is initialized to 0 for normal sync nodes, and
CONDITION for condition nodes.  It is modified using CAS
(or when possible, unconditional volatile writes).

"
	end

	classrelation 3648642 // prev (<unidirectional association>)
	  relation 3648642 --->
	    a role_name "prev" volatile package
	      comment "
Link to predecessor node that current node/thread relies on
for checking waitStatus. Assigned during enqueuing, and nulled
out (for sake of GC) only upon dequeuing.  Also, upon
cancellation of a predecessor, we short-circuit while
finding a non-cancelled one, which will always exist
because the head node is never cancelled: A node becomes
head only as a result of successful acquire. A
cancelled thread never succeeds in acquiring, and a thread only
cancels itself, not any other node.

"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3648642 // prev (<unidirectional association>)
	    b parent class_ref 1130626 // Node
	end

	classrelation 3648770 // next (<unidirectional association>)
	  relation 3648770 --->
	    a role_name "next" volatile package
	      comment "
Link to the successor node that the current node/thread
unparks upon release. Assigned during enqueuing, adjusted
when bypassing cancelled predecessors, and nulled out (for
sake of GC) when dequeued.  The enq operation does not
assign next field of a predecessor until after attachment,
so seeing a null next field does not necessarily mean that
node is at end of queue. However, if a next field appears
to be null, we can scan prev's from the tail to
double-check.  The next field of cancelled nodes is set to
point to the node itself instead of null, to make life
easier for isOnSyncQueue.

"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3648770 // next (<unidirectional association>)
	    b parent class_ref 1130626 // Node
	end

	classrelation 3648898 // thread (<unidirectional association>)
	  relation 3648898 --->
	    a role_name "thread" volatile package
	      comment "
The thread that enqueued this node.  Initialized on
construction and nulled out after use.

"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3648898 // thread (<unidirectional association>)
	    b parent class_ref 128642 // Thread
	end

	classrelation 3649026 // nextWaiter (<unidirectional association>)
	  relation 3649026 --->
	    a role_name "nextWaiter" package
	      comment "
Link to next node waiting on condition, or the special
value SHARED.  Because condition queues are accessed only
when holding in exclusive mode, we just need a simple
linked queue to hold nodes while they are waiting on
conditions. They are then transferred to the queue to
re-acquire. And because conditions can only be exclusive,
we save a field by using special value to indicate shared
mode.

"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3649026 // nextWaiter (<unidirectional association>)
	    b parent class_ref 1130626 // Node
	end

	operation 9292034 "isShared"
	  package explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns true if node is waiting in shared mode.
"
	end

	operation 9292162 "predecessor"
	  package return_type class_ref 1130626 // Node
	  nparams 0
	  nexceptions 1
	    exception class_ref 521346 // NullPointerException
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns previous node, or throws NullPointerException if null.
Use when predecessor cannot be null.  The null check could
be elided, but is present to help the VM.

@return the predecessor of this node
"
	end

	operation 9292290 "Node"
	  package explicit_return_type ""
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9292418 "Node"
	  package explicit_return_type ""
	  nparams 2
	    param inout name "thread" type class_ref 128642 // Thread
	    param inout name "mode" type class_ref 1130626 // Node
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9292546 "Node"
	  package explicit_return_type ""
	  nparams 2
	    param inout name "thread" type class_ref 128642 // Thread
	    param in name "waitStatus" explicit_type "int"
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      classrelation 3649154 // head (<unidirectional association>)
	relation 3649154 --->
	  a role_name "head" volatile private
	    comment "
Head of the wait queue, lazily initialized.  Except for
initialization, it is modified only via method setHead.  Note:
If head exists, its waitStatus is guaranteed not to be
CANCELLED.

"
	    transient
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 3649154 // head (<unidirectional association>)
	  b parent class_ref 1130626 // Node
      end

      classrelation 3649282 // tail (<unidirectional association>)
	relation 3649282 --->
	  a role_name "tail" volatile private
	    comment "
Tail of the wait queue, lazily initialized.  Modified only via
method enq to add new wait node.

"
	    transient
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 3649282 // tail (<unidirectional association>)
	  b parent class_ref 1130626 // Node
      end

      attribute 2163330 "state"
	volatile private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "The synchronization state.

"
      end

      operation 9292674 "getState"
	protected explicit_return_type "long"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the current value of synchronization state.
This operation has memory semantics of a {@code volatile} read.
@return current state value
"
      end

      operation 9292802 "setState"
	protected explicit_return_type "void"
	nparams 1
	  param in name "newState" explicit_type "long"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sets the value of synchronization state.
This operation has memory semantics of a {@code volatile} write.
@param newState the new state value
"
      end

      operation 9292930 "compareAndSetState"
	protected explicit_return_type "boolean"
	nparams 2
	  param in name "expect" explicit_type "long"
	  param in name "update" explicit_type "long"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Atomically sets synchronization state to the given updated
value if the current state value equals the expected value.
This operation has memory semantics of a {@code volatile} read
and write.

@param expect the expected value
@param update the new value
@return {@code true} if successful. False return indicates that the actual
        value was not equal to the expected value.
"
      end

      attribute 2163458 "spinForTimeoutThreshold"
	class_attribute const_attribute package explicit_type "long"
	init_value " 1000L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Queuing utilities

The number of nanoseconds for which it is faster to spin
rather than to use timed park. A rough estimate suffices
to improve responsiveness with very short timeouts.

"
      end

      operation 9293058 "enq"
	private return_type class_ref 1130626 // Node
	nparams 1
	  param in name "node" type class_ref 1130626 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}final ${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Inserts node into queue, initializing if necessary. See picture above.
@param node the node to insert
@return node's predecessor
"
      end

      operation 9293186 "addWaiter"
	private return_type class_ref 1130626 // Node
	nparams 1
	  param inout name "mode" type class_ref 1130626 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates and enqueues node for current thread and given mode.

@param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared
@return the new node
"
      end

      operation 9293314 "setHead"
	private explicit_return_type "void"
	nparams 1
	  param inout name "node" type class_ref 1130626 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sets head of queue to be node, thus dequeuing. Called only by
acquire methods.  Also nulls out unused fields for sake of GC
and to suppress unnecessary signals and traversals.

@param node the node
"
      end

      operation 9293442 "unparkSuccessor"
	private explicit_return_type "void"
	nparams 1
	  param inout name "node" type class_ref 1130626 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Wakes up node's successor, if one exists.

@param node the node
"
      end

      operation 9293570 "doReleaseShared"
	private explicit_return_type "void"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Release action for shared mode -- signals successor and ensures
propagation. (Note: For exclusive mode, release just amounts
to calling unparkSuccessor of head if it needs signal.)
"
      end

      operation 9293698 "setHeadAndPropagate"
	private explicit_return_type "void"
	nparams 2
	  param inout name "node" type class_ref 1130626 // Node
	  param in name "propagate" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Sets head of queue, and checks if successor may be waiting
in shared mode, if so propagating if either propagate > 0 or
PROPAGATE status was set.

@param node the node
@param propagate the return value from a tryAcquireShared
"
      end

      operation 9293826 "cancelAcquire"
	private explicit_return_type "void"
	nparams 1
	  param inout name "node" type class_ref 1130626 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Utilities for various versions of acquire

Cancels an ongoing attempt to acquire.

@param node the node
"
      end

      operation 9293954 "shouldParkAfterFailedAcquire"
	class_operation private explicit_return_type "boolean"
	nparams 2
	  param inout name "pred" type class_ref 1130626 // Node
	  param inout name "node" type class_ref 1130626 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Checks and updates status for a node that failed to acquire.
Returns true if thread should block. This is the main signal
control in all acquire loops.  Requires that pred == node.prev.

@param pred node's predecessor holding status
@param node the node
@return {@code true} if thread should block
"
      end

      operation 9294082 "selfInterrupt"
	class_operation package explicit_return_type "void"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Convenience method to interrupt current thread.
"
      end

      operation 9294210 "parkAndCheckInterrupt"
	private explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Convenience method to park and then check if interrupted

@return {@code true} if interrupted
"
      end

      operation 9294338 "acquireQueued"
	package explicit_return_type "boolean"
	nparams 2
	  param in name "node" type class_ref 1130626 // Node
	  param in name "arg" explicit_type "long"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}final ${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Various flavors of acquire, varying in exclusive/shared and
control modes.  Each is mostly the same, but annoyingly
different.  Only a little bit of factoring is possible due to
interactions of exception mechanics (including ensuring that we
cancel if tryAcquire throws exception) and other control, at
least not without hurting performance too much.


Acquires in exclusive uninterruptible mode for thread already in
queue. Used by condition wait methods as well as acquire.

@param node the node
@param arg the acquire argument
@return {@code true} if interrupted while waiting
"
      end

      operation 9294466 "doAcquireInterruptibly"
	private explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "long"
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in exclusive interruptible mode.
@param arg the acquire argument
"
      end

      operation 9294594 "doAcquireNanos"
	private explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "long"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in exclusive timed mode.

@param arg the acquire argument
@param nanosTimeout max wait time
@return {@code true} if acquired
"
      end

      operation 9294722 "doAcquireShared"
	private explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared uninterruptible mode.
@param arg the acquire argument
"
      end

      operation 9294850 "doAcquireSharedInterruptibly"
	private explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "long"
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared interruptible mode.
@param arg the acquire argument
"
      end

      operation 9294978 "doAcquireSharedNanos"
	private explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "long"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared timed mode.

@param arg the acquire argument
@param nanosTimeout max wait time
@return {@code true} if acquired
"
      end

      operation 9295106 "tryAcquire"
	protected explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Main exported methods

Attempts to acquire in exclusive mode. This method should query
if the state of the object permits it to be acquired in the
exclusive mode, and if so to acquire it.

<p>This method is always invoked by the thread performing
acquire.  If this method reports failure, the acquire method
may queue the thread, if it is not already queued, until it is
signalled by a release from some other thread. This can be used
to implement method {@link Lock#tryLock()}.

<p>The default
implementation throws {@link UnsupportedOperationException}.

@param arg the acquire argument. This value is always the one
       passed to an acquire method, or is the value saved on entry
       to a condition wait.  The value is otherwise uninterpreted
       and can represent anything you like.
@return {@code true} if successful. Upon success, this object has
        been acquired.
@throws IllegalMonitorStateException if acquiring would place this
        synchronizer in an illegal state. This exception must be
        thrown in a consistent fashion for synchronization to work
        correctly.
@throws UnsupportedOperationException if exclusive mode is not supported
"
      end

      operation 9295234 "tryRelease"
	protected explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to set the state to reflect a release in exclusive
mode.

<p>This method is always invoked by the thread performing release.

<p>The default implementation throws
{@link UnsupportedOperationException}.

@param arg the release argument. This value is always the one
       passed to a release method, or the current state value upon
       entry to a condition wait.  The value is otherwise
       uninterpreted and can represent anything you like.
@return {@code true} if this object is now in a fully released
        state, so that any waiting threads may attempt to acquire;
        and {@code false} otherwise.
@throws IllegalMonitorStateException if releasing would place this
        synchronizer in an illegal state. This exception must be
        thrown in a consistent fashion for synchronization to work
        correctly.
@throws UnsupportedOperationException if exclusive mode is not supported
"
      end

      operation 9295362 "tryAcquireShared"
	protected explicit_return_type "long"
	nparams 1
	  param in name "arg" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to acquire in shared mode. This method should query if
the state of the object permits it to be acquired in the shared
mode, and if so to acquire it.

<p>This method is always invoked by the thread performing
acquire.  If this method reports failure, the acquire method
may queue the thread, if it is not already queued, until it is
signalled by a release from some other thread.

<p>The default implementation throws {@link
UnsupportedOperationException}.

@param arg the acquire argument. This value is always the one
       passed to an acquire method, or is the value saved on entry
       to a condition wait.  The value is otherwise uninterpreted
       and can represent anything you like.
@return a negative value on failure; zero if acquisition in shared
        mode succeeded but no subsequent shared-mode acquire can
        succeed; and a positive value if acquisition in shared
        mode succeeded and subsequent shared-mode acquires might
        also succeed, in which case a subsequent waiting thread
        must check availability. (Support for three different
        return values enables this method to be used in contexts
        where acquires only sometimes act exclusively.)  Upon
        success, this object has been acquired.
@throws IllegalMonitorStateException if acquiring would place this
        synchronizer in an illegal state. This exception must be
        thrown in a consistent fashion for synchronization to work
        correctly.
@throws UnsupportedOperationException if shared mode is not supported
"
      end

      operation 9295490 "tryReleaseShared"
	protected explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to set the state to reflect a release in shared mode.

<p>This method is always invoked by the thread performing release.

<p>The default implementation throws
{@link UnsupportedOperationException}.

@param arg the release argument. This value is always the one
       passed to a release method, or the current state value upon
       entry to a condition wait.  The value is otherwise
       uninterpreted and can represent anything you like.
@return {@code true} if this release of shared mode may permit a
        waiting acquire (shared or exclusive) to succeed; and
        {@code false} otherwise
@throws IllegalMonitorStateException if releasing would place this
        synchronizer in an illegal state. This exception must be
        thrown in a consistent fashion for synchronization to work
        correctly.
@throws UnsupportedOperationException if shared mode is not supported
"
      end

      operation 9295618 "isHeldExclusively"
	protected explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns {@code true} if synchronization is held exclusively with
respect to the current (calling) thread.  This method is invoked
upon each call to a non-waiting {@link ConditionObject} method.
(Waiting methods instead invoke {@link #release}.)

<p>The default implementation throws {@link
UnsupportedOperationException}. This method is invoked
internally only within {@link ConditionObject} methods, so need
not be defined if conditions are not used.

@return {@code true} if synchronization is held exclusively;
        {@code false} otherwise
@throws UnsupportedOperationException if conditions are not supported
"
      end

      operation 9295746 "acquire"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "long"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in exclusive mode, ignoring interrupts.  Implemented
by invoking at least once {@link #tryAcquire},
returning on success.  Otherwise the thread is queued, possibly
repeatedly blocking and unblocking, invoking {@link
#tryAcquire} until success.  This method can be used
to implement method {@link Lock#lock}.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquire} but is otherwise uninterpreted and
       can represent anything you like.
"
      end

      operation 9295874 "acquireInterruptibly"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "long"
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in exclusive mode, aborting if interrupted.
Implemented by first checking interrupt status, then invoking
at least once {@link #tryAcquire}, returning on
success.  Otherwise the thread is queued, possibly repeatedly
blocking and unblocking, invoking {@link #tryAcquire}
until success or the thread is interrupted.  This method can be
used to implement method {@link Lock#lockInterruptibly}.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquire} but is otherwise uninterpreted and
       can represent anything you like.
@throws InterruptedException if the current thread is interrupted
"
      end

      operation 9296002 "tryAcquireNanos"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "long"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to acquire in exclusive mode, aborting if interrupted,
and failing if the given timeout elapses.  Implemented by first
checking interrupt status, then invoking at least once {@link
#tryAcquire}, returning on success.  Otherwise, the thread is
queued, possibly repeatedly blocking and unblocking, invoking
{@link #tryAcquire} until success or the thread is interrupted
or the timeout elapses.  This method can be used to implement
method {@link Lock#tryLock(long, TimeUnit)}.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquire} but is otherwise uninterpreted and
       can represent anything you like.
@param nanosTimeout the maximum number of nanoseconds to wait
@return {@code true} if acquired; {@code false} if timed out
@throws InterruptedException if the current thread is interrupted
"
      end

      operation 9296130 "release"
	public explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "long"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Releases in exclusive mode.  Implemented by unblocking one or
more threads if {@link #tryRelease} returns true.
This method can be used to implement method {@link Lock#unlock}.

@param arg the release argument.  This value is conveyed to
       {@link #tryRelease} but is otherwise uninterpreted and
       can represent anything you like.
@return the value returned from {@link #tryRelease}
"
      end

      operation 9296258 "acquireShared"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "long"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared mode, ignoring interrupts.  Implemented by
first invoking at least once {@link #tryAcquireShared},
returning on success.  Otherwise the thread is queued, possibly
repeatedly blocking and unblocking, invoking {@link
#tryAcquireShared} until success.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquireShared} but is otherwise uninterpreted
       and can represent anything you like.
"
      end

      operation 9296386 "acquireSharedInterruptibly"
	public explicit_return_type "void"
	nparams 1
	  param in name "arg" explicit_type "long"
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Acquires in shared mode, aborting if interrupted.  Implemented
by first checking interrupt status, then invoking at least once
{@link #tryAcquireShared}, returning on success.  Otherwise the
thread is queued, possibly repeatedly blocking and unblocking,
invoking {@link #tryAcquireShared} until success or the thread
is interrupted.
@param arg the acquire argument.
This value is conveyed to {@link #tryAcquireShared} but is
otherwise uninterpreted and can represent anything
you like.
@throws InterruptedException if the current thread is interrupted
"
      end

      operation 9296514 "tryAcquireSharedNanos"
	public explicit_return_type "boolean"
	nparams 2
	  param in name "arg" explicit_type "long"
	  param in name "nanosTimeout" explicit_type "long"
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Attempts to acquire in shared mode, aborting if interrupted, and
failing if the given timeout elapses.  Implemented by first
checking interrupt status, then invoking at least once {@link
#tryAcquireShared}, returning on success.  Otherwise, the
thread is queued, possibly repeatedly blocking and unblocking,
invoking {@link #tryAcquireShared} until success or the thread
is interrupted or the timeout elapses.

@param arg the acquire argument.  This value is conveyed to
       {@link #tryAcquireShared} but is otherwise uninterpreted
       and can represent anything you like.
@param nanosTimeout the maximum number of nanoseconds to wait
@return {@code true} if acquired; {@code false} if timed out
@throws InterruptedException if the current thread is interrupted
"
      end

      operation 9296642 "releaseShared"
	public explicit_return_type "boolean"
	nparams 1
	  param in name "arg" explicit_type "long"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Releases in shared mode.  Implemented by unblocking one or more
threads if {@link #tryReleaseShared} returns true.

@param arg the release argument.  This value is conveyed to
       {@link #tryReleaseShared} but is otherwise uninterpreted
       and can represent anything you like.
@return the value returned from {@link #tryReleaseShared}
"
      end

      operation 9296770 "hasQueuedThreads"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Queue inspection methods

Queries whether any threads are waiting to acquire. Note that
because cancellations due to interrupts and timeouts may occur
at any time, a {@code true} return does not guarantee that any
other thread will ever acquire.

<p>In this implementation, this operation returns in
constant time.

@return {@code true} if there may be other threads waiting to acquire
"
      end

      operation 9296898 "hasContended"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads have ever contended to acquire this
synchronizer; that is if an acquire method has ever blocked.

<p>In this implementation, this operation returns in
constant time.

@return {@code true} if there has ever been contention
"
      end

      operation 9297026 "getFirstQueuedThread"
	public return_type class_ref 128642 // Thread
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the first (longest-waiting) thread in the queue, or
{@code null} if no threads are currently queued.

<p>In this implementation, this operation normally returns in
constant time, but may iterate upon contention if other threads are
concurrently modifying the queue.

@return the first (longest-waiting) thread in the queue, or
        {@code null} if no threads are currently queued
"
      end

      operation 9297154 "fullGetFirstQueuedThread"
	private return_type class_ref 128642 // Thread
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Version of getFirstQueuedThread called when fastpath fails
"
      end

      operation 9297282 "isQueued"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "thread" type class_ref 128642 // Thread
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns true if the given thread is currently queued.

<p>This implementation traverses the queue to determine
presence of the given thread.

@param thread the thread
@return {@code true} if the given thread is on the queue
@throws NullPointerException if the thread is null
"
      end

      operation 9297410 "apparentlyFirstQueuedIsExclusive"
	package explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns {@code true} if the apparent first queued thread, if one
exists, is waiting in exclusive mode.  If this method returns
{@code true}, and the current thread is attempting to acquire in
shared mode (that is, this method is invoked from {@link
#tryAcquireShared}) then it is guaranteed that the current thread
is not the first queued thread.  Used only as a heuristic in
ReentrantReadWriteLock.
"
      end

      operation 9297538 "hasQueuedPredecessors"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads have been waiting to acquire longer
than the current thread.

<p>An invocation of this method is equivalent to (but may be
more efficient than):
 <pre> {@code
getFirstQueuedThread() != Thread.currentThread() &&
hasQueuedThreads()}</pre>

<p>Note that because cancellations due to interrupts and
timeouts may occur at any time, a {@code true} return does not
guarantee that some other thread will acquire before the current
thread.  Likewise, it is possible for another thread to win a
race to enqueue after this method has returned {@code false},
due to the queue being empty.

<p>This method is designed to be used by a fair synchronizer to
avoid <a href=\"AbstractQueuedSynchronizer.html#barging\">barging</a>.
Such a synchronizer's {@link #tryAcquire} method should return
{@code false}, and its {@link #tryAcquireShared} method should
return a negative value, if this method returns {@code true}
(unless this is a reentrant acquire).  For example, the {@code
tryAcquire} method for a fair, reentrant, exclusive mode
synchronizer might look like this:

 <pre> {@code
protected boolean tryAcquire(int arg) {
  if (isHeldExclusively()) {
    // A reentrant acquire; increment hold count
    return true;
  } else if (hasQueuedPredecessors()) {
    return false;
  } else {
    // try to acquire normally
  }
}}</pre>

@return {@code true} if there is a queued thread preceding the
        current thread, and {@code false} if the current thread
        is at the head of the queue or the queue is empty
@since 1.7
"
      end

      operation 9297666 "getQueueLength"
	public explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Instrumentation and monitoring methods

Returns an estimate of the number of threads waiting to
acquire.  The value is only an estimate because the number of
threads may change dynamically while this method traverses
internal data structures.  This method is designed for use in
monitoring system state, not for synchronization
control.

@return the estimated number of threads waiting to acquire
"
      end

      operation 9297794 "getQueuedThreads"
	public return_type class_ref 184194 // Collection
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire.  Because the actual set of threads may change
dynamically while constructing this result, the returned
collection is only a best-effort estimate.  The elements of the
returned collection are in no particular order.  This method is
designed to facilitate construction of subclasses that provide
more extensive monitoring facilities.

@return the collection of threads
"
      end

      operation 9297922 "getExclusiveQueuedThreads"
	public return_type class_ref 184194 // Collection
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire in exclusive mode. This has the same properties
as {@link #getQueuedThreads} except that it only returns
those threads waiting due to an exclusive acquire.

@return the collection of threads
"
      end

      operation 9298050 "getSharedQueuedThreads"
	public return_type class_ref 184194 // Collection
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing threads that may be waiting to
acquire in shared mode. This has the same properties
as {@link #getQueuedThreads} except that it only returns
those threads waiting due to a shared acquire.

@return the collection of threads
"
      end

      operation 9298178 "toString"
	public return_type class_ref 128130 // String
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a string identifying this synchronizer, as well as its state.
The state, in brackets, includes the String {@code \"State =\"}
followed by the current value of {@link #getState}, and either
{@code \"nonempty\"} or {@code \"empty\"} depending on whether the
queue is empty.

@return a string identifying this synchronizer, as well as its state
"
      end

      operation 9298306 "isOnSyncQueue"
	package explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 1130626 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Internal support methods for Conditions

Returns true if a node, always one that was initially placed on
a condition queue, is now waiting to reacquire on sync queue.
@param node the node
@return true if is reacquiring
"
      end

      operation 9298434 "findNodeFromTail"
	private explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 1130626 // Node
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns true if node is on sync queue by searching backwards from tail.
Called only when needed by isOnSyncQueue.
@return true if present
"
      end

      operation 9298562 "transferForSignal"
	package explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 1130626 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Transfers a node from a condition queue onto sync queue.
Returns true if successful.
@param node the node
@return true if successfully transferred (else the node was
cancelled before signal)
"
      end

      operation 9298690 "transferAfterCancelledWait"
	package explicit_return_type "boolean"
	nparams 1
	  param inout name "node" type class_ref 1130626 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Transfers node, if necessary, to sync queue after a cancelled wait.
Returns true if thread was cancelled before being signalled.

@param node the node
@return true if cancelled before the node was signalled
"
      end

      operation 9298818 "fullyRelease"
	package explicit_return_type "long"
	nparams 1
	  param inout name "node" type class_ref 1130626 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Invokes release with current state value; returns saved state.
Cancels node and throws exception on failure.
@param node the condition node for this wait
@return previous sync state
"
      end

      operation 9298946 "owns"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "condition" type class_ref 1130754 // ConditionObject
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Instrumentation methods for conditions

Queries whether the given ConditionObject
uses this synchronizer as its lock.

@param condition the condition
@return {@code true} if owned
@throws NullPointerException if the condition is null
"
      end

      class 1130754 "ConditionObject"
	visibility public 
	cpp_decl ""
	java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3649410 // <realization>
	  relation 3649410 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 3649410 // <realization>
	    b parent class_ref 864770 // Condition
	end

	classrelation 3649538 // <realization>
	  relation 3649538 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 3649538 // <realization>
	    b parent class_ref 136578 // Serializable
	end

	attribute 2163586 "serialVersionUID"
	  class_attribute const_attribute private explicit_type "long"
	  init_value " 1173984872572414699L"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	end

	classrelation 3649666 // firstWaiter (<unidirectional association>)
	  relation 3649666 --->
	    a role_name "firstWaiter" private
	      comment " First node of condition queue. 
"
	      transient
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3649666 // firstWaiter (<unidirectional association>)
	    b parent class_ref 1130626 // Node
	end

	classrelation 3649794 // lastWaiter (<unidirectional association>)
	  relation 3649794 --->
	    a role_name "lastWaiter" private
	      comment " Last node of condition queue. 
"
	      transient
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3649794 // lastWaiter (<unidirectional association>)
	    b parent class_ref 1130626 // Node
	end

	operation 9299458 "ConditionObject"
	  public explicit_return_type ""
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Creates a new {@code ConditionObject} instance.
"
	end

	operation 9299586 "addConditionWaiter"
	  private return_type class_ref 1130626 // Node
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " Internal methods

Adds a new waiter to wait queue.
@return its new wait node
"
	end

	operation 9299714 "doSignal"
	  private explicit_return_type "void"
	  nparams 1
	    param inout name "first" type class_ref 1130626 // Node
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Removes and transfers nodes until hit non-cancelled one or
null. Split out from signal in part to encourage compilers
to inline the case of no waiters.
@param first (non-null) the first node on condition queue
"
	end

	operation 9299842 "doSignalAll"
	  private explicit_return_type "void"
	  nparams 1
	    param inout name "first" type class_ref 1130626 // Node
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Removes and transfers all nodes.
@param first (non-null) the first node on condition queue
"
	end

	operation 9299970 "unlinkCancelledWaiters"
	  private explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Unlinks cancelled waiter nodes from condition queue.
Called only while holding lock. This is called when
cancellation occurred during condition wait, and upon
insertion of a new waiter when lastWaiter is seen to have
been cancelled. This method is needed to avoid garbage
retention in the absence of signals. So even though it may
require a full traversal, it comes into play only when
timeouts or cancellations occur in the absence of
signals. It traverses all nodes rather than stopping at a
particular target to unlink all pointers to garbage nodes
without requiring many re-traversals during cancellation
storms.
"
	end

	operation 9300098 "signal"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment " public methods

Moves the longest-waiting thread, if one exists, from the
wait queue for this condition to the wait queue for the
owning lock.

@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}
"
	end

	operation 9300226 "signalAll"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Moves all threads from the wait queue for this condition to
the wait queue for the owning lock.

@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}
"
	end

	operation 9300354 "awaitUninterruptibly"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements uninterruptible condition wait.
<ol>
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with saved state as argument,
     throwing IllegalMonitorStateException if it fails.
<li> Block until signalled.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
</ol>
"
	end

	attribute 2163714 "REINTERRUPT"
	  class_attribute const_attribute private explicit_type "int"
	  init_value "  1"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment "For interruptible waits, we need to track whether to throw
InterruptedException, if interrupted while blocked on
condition, versus reinterrupt current thread, if
interrupted while blocked waiting to re-acquire.

 Mode meaning to reinterrupt on exit from wait 
"
	end

	attribute 2163842 "THROW_IE"
	  class_attribute const_attribute private explicit_type "int"
	  init_value " -1"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment " Mode meaning to throw InterruptedException on exit from wait 
"
	end

	operation 9300482 "checkInterruptWhileWaiting"
	  private explicit_return_type "int"
	  nparams 1
	    param inout name "node" type class_ref 1130626 // Node
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Checks for interrupt, returning THROW_IE if interrupted
before signalled, REINTERRUPT if after signalled, or
0 if not interrupted.
"
	end

	operation 9300610 "reportInterruptAfterWait"
	  private explicit_return_type "void"
	  nparams 1
	    param in name "interruptMode" explicit_type "int"
	  nexceptions 1
	    exception class_ref 129666 // InterruptedException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Throws InterruptedException, reinterrupts current thread, or
does nothing, depending on mode.
"
	end

	operation 9300738 "await"
	  public explicit_return_type "void"
	  nparams 0
	  nexceptions 1
	    exception class_ref 129666 // InterruptedException
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements interruptible condition wait.
<ol>
<li> If current thread is interrupted, throw InterruptedException.
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with saved state as argument,
     throwing IllegalMonitorStateException if it fails.
<li> Block until signalled or interrupted.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw InterruptedException.
</ol>
"
	end

	operation 9300866 "awaitNanos"
	  public explicit_return_type "long"
	  nparams 1
	    param in name "nanosTimeout" explicit_type "long"
	  nexceptions 1
	    exception class_ref 129666 // InterruptedException
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements timed condition wait.
<ol>
<li> If current thread is interrupted, throw InterruptedException.
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with saved state as argument,
     throwing IllegalMonitorStateException if it fails.
<li> Block until signalled, interrupted, or timed out.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw InterruptedException.
</ol>
"
	end

	operation 9300994 "awaitUntil"
	  public explicit_return_type "boolean"
	  nparams 1
	    param inout name "deadline" type class_ref 521474 // Date
	  nexceptions 1
	    exception class_ref 129666 // InterruptedException
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements absolute timed condition wait.
<ol>
<li> If current thread is interrupted, throw InterruptedException.
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with saved state as argument,
     throwing IllegalMonitorStateException if it fails.
<li> Block until signalled, interrupted, or timed out.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw InterruptedException.
<li> If timed out while blocked in step 4, return false, else true.
</ol>
"
	end

	operation 9301122 "await"
	  public explicit_return_type "boolean"
	  nparams 2
	    param in name "time" explicit_type "long"
	    param inout name "unit" type class_ref 935938 // TimeUnit
	  nexceptions 1
	    exception class_ref 129666 // InterruptedException
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Implements timed condition wait.
<ol>
<li> If current thread is interrupted, throw InterruptedException.
<li> Save lock state returned by {@link #getState}.
<li> Invoke {@link #release} with saved state as argument,
     throwing IllegalMonitorStateException if it fails.
<li> Block until signalled, interrupted, or timed out.
<li> Reacquire by invoking specialized version of
     {@link #acquire} with saved state as argument.
<li> If interrupted while blocked in step 4, throw InterruptedException.
<li> If timed out while blocked in step 4, return false, else true.
</ol>
"
	end

	operation 9301250 "isOwnedBy"
	  package explicit_return_type "boolean"
	  nparams 1
	    param inout name "sync" type class_ref 1130498 // AbstractQueuedLongSynchronizer
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "  support for instrumentation

Returns true if this condition was created by the given
synchronization object.

@return {@code true} if owned
"
	end

	operation 9301378 "hasWaiters"
	  protected explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Queries whether any threads are waiting on this condition.
Implements {@link AbstractQueuedLongSynchronizer#hasWaiters(ConditionObject)}.

@return {@code true} if there are any waiting threads
@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}
"
	end

	operation 9301506 "getWaitQueueLength"
	  protected explicit_return_type "int"
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns an estimate of the number of threads waiting on
this condition.
Implements {@link AbstractQueuedLongSynchronizer#getWaitQueueLength(ConditionObject)}.

@return the estimated number of waiting threads
@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}
"
	end

	operation 9301634 "getWaitingThreads"
	  protected return_type class_ref 184194 // Collection
	  nparams 0
	  
	  preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	  comment "Returns a collection containing those threads that may be
waiting on this Condition.
Implements {@link AbstractQueuedLongSynchronizer#getWaitingThreads(ConditionObject)}.

@return the collection of threads
@throws IllegalMonitorStateException if {@link #isHeldExclusively}
        returns {@code false}
"
	end
      end

      operation 9299074 "hasWaiters"
	public explicit_return_type "boolean"
	nparams 1
	  param inout name "condition" type class_ref 1130754 // ConditionObject
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries whether any threads are waiting on the given condition
associated with this synchronizer. Note that because timeouts
and interrupts may occur at any time, a {@code true} return
does not guarantee that a future {@code signal} will awaken
any threads.  This method is designed primarily for use in
monitoring of the system state.

@param condition the condition
@return {@code true} if there are any waiting threads
@throws IllegalMonitorStateException if exclusive synchronization
        is not held
@throws IllegalArgumentException if the given condition is
        not associated with this synchronizer
@throws NullPointerException if the condition is null
"
      end

      operation 9299202 "getWaitQueueLength"
	public explicit_return_type "int"
	nparams 1
	  param inout name "condition" type class_ref 1130754 // ConditionObject
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns an estimate of the number of threads waiting on the
given condition associated with this synchronizer. Note that
because timeouts and interrupts may occur at any time, the
estimate serves only as an upper bound on the actual number of
waiters.  This method is designed for use in monitoring of the
system state, not for synchronization control.

@param condition the condition
@return the estimated number of waiting threads
@throws IllegalMonitorStateException if exclusive synchronization
        is not held
@throws IllegalArgumentException if the given condition is
        not associated with this synchronizer
@throws NullPointerException if the condition is null
"
      end

      operation 9299330 "getWaitingThreads"
	public return_type class_ref 184194 // Collection
	nparams 1
	  param inout name "condition" type class_ref 1130754 // ConditionObject
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type}<Thread> ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a collection containing those threads that may be
waiting on the given condition associated with this
synchronizer.  Because the actual set of threads may change
dynamically while constructing this result, the returned
collection is only a best-effort estimate. The elements of the
returned collection are in no particular order.

@param condition the condition
@return the collection of threads
@throws IllegalMonitorStateException if exclusive synchronization
        is not held
@throws IllegalArgumentException if the given condition is
        not associated with this synchronizer
@throws NullPointerException if the condition is null
"
      end

      attribute 2163970 "unsafe"
	class_attribute const_attribute private explicit_type "Unsafe"
	init_value " Unsafe.getUnsafe()"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "Setup to support compareAndSet. We need to natively implement
this here: For the sake of permitting future enhancements, we
cannot explicitly subclass AtomicLong, which would be
efficient and useful otherwise. So, as the lesser of evils, we
natively implement using hotspot intrinsics API. And while we
are at it, we do the same for other CASable fields (which could
otherwise be done with atomic field updaters).

"
      end

      attribute 2164098 "stateOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2164226 "headOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2164354 "tailOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2164482 "waitStatusOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2164610 "nextOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      extra_member 177154 "initialization"
	
	cpp "" ""
	java "  static {
        try {
            stateOffset = unsafe.objectFieldOffset
                (AbstractQueuedLongSynchronizer.class.getDeclaredField(\"state\"));
            headOffset = unsafe.objectFieldOffset
                (AbstractQueuedLongSynchronizer.class.getDeclaredField(\"head\"));
            tailOffset = unsafe.objectFieldOffset
                (AbstractQueuedLongSynchronizer.class.getDeclaredField(\"tail\"));
            waitStatusOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField(\"waitStatus\"));
            nextOffset = unsafe.objectFieldOffset
                (Node.class.getDeclaredField(\"next\"));

        } catch (Exception ex) { throw new Error(ex); }
    }"
	php ""
	python ""
	idl ""
	mysql ""
      end

      operation 9301762 "compareAndSetHead"
	private explicit_return_type "boolean"
	nparams 1
	  param inout name "update" type class_ref 1130626 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS head field. Used only by enq.
"
      end

      operation 9301890 "compareAndSetTail"
	private explicit_return_type "boolean"
	nparams 2
	  param inout name "expect" type class_ref 1130626 // Node
	  param inout name "update" type class_ref 1130626 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS tail field. Used only by enq.
"
      end

      operation 9302018 "compareAndSetWaitStatus"
	class_operation private explicit_return_type "boolean"
	nparams 3
	  param inout name "node" type class_ref 1130626 // Node
	  param in name "expect" explicit_type "int"
	  param in name "update" explicit_type "int"
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS waitStatus field of a node.
"
      end

      operation 9302146 "compareAndSetNext"
	class_operation private explicit_return_type "boolean"
	nparams 3
	  param inout name "node" type class_ref 1130626 // Node
	  param inout name "expect" type class_ref 1130626 // Node
	  param inout name "update" type class_ref 1130626 // Node
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "CAS next field of a node.
"
      end
    end

    class 1130882 "LockSupport"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "Basic thread blocking primitives for creating locks and other
synchronization classes.

<p>This class associates, with each thread that uses it, a permit
(in the sense of the {@link java.util.concurrent.Semaphore
Semaphore} class). A call to {@code park} will return immediately
if the permit is available, consuming it in the process; otherwise
it <em>may</em> block.  A call to {@code unpark} makes the permit
available, if it was not already available. (Unlike with Semaphores
though, permits do not accumulate. There is at most one.)

<p>Methods {@code park} and {@code unpark} provide efficient
means of blocking and unblocking threads that do not encounter the
problems that cause the deprecated methods {@code Thread.suspend}
and {@code Thread.resume} to be unusable for such purposes: Races
between one thread invoking {@code park} and another thread trying
to {@code unpark} it will preserve liveness, due to the
permit. Additionally, {@code park} will return if the caller's
thread was interrupted, and timeout versions are supported. The
{@code park} method may also return at any other time, for \"no
reason\", so in general must be invoked within a loop that rechecks
conditions upon return. In this sense {@code park} serves as an
optimization of a \"busy wait\" that does not waste as much time
spinning, but must be paired with an {@code unpark} to be
effective.

<p>The three forms of {@code park} each also support a
{@code blocker} object parameter. This object is recorded while
the thread is blocked to permit monitoring and diagnostic tools to
identify the reasons that threads are blocked. (Such tools may
access blockers using method {@link #getBlocker(Thread)}.)
The use of these forms rather than the original forms without this
parameter is strongly encouraged. The normal argument to supply as
a {@code blocker} within a lock implementation is {@code this}.

<p>These methods are designed to be used as tools for creating
higher-level synchronization utilities, and are not in themselves
useful for most concurrency control applications.  The {@code park}
method is designed for use only in constructions of the form:

 <pre> {@code
while (!canProceed()) { ... LockSupport.park(this); }}</pre>

where neither {@code canProceed} nor any other actions prior to the
call to {@code park} entail locking or blocking.  Because only one
permit is associated with each thread, any intermediary uses of
{@code park} could interfere with its intended effects.

<p><b>Sample Usage.</b> Here is a sketch of a first-in-first-out
non-reentrant lock class:
 <pre> {@code
class FIFOMutex {
  private final AtomicBoolean locked = new AtomicBoolean(false);
  private final Queue<Thread> waiters
    = new ConcurrentLinkedQueue<Thread>();

  public void lock() {
    boolean wasInterrupted = false;
    Thread current = Thread.currentThread();
    waiters.add(current);

    // Block while not first in queue or cannot acquire lock
    while (waiters.peek() != current ||
           !locked.compareAndSet(false, true)) {
      LockSupport.park(this);
      if (Thread.interrupted()) // ignore interrupts while waiting
        wasInterrupted = true;
    }

    waiters.remove();
    if (wasInterrupted)          // reassert interrupt status on exit
      current.interrupt();
  }

  public void unlock() {
    locked.set(false);
    LockSupport.unpark(waiters.peek());
  }
}}</pre>
"
      operation 9302274 "LockSupport"
	private explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 9302402 "setBlocker"
	class_operation private explicit_return_type "void"
	nparams 2
	  param inout name "t" type class_ref 128642 // Thread
	  param inout name "arg" type class_ref 129538 // Object
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Cannot be instantiated."
      end

      operation 9302530 "unpark"
	class_operation public explicit_return_type "void"
	nparams 1
	  param inout name "thread" type class_ref 128642 // Thread
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Makes available the permit for the given thread, if it
was not already available.  If the thread was blocked on
{@code park} then it will unblock.  Otherwise, its next call
to {@code park} is guaranteed not to block. This operation
is not guaranteed to have any effect at all if the given
thread has not been started.

@param thread the thread to unpark, or {@code null}, in which case
       this operation has no effect
"
      end

      operation 9302658 "park"
	class_operation public explicit_return_type "void"
	nparams 1
	  param inout name "blocker" type class_ref 129538 // Object
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Disables the current thread for thread scheduling purposes unless the
permit is available.

<p>If the permit is available then it is consumed and the call returns
immediately; otherwise
the current thread becomes disabled for thread scheduling
purposes and lies dormant until one of three things happens:

<ul>
<li>Some other thread invokes {@link #unpark unpark} with the
current thread as the target; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread; or

<li>The call spuriously (that is, for no reason) returns.
</ul>

<p>This method does <em>not</em> report which of these caused the
method to return. Callers should re-check the conditions which caused
the thread to park in the first place. Callers may also determine,
for example, the interrupt status of the thread upon return.

@param blocker the synchronization object responsible for this
       thread parking
@since 1.6
"
      end

      operation 9302786 "parkNanos"
	class_operation public explicit_return_type "void"
	nparams 2
	  param inout name "blocker" type class_ref 129538 // Object
	  param in name "nanos" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Disables the current thread for thread scheduling purposes, for up to
the specified waiting time, unless the permit is available.

<p>If the permit is available then it is consumed and the call
returns immediately; otherwise the current thread becomes disabled
for thread scheduling purposes and lies dormant until one of four
things happens:

<ul>
<li>Some other thread invokes {@link #unpark unpark} with the
current thread as the target; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread; or

<li>The specified waiting time elapses; or

<li>The call spuriously (that is, for no reason) returns.
</ul>

<p>This method does <em>not</em> report which of these caused the
method to return. Callers should re-check the conditions which caused
the thread to park in the first place. Callers may also determine,
for example, the interrupt status of the thread, or the elapsed time
upon return.

@param blocker the synchronization object responsible for this
       thread parking
@param nanos the maximum number of nanoseconds to wait
@since 1.6
"
      end

      operation 9302914 "parkUntil"
	class_operation public explicit_return_type "void"
	nparams 2
	  param inout name "blocker" type class_ref 129538 // Object
	  param in name "deadline" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Disables the current thread for thread scheduling purposes, until
the specified deadline, unless the permit is available.

<p>If the permit is available then it is consumed and the call
returns immediately; otherwise the current thread becomes disabled
for thread scheduling purposes and lies dormant until one of four
things happens:

<ul>
<li>Some other thread invokes {@link #unpark unpark} with the
current thread as the target; or

<li>Some other thread {@linkplain Thread#interrupt interrupts} the
current thread; or

<li>The specified deadline passes; or

<li>The call spuriously (that is, for no reason) returns.
</ul>

<p>This method does <em>not</em> report which of these caused the
method to return. Callers should re-check the conditions which caused
the thread to park in the first place. Callers may also determine,
for example, the interrupt status of the thread, or the current time
upon return.

@param blocker the synchronization object responsible for this
       thread parking
@param deadline the absolute time, in milliseconds from the Epoch,
       to wait until
@since 1.6
"
      end

      operation 9303042 "getBlocker"
	class_operation public return_type class_ref 129538 // Object
	nparams 1
	  param inout name "t" type class_ref 128642 // Thread
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the blocker object supplied to the most recent
invocation of a park method that has not yet unblocked, or null
if not blocked.  The value returned is just a momentary
snapshot -- the thread may have since unblocked or blocked on a
different blocker object.

@param t the thread
@return the blocker
@throws NullPointerException if argument is null
@since 1.6
"
      end

      operation 9303170 "park"
	class_operation public explicit_return_type "void"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Disables the current thread for thread scheduling purposes unless the
permit is available.

<p>If the permit is available then it is consumed and the call
returns immediately; otherwise the current thread becomes disabled
for thread scheduling purposes and lies dormant until one of three
things happens:

<ul>

<li>Some other thread invokes {@link #unpark unpark} with the
current thread as the target; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread; or

<li>The call spuriously (that is, for no reason) returns.
</ul>

<p>This method does <em>not</em> report which of these caused the
method to return. Callers should re-check the conditions which caused
the thread to park in the first place. Callers may also determine,
for example, the interrupt status of the thread upon return.
"
      end

      operation 9303298 "parkNanos"
	class_operation public explicit_return_type "void"
	nparams 1
	  param in name "nanos" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Disables the current thread for thread scheduling purposes, for up to
the specified waiting time, unless the permit is available.

<p>If the permit is available then it is consumed and the call
returns immediately; otherwise the current thread becomes disabled
for thread scheduling purposes and lies dormant until one of four
things happens:

<ul>
<li>Some other thread invokes {@link #unpark unpark} with the
current thread as the target; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread; or

<li>The specified waiting time elapses; or

<li>The call spuriously (that is, for no reason) returns.
</ul>

<p>This method does <em>not</em> report which of these caused the
method to return. Callers should re-check the conditions which caused
the thread to park in the first place. Callers may also determine,
for example, the interrupt status of the thread, or the elapsed time
upon return.

@param nanos the maximum number of nanoseconds to wait
"
      end

      operation 9303426 "parkUntil"
	class_operation public explicit_return_type "void"
	nparams 1
	  param in name "deadline" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Disables the current thread for thread scheduling purposes, until
the specified deadline, unless the permit is available.

<p>If the permit is available then it is consumed and the call
returns immediately; otherwise the current thread becomes disabled
for thread scheduling purposes and lies dormant until one of four
things happens:

<ul>
<li>Some other thread invokes {@link #unpark unpark} with the
current thread as the target; or

<li>Some other thread {@linkplain Thread#interrupt interrupts}
the current thread; or

<li>The specified deadline passes; or

<li>The call spuriously (that is, for no reason) returns.
</ul>

<p>This method does <em>not</em> report which of these caused the
method to return. Callers should re-check the conditions which caused
the thread to park in the first place. Callers may also determine,
for example, the interrupt status of the thread, or the current time
upon return.

@param deadline the absolute time, in milliseconds from the Epoch,
       to wait until
"
      end

      operation 9303554 "nextSecondarySeed"
	class_operation package explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the pseudo-randomly initialized or updated secondary seed.
Copied from ThreadLocalRandom due to package access restrictions.
"
      end

      attribute 2164738 "UNSAFE"
	class_attribute const_attribute private explicit_type "sun.misc.Unsafe"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Hotspot implementation via intrinsics API
"
      end

      attribute 2164866 "parkBlockerOffset"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2164994 "SEED"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2165122 "PROBE"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2165250 "SECONDARY"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      extra_member 177282 "initialization"
	
	cpp "" ""
	java "  static {
        try {
            UNSAFE = sun.misc.Unsafe.getUnsafe();
            Class<?> tk = Thread.class;
            parkBlockerOffset = UNSAFE.objectFieldOffset
                (tk.getDeclaredField(\"parkBlocker\"));
            SEED = UNSAFE.objectFieldOffset
                (tk.getDeclaredField(\"threadLocalRandomSeed\"));
            PROBE = UNSAFE.objectFieldOffset
                (tk.getDeclaredField(\"threadLocalRandomProbe\"));
            SECONDARY = UNSAFE.objectFieldOffset
                (tk.getDeclaredField(\"threadLocalRandomSecondarySeed\"));
        } catch (Exception ex) { throw new Error(ex); }
    }"
	php ""
	python ""
	idl ""
	mysql ""
      end
    end

    class 1131010 "ReadWriteLock"
      visibility public stereotype "interface"
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}interface ${name}${extends} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A {@code ReadWriteLock} maintains a pair of associated {@link
Lock locks}, one for read-only operations and one for writing.
The {@link #readLock read lock} may be held simultaneously by
multiple reader threads, so long as there are no writers.  The
{@link #writeLock write lock} is exclusive.

<p>All {@code ReadWriteLock} implementations must guarantee that
the memory synchronization effects of {@code writeLock} operations
(as specified in the {@link Lock} interface) also hold with respect
to the associated {@code readLock}. That is, a thread successfully
acquiring the read lock will see all updates made upon previous
release of the write lock.

<p>A read-write lock allows for a greater level of concurrency in
accessing shared data than that permitted by a mutual exclusion lock.
It exploits the fact that while only a single thread at a time (a
<em>writer</em> thread) can modify the shared data, in many cases any
number of threads can concurrently read the data (hence <em>reader</em>
threads).
In theory, the increase in concurrency permitted by the use of a read-write
lock will lead to performance improvements over the use of a mutual
exclusion lock. In practice this increase in concurrency will only be fully
realized on a multi-processor, and then only if the access patterns for
the shared data are suitable.

<p>Whether or not a read-write lock will improve performance over the use
of a mutual exclusion lock depends on the frequency that the data is
read compared to being modified, the duration of the read and write
operations, and the contention for the data - that is, the number of
threads that will try to read or write the data at the same time.
For example, a collection that is initially populated with data and
thereafter infrequently modified, while being frequently searched
(such as a directory of some kind) is an ideal candidate for the use of
a read-write lock. However, if updates become frequent then the data
spends most of its time being exclusively locked and there is little, if any
increase in concurrency. Further, if the read operations are too short
the overhead of the read-write lock implementation (which is inherently
more complex than a mutual exclusion lock) can dominate the execution
cost, particularly as many read-write lock implementations still serialize
all threads through a small section of code. Ultimately, only profiling
and measurement will establish whether the use of a read-write lock is
suitable for your application.


<p>Although the basic operation of a read-write lock is straight-forward,
there are many policy decisions that an implementation must make, which
may affect the effectiveness of the read-write lock in a given application.
Examples of these policies include:
<ul>
<li>Determining whether to grant the read lock or the write lock, when
both readers and writers are waiting, at the time that a writer releases
the write lock. Writer preference is common, as writes are expected to be
short and infrequent. Reader preference is less common as it can lead to
lengthy delays for a write if the readers are frequent and long-lived as
expected. Fair, or &quot;in-order&quot; implementations are also possible.

<li>Determining whether readers that request the read lock while a
reader is active and a writer is waiting, are granted the read lock.
Preference to the reader can delay the writer indefinitely, while
preference to the writer can reduce the potential for concurrency.

<li>Determining whether the locks are reentrant: can a thread with the
write lock reacquire it? Can it acquire a read lock while holding the
write lock? Is the read lock itself reentrant?

<li>Can the write lock be downgraded to a read lock without allowing
an intervening writer? Can a read lock be upgraded to a write lock,
in preference to other waiting readers or writers?

</ul>
You should consider all of these things when evaluating the suitability
of a given implementation for your application.

@see ReentrantReadWriteLock
@see Lock
@see ReentrantLock

@since 1.5
@author Doug Lea
"
      operation 9303682 "readLock"
	public return_type class_ref 864642 // Lock
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the lock used for reading.

@return the lock used for reading
"
      end

      operation 9303810 "writeLock"
	public return_type class_ref 864642 // Lock
	nparams 0
	
	java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns the lock used for writing.

@return the lock used for writing
"
      end
    end

    class 1132034 "StampedLock"
      visibility public 
      cpp_decl ""
      java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment "A capability-based lock with three modes for controlling read/write
access.  The state of a StampedLock consists of a version and mode.
Lock acquisition methods return a stamp that represents and
controls access with respect to a lock state; \"try\" versions of
these methods may instead return the special value zero to
represent failure to acquire access. Lock release and conversion
methods require stamps as arguments, and fail if they do not match
the state of the lock. The three modes are:

<ul>

 <li><b>Writing.</b> Method {@link #writeLock} possibly blocks
  waiting for exclusive access, returning a stamp that can be used
  in method {@link #unlockWrite} to release the lock. Untimed and
  timed versions of {@code tryWriteLock} are also provided. When
  the lock is held in write mode, no read locks may be obtained,
  and all optimistic read validations will fail.  </li>

 <li><b>Reading.</b> Method {@link #readLock} possibly blocks
  waiting for non-exclusive access, returning a stamp that can be
  used in method {@link #unlockRead} to release the lock. Untimed
  and timed versions of {@code tryReadLock} are also provided. </li>

 <li><b>Optimistic Reading.</b> Method {@link #tryOptimisticRead}
  returns a non-zero stamp only if the lock is not currently held
  in write mode. Method {@link #validate} returns true if the lock
  has not been acquired in write mode since obtaining a given
  stamp.  This mode can be thought of as an extremely weak version
  of a read-lock, that can be broken by a writer at any time.  The
  use of optimistic mode for short read-only code segments often
  reduces contention and improves throughput.  However, its use is
  inherently fragile.  Optimistic read sections should only read
  fields and hold them in local variables for later use after
  validation. Fields read while in optimistic mode may be wildly
  inconsistent, so usage applies only when you are familiar enough
  with data representations to check consistency and/or repeatedly
  invoke method {@code validate()}.  For example, such steps are
  typically required when first reading an object or array
  reference, and then accessing one of its fields, elements or
  methods. </li>

</ul>

<p>This class also supports methods that conditionally provide
conversions across the three modes. For example, method {@link
#tryConvertToWriteLock} attempts to \"upgrade\" a mode, returning
a valid write stamp if (1) already in writing mode (2) in reading
mode and there are no other readers or (3) in optimistic mode and
the lock is available. The forms of these methods are designed to
help reduce some of the code bloat that otherwise occurs in
retry-based designs.

<p>StampedLocks are designed for use as internal utilities in the
development of thread-safe components. Their use relies on
knowledge of the internal properties of the data, objects, and
methods they are protecting.  They are not reentrant, so locked
bodies should not call other unknown methods that may try to
re-acquire locks (although you may pass a stamp to other methods
that can use or convert it).  The use of read lock modes relies on
the associated code sections being side-effect-free.  Unvalidated
optimistic read sections cannot call methods that are not known to
tolerate potential inconsistencies.  Stamps use finite
representations, and are not cryptographically secure (i.e., a
valid stamp may be guessable). Stamp values may recycle after (no
sooner than) one year of continuous operation. A stamp held without
use or validation for longer than this period may fail to validate
correctly.  StampedLocks are serializable, but always deserialize
into initial unlocked state, so they are not useful for remote
locking.

<p>The scheduling policy of StampedLock does not consistently
prefer readers over writers or vice versa.  All \"try\" methods are
best-effort and do not necessarily conform to any scheduling or
fairness policy. A zero return from any \"try\" method for acquiring
or converting locks does not carry any information about the state
of the lock; a subsequent invocation may succeed.

<p>Because it supports coordinated usage across multiple lock
modes, this class does not directly implement the {@link Lock} or
{@link ReadWriteLock} interfaces. However, a StampedLock may be
viewed {@link #asReadLock()}, {@link #asWriteLock()}, or {@link
#asReadWriteLock()} in applications requiring only the associated
set of functionality.

<p><b>Sample Usage.</b> The following illustrates some usage idioms
in a class that maintains simple two-dimensional points. The sample
code illustrates some try/catch conventions even though they are
not strictly needed here because no exceptions can occur in their
bodies.<br>

 <pre>{@code
class Point {
  private double x, y;
  private final StampedLock sl = new StampedLock();

  void move(double deltaX, double deltaY) { // an exclusively locked method
    long stamp = sl.writeLock();
    try {
      x += deltaX;
      y += deltaY;
    } finally {
      sl.unlockWrite(stamp);
    }
  }

  double distanceFromOrigin() { // A read-only method
    long stamp = sl.tryOptimisticRead();
    double currentX = x, currentY = y;
    if (!sl.validate(stamp)) {
       stamp = sl.readLock();
       try {
         currentX = x;
         currentY = y;
       } finally {
          sl.unlockRead(stamp);
       }
    }
    return Math.sqrt(currentX * currentX + currentY * currentY);
  }

  void moveIfAtOrigin(double newX, double newY) { // upgrade
    // Could instead start with optimistic, not read mode
    long stamp = sl.readLock();
    try {
      while (x == 0.0 && y == 0.0) {
        long ws = sl.tryConvertToWriteLock(stamp);
        if (ws != 0L) {
          stamp = ws;
          x = newX;
          y = newY;
          break;
        }
        else {
          sl.unlockRead(stamp);
          stamp = sl.writeLock();
        }
      }
    } finally {
      sl.unlock(stamp);
    }
  }
}}</pre>

@since 1.8
@author Doug Lea
"
      classrelation 3652226 // <realization>
	relation 3652226 -_-|>
	  a public
	    java "${type}"
	    classrelation_ref 3652226 // <realization>
	  b parent class_ref 136578 // Serializable
      end

      attribute 2167298 "serialVersionUID"
	class_attribute const_attribute private explicit_type "long"
	init_value " -6001602636862214147L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment "Algorithmic notes:

The design employs elements of Sequence locks
(as used in linux kernels; see Lameter's
http://www.lameter.com/gelato2005.pdf
and elsewhere; see
Boehm's http://www.hpl.hp.com/techreports/2012/HPL-2012-68.html)
and Ordered RW locks (see Shirako et al
http://dl.acm.org/citation.cfm?id=2312015)

Conceptually, the primary state of the lock includes a sequence
number that is odd when write-locked and even otherwise.
However, this is offset by a reader count that is non-zero when
read-locked.  The read count is ignored when validating
\"optimistic\" seqlock-reader-style stamps.  Because we must use
a small finite number of bits (currently 7) for readers, a
supplementary reader overflow word is used when the number of
readers exceeds the count field. We do this by treating the max
reader count value (RBITS) as a spinlock protecting overflow
updates.

Waiters use a modified form of CLH lock used in
AbstractQueuedSynchronizer (see its internal documentation for
a fuller account), where each node is tagged (field mode) as
either a reader or writer. Sets of waiting readers are grouped
(linked) under a common node (field cowait) so act as a single
node with respect to most CLH mechanics.  By virtue of the
queue structure, wait nodes need not actually carry sequence
numbers; we know each is greater than its predecessor.  This
simplifies the scheduling policy to a mainly-FIFO scheme that
incorporates elements of Phase-Fair locks (see Brandenburg &
Anderson, especially http://www.cs.unc.edu/~bbb/diss/).  In
particular, we use the phase-fair anti-barging rule: If an
incoming reader arrives while read lock is held but there is a
queued writer, this incoming reader is queued.  (This rule is
responsible for some of the complexity of method acquireRead,
but without it, the lock becomes highly unfair.) Method release
does not (and sometimes cannot) itself wake up cowaiters. This
is done by the primary thread, but helped by any other threads
with nothing better to do in methods acquireRead and
acquireWrite.

These rules apply to threads actually queued. All tryLock forms
opportunistically try to acquire locks regardless of preference
rules, and so may \"barge\" their way in.  Randomized spinning is
used in the acquire methods to reduce (increasingly expensive)
context switching while also avoiding sustained memory
thrashing among many threads.  We limit spins to the head of
queue. A thread spin-waits up to SPINS times (where each
iteration decreases spin count with 50% probability) before
blocking. If, upon wakening it fails to obtain lock, and is
still (or becomes) the first waiting thread (which indicates
that some other thread barged and obtained lock), it escalates
spins (up to MAX_HEAD_SPINS) to reduce the likelihood of
continually losing to barging threads.

Nearly all of these mechanics are carried out in methods
acquireWrite and acquireRead, that, as typical of such code,
sprawl out because actions and retries rely on consistent sets
of locally cached reads.

As noted in Boehm's paper (above), sequence validation (mainly
method validate()) requires stricter ordering rules than apply
to normal volatile reads (of \"state\").  To force orderings of
reads before a validation and the validation itself in those
cases where this is not already forced, we use
Unsafe.loadFence.

The memory layout keeps lock state and queue pointers together
(normally on the same cache line). This usually works well for
read-mostly loads. In most other cases, the natural tendency of
adaptive-spin CLH locks to reduce memory contention lessens
motivation to further spread out contended locations, but might
be subject to future improvements.

"
      end

      attribute 2167426 "NCPU"
	class_attribute const_attribute private explicit_type "int"
	init_value " Runtime.getRuntime().availableProcessors()"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Number of processors, for spin control 
"
      end

      attribute 2167554 "SPINS"
	class_attribute const_attribute private explicit_type "int"
	init_value " (NCPU > 1) ? 1 << 6 : 0"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Maximum number of retries before enqueuing on acquisition 
"
      end

      attribute 2167682 "HEAD_SPINS"
	class_attribute const_attribute private explicit_type "int"
	init_value " (NCPU > 1) ? 1 << 10 : 0"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Maximum number of retries before blocking at head on acquisition 
"
      end

      attribute 2167810 "MAX_HEAD_SPINS"
	class_attribute const_attribute private explicit_type "int"
	init_value " (NCPU > 1) ? 1 << 16 : 0"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Maximum number of retries before re-blocking 
"
      end

      attribute 2167938 "OVERFLOW_YIELD_RATE"
	class_attribute const_attribute private explicit_type "int"
	init_value " 7"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " The period for yielding when waiting for overflow spinlock 
 must be power 2 - 1"
      end

      attribute 2168066 "LG_READERS"
	class_attribute const_attribute private explicit_type "int"
	init_value " 7"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " The number of bits to use for reader count before overflowing 
"
      end

      attribute 2168194 "RUNIT"
	class_attribute const_attribute private explicit_type "long"
	init_value " 1L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Values for lock state and stamp operations
"
      end

      attribute 2168322 "WBIT"
	class_attribute const_attribute private explicit_type "long"
	init_value " 1L << LG_READERS"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2168450 "RBITS"
	class_attribute const_attribute private explicit_type "long"
	init_value " WBIT - 1L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2168578 "RFULL"
	class_attribute const_attribute private explicit_type "long"
	init_value " RBITS - 1L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2168706 "ABITS"
	class_attribute const_attribute private explicit_type "long"
	init_value " RBITS | WBIT"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2168834 "SBITS"
	class_attribute const_attribute private explicit_type "long"
	init_value " ~RBITS"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " note overlap with ABITS"
      end

      attribute 2168962 "ORIGIN"
	class_attribute const_attribute private explicit_type "long"
	init_value " WBIT << 1"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Initial value for lock state; avoid failure value zero
"
      end

      attribute 2169090 "INTERRUPTED"
	class_attribute const_attribute private explicit_type "long"
	init_value " 1L"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Special value from cancelled acquire methods so caller can throw IE
"
      end

      attribute 2169218 "WAITING"
	class_attribute const_attribute private explicit_type "int"
	init_value " -1"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Values for node status; order matters
"
      end

      attribute 2169346 "CANCELLED"
	class_attribute const_attribute private explicit_type "int"
	init_value "  1"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2169474 "RMODE"
	class_attribute const_attribute private explicit_type "int"
	init_value " 0"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Modes for nodes (int not boolean to allow arithmetic)
"
      end

      attribute 2169602 "WMODE"
	class_attribute const_attribute private explicit_type "int"
	init_value " 1"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      class 1132162 "WNode"
	visibility package 
	cpp_decl ""
	final static java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3652354 // prev (<unidirectional association>)
	  relation 3652354 --->
	    a role_name "prev" volatile package
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3652354 // prev (<unidirectional association>)
	    b parent class_ref 1132162 // WNode
	end

	classrelation 3652482 // next (<unidirectional association>)
	  relation 3652482 --->
	    a role_name "next" volatile package
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3652482 // next (<unidirectional association>)
	    b parent class_ref 1132162 // WNode
	end

	classrelation 3652610 // cowait (<unidirectional association>)
	  relation 3652610 --->
	    a role_name "cowait" volatile package
	      comment " list of linked readers"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3652610 // cowait (<unidirectional association>)
	    b parent class_ref 1132162 // WNode
	end

	classrelation 3652738 // thread (<unidirectional association>)
	  relation 3652738 --->
	    a role_name "thread" volatile package
	      comment " non-null while possibly parked"
	      java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	      classrelation_ref 3652738 // thread (<unidirectional association>)
	    b parent class_ref 128642 // Thread
	end

	attribute 2169730 "status"
	  volatile package explicit_type "int"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment " 0, WAITING, or CANCELLED"
	end

	attribute 2169858 "mode"
	  const_attribute package explicit_type "int"
	  cpp_decl ""
	  java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	  mysql_decl ""
	  MysqlColumn
	  comment " RMODE or WMODE"
	end

	operation 9312514 "WNode"
	  package explicit_return_type ""
	  nparams 2
	    param in name "m" explicit_type "int"
	    param inout name "p" type class_ref 1132162 // WNode
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      classrelation 3652866 // whead (<unidirectional association>)
	relation 3652866 --->
	  a role_name "whead" volatile private
	    comment " Head of CLH queue 
"
	    transient
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 3652866 // whead (<unidirectional association>)
	  b parent class_ref 1132162 // WNode
      end

      classrelation 3652994 // wtail (<unidirectional association>)
	relation 3652994 --->
	  a role_name "wtail" volatile private
	    comment " Tail (last) of CLH queue 
"
	    transient
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 3652994 // wtail (<unidirectional association>)
	  b parent class_ref 1132162 // WNode
      end

      class 1132290 "ReadLockView"
	visibility package 
	cpp_decl ""
	final java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3653506 // <realization>
	  relation 3653506 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 3653506 // <realization>
	    b parent class_ref 864642 // Lock
	end

	operation 9316098 "lock"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9316226 "lockInterruptibly"
	  public explicit_return_type "void"
	  nparams 0
	  nexceptions 1
	    exception class_ref 129666 // InterruptedException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9316354 "tryLock"
	  public explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9316482 "tryLock"
	  public explicit_return_type "boolean"
	  nparams 2
	    param in name "time" explicit_type "long"
	    param inout name "unit" type class_ref 935938 // TimeUnit
	  nexceptions 1
	    exception class_ref 129666 // InterruptedException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9316610 "unlock"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9316738 "newCondition"
	  public return_type class_ref 864770 // Condition
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      classrelation 3653122 // readLockView (<unidirectional association>)
	relation 3653122 --->
	  a role_name "readLockView" package
	    comment " views
"
	    transient
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 3653122 // readLockView (<unidirectional association>)
	  b parent class_ref 1132290 // ReadLockView
      end

      class 1132418 "WriteLockView"
	visibility package 
	cpp_decl ""
	final java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3653634 // <realization>
	  relation 3653634 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 3653634 // <realization>
	    b parent class_ref 864642 // Lock
	end

	operation 9316866 "lock"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9316994 "lockInterruptibly"
	  public explicit_return_type "void"
	  nparams 0
	  nexceptions 1
	    exception class_ref 129666 // InterruptedException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9317122 "tryLock"
	  public explicit_return_type "boolean"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9317250 "tryLock"
	  public explicit_return_type "boolean"
	  nparams 2
	    param in name "time" explicit_type "long"
	    param inout name "unit" type class_ref 935938 // TimeUnit
	  nexceptions 1
	    exception class_ref 129666 // InterruptedException
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9317378 "unlock"
	  public explicit_return_type "void"
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9317506 "newCondition"
	  public return_type class_ref 864770 // Condition
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      classrelation 3653250 // writeLockView (<unidirectional association>)
	relation 3653250 --->
	  a role_name "writeLockView" package
	    transient
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 3653250 // writeLockView (<unidirectional association>)
	  b parent class_ref 1132418 // WriteLockView
      end

      class 1132546 "ReadWriteLockView"
	visibility package 
	cpp_decl ""
	final java_decl "${comment}${@}${visibility}${static}${final}${abstract}class ${name}${extends}${implements} {
${members}}
"
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	mysql_decl ""
	
	classrelation 3653762 // <realization>
	  relation 3653762 -_-|>
	    a public
	      java "${type}"
	      classrelation_ref 3653762 // <realization>
	    b parent class_ref 1131010 // ReadWriteLock
	end

	operation 9317634 "readLock"
	  public return_type class_ref 864642 // Lock
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end

	operation 9317762 "writeLock"
	  public return_type class_ref 864642 // Lock
	  nparams 0
	  
	  preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	  
	  
	  
	end
      end

      classrelation 3653378 // readWriteLockView (<unidirectional association>)
	relation 3653378 --->
	  a role_name "readWriteLockView" package
	    transient
	    java "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	    classrelation_ref 3653378 // readWriteLockView (<unidirectional association>)
	  b parent class_ref 1132546 // ReadWriteLockView
      end

      attribute 2169986 "state"
	volatile private explicit_type "long"
	cpp_decl ""
	transient java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Lock sequence/state 
"
      end

      attribute 2170114 "readerOverflow"
	private explicit_type "int"
	cpp_decl ""
	transient java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " extra reader count when state read count saturated 
"
      end

      operation 9312642 "StampedLock"
	public explicit_return_type ""
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${synchronized}${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Creates a new lock, initially in unlocked state.
"
      end

      operation 9312770 "writeLock"
	public explicit_return_type "long"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Exclusively acquires the lock, blocking if necessary
until available.

@return a stamp that can be used to unlock or convert mode
"
      end

      operation 9312898 "tryWriteLock"
	public explicit_return_type "long"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Exclusively acquires the lock if it is immediately available.

@return a stamp that can be used to unlock or convert mode,
or zero if the lock is not available
"
      end

      operation 9313026 "tryWriteLock"
	public explicit_return_type "long"
	nparams 2
	  param in name "time" explicit_type "long"
	  param inout name "unit" type class_ref 935938 // TimeUnit
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Exclusively acquires the lock if it is available within the
given time and the current thread has not been interrupted.
Behavior under timeout and interruption matches that specified
for method {@link Lock#tryLock(long,TimeUnit)}.

@param time the maximum time to wait for the lock
@param unit the time unit of the {@code time} argument
@return a stamp that can be used to unlock or convert mode,
or zero if the lock is not available
@throws InterruptedException if the current thread is interrupted
before acquiring the lock
"
      end

      operation 9313154 "writeLockInterruptibly"
	public explicit_return_type "long"
	nparams 0
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Exclusively acquires the lock, blocking if necessary
until available or the current thread is interrupted.
Behavior under interruption matches that specified
for method {@link Lock#lockInterruptibly()}.

@return a stamp that can be used to unlock or convert mode
@throws InterruptedException if the current thread is interrupted
before acquiring the lock
"
      end

      operation 9313282 "readLock"
	public explicit_return_type "long"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Non-exclusively acquires the lock, blocking if necessary
until available.

@return a stamp that can be used to unlock or convert mode
"
      end

      operation 9313410 "tryReadLock"
	public explicit_return_type "long"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Non-exclusively acquires the lock if it is immediately available.

@return a stamp that can be used to unlock or convert mode,
or zero if the lock is not available
"
      end

      operation 9313538 "tryReadLock"
	public explicit_return_type "long"
	nparams 2
	  param in name "time" explicit_type "long"
	  param inout name "unit" type class_ref 935938 // TimeUnit
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Non-exclusively acquires the lock if it is available within the
given time and the current thread has not been interrupted.
Behavior under timeout and interruption matches that specified
for method {@link Lock#tryLock(long,TimeUnit)}.

@param time the maximum time to wait for the lock
@param unit the time unit of the {@code time} argument
@return a stamp that can be used to unlock or convert mode,
or zero if the lock is not available
@throws InterruptedException if the current thread is interrupted
before acquiring the lock
"
      end

      operation 9313666 "readLockInterruptibly"
	public explicit_return_type "long"
	nparams 0
	nexceptions 1
	  exception class_ref 129666 // InterruptedException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Non-exclusively acquires the lock, blocking if necessary
until available or the current thread is interrupted.
Behavior under interruption matches that specified
for method {@link Lock#lockInterruptibly()}.

@return a stamp that can be used to unlock or convert mode
@throws InterruptedException if the current thread is interrupted
before acquiring the lock
"
      end

      operation 9313794 "tryOptimisticRead"
	public explicit_return_type "long"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a stamp that can later be validated, or zero
if exclusively locked.

@return a stamp, or zero if exclusively locked
"
      end

      operation 9313922 "validate"
	public explicit_return_type "boolean"
	nparams 1
	  param in name "stamp" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns true if the lock has not been exclusively acquired
since issuance of the given stamp. Always returns false if the
stamp is zero. Always returns true if the stamp represents a
currently held lock. Invoking this method with a value not
obtained from {@link #tryOptimisticRead} or a locking method
for this lock has no defined effect or result.

@param stamp a stamp
@return {@code true} if the lock has not been exclusively acquired
since issuance of the given stamp; else false
"
      end

      operation 9314050 "unlockWrite"
	public explicit_return_type "void"
	nparams 1
	  param in name "stamp" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "If the lock state matches the given stamp, releases the
exclusive lock.

@param stamp a stamp returned by a write-lock operation
@throws IllegalMonitorStateException if the stamp does
not match the current state of this lock
"
      end

      operation 9314178 "unlockRead"
	public explicit_return_type "void"
	nparams 1
	  param in name "stamp" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "If the lock state matches the given stamp, releases the
non-exclusive lock.

@param stamp a stamp returned by a read-lock operation
@throws IllegalMonitorStateException if the stamp does
not match the current state of this lock
"
      end

      operation 9314306 "unlock"
	public explicit_return_type "void"
	nparams 1
	  param in name "stamp" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "If the lock state matches the given stamp, releases the
corresponding mode of the lock.

@param stamp a stamp returned by a lock operation
@throws IllegalMonitorStateException if the stamp does
not match the current state of this lock
"
      end

      operation 9314434 "tryConvertToWriteLock"
	public explicit_return_type "long"
	nparams 1
	  param in name "stamp" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "If the lock state matches the given stamp, performs one of
the following actions. If the stamp represents holding a write
lock, returns it.  Or, if a read lock, if the write lock is
available, releases the read lock and returns a write stamp.
Or, if an optimistic read, returns a write stamp only if
immediately available. This method returns zero in all other
cases.

@param stamp a stamp
@return a valid write stamp, or zero on failure
"
      end

      operation 9314562 "tryConvertToReadLock"
	public explicit_return_type "long"
	nparams 1
	  param in name "stamp" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "If the lock state matches the given stamp, performs one of
the following actions. If the stamp represents holding a write
lock, releases it and obtains a read lock.  Or, if a read lock,
returns it. Or, if an optimistic read, acquires a read lock and
returns a read stamp only if immediately available. This method
returns zero in all other cases.

@param stamp a stamp
@return a valid read stamp, or zero on failure
"
      end

      operation 9314690 "tryConvertToOptimisticRead"
	public explicit_return_type "long"
	nparams 1
	  param in name "stamp" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "If the lock state matches the given stamp then, if the stamp
represents holding a lock, releases it and returns an
observation stamp.  Or, if an optimistic read, returns it if
validated. This method returns zero in all other cases, and so
may be useful as a form of \"tryUnlock\".

@param stamp a stamp
@return a valid optimistic read stamp, or zero on failure
"
      end

      operation 9314818 "tryUnlockWrite"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Releases the write lock if it is held, without requiring a
stamp value. This method may be useful for recovery after
errors.

@return {@code true} if the lock was held, else false
"
      end

      operation 9314946 "tryUnlockRead"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Releases one hold of the read lock if it is held, without
requiring a stamp value. This method may be useful for recovery
after errors.

@return {@code true} if the read lock was held, else false
"
      end

      operation 9315074 "getReadLockCount"
	private explicit_return_type "int"
	nparams 1
	  param in name "s" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " status monitoring methods

Returns combined state-held and overflow read count for given
state s.
"
      end

      operation 9315202 "isWriteLocked"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns {@code true} if the lock is currently held exclusively.

@return {@code true} if the lock is currently held exclusively
"
      end

      operation 9315330 "isReadLocked"
	public explicit_return_type "boolean"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns {@code true} if the lock is currently held non-exclusively.

@return {@code true} if the lock is currently held non-exclusively
"
      end

      operation 9315458 "getReadLockCount"
	public explicit_return_type "int"
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Queries the number of read locks held for this lock. This
method is designed for use in monitoring system state, not for
synchronization control.
@return the number of read locks held
"
      end

      operation 9315586 "toString"
	public return_type class_ref 128130 // String
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a string identifying this lock, as well as its lock
state.  The state, in brackets, includes the String {@code
\"Unlocked\"} or the String {@code \"Write-locked\"} or the String
{@code \"Read-locks:\"} followed by the current number of
read-locks held.

@return a string identifying this lock, as well as its lock state
"
      end

      operation 9315714 "asReadLock"
	public return_type class_ref 864642 // Lock
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " views

Returns a plain {@link Lock} view of this StampedLock in which
the {@link Lock#lock} method is mapped to {@link #readLock},
and similarly for other methods. The returned Lock does not
support a {@link Condition}; method {@link
Lock#newCondition()} throws {@code
UnsupportedOperationException}.

@return the lock
"
      end

      operation 9315842 "asWriteLock"
	public return_type class_ref 864642 // Lock
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a plain {@link Lock} view of this StampedLock in which
the {@link Lock#lock} method is mapped to {@link #writeLock},
and similarly for other methods. The returned Lock does not
support a {@link Condition}; method {@link
Lock#newCondition()} throws {@code
UnsupportedOperationException}.

@return the lock
"
      end

      operation 9315970 "asReadWriteLock"
	public return_type class_ref 1131010 // ReadWriteLock
	nparams 0
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Returns a {@link ReadWriteLock} view of this StampedLock in
which the {@link ReadWriteLock#readLock()} method is mapped to
{@link #asReadLock()}, and {@link ReadWriteLock#writeLock()} to
{@link #asWriteLock()}.

@return the lock
"
      end

      operation 9317890 "unstampedUnlockWrite"
	package explicit_return_type "void"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " Unlock methods without stamp argument checks for view classes.
 Needed because view-class lock methods throw away stamps."
      end

      operation 9318018 "unstampedUnlockRead"
	package explicit_return_type "void"
	nparams 0
	
	preserve_java_body_indent final java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 9318146 "readObject"
	private explicit_return_type "void"
	nparams 1
	  param inout name "s" type class_ref 168962 // ObjectInputStream
	nexceptions 2
	  exception class_ref 146818 // IOException
	  exception class_ref 169730 // ClassNotFoundException
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
      end

      operation 9318274 "tryIncReaderOverflow"
	private explicit_return_type "long"
	nparams 1
	  param in name "s" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment " internals

Tries to increment readerOverflow by first setting state
access bits value to RBITS, indicating hold of spinlock,
then updating, then releasing.

@param s a reader overflow stamp: (s & ABITS) >= RFULL
@return new stamp on success, else zero
"
      end

      operation 9318402 "tryDecReaderOverflow"
	private explicit_return_type "long"
	nparams 1
	  param in name "s" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Tries to decrement readerOverflow.

@param s a reader overflow stamp: (s & ABITS) >= RFULL
@return new stamp on success, else zero
"
      end

      operation 9318530 "release"
	private explicit_return_type "void"
	nparams 1
	  param inout name "h" type class_ref 1132162 // WNode
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "Wakes up the successor of h (normally whead). This is normally
just h.next, but may require traversal from wtail if next
pointers are lagging. This may fail to wake up an acquiring
thread when one or more have been cancelled, but the cancel
methods themselves provide extra safeguards to ensure liveness.
"
      end

      operation 9318658 "acquireWrite"
	private explicit_return_type "long"
	nparams 2
	  param inout name "interruptible" explicit_type "boolean"
	  param in name "deadline" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "See above for explanation.

@param interruptible true if should check interrupts and if so
return INTERRUPTED
@param deadline if nonzero, the System.nanoTime value to timeout
at (and return zero)
@return next state, or INTERRUPTED
"
      end

      operation 9318786 "acquireRead"
	private explicit_return_type "long"
	nparams 2
	  param inout name "interruptible" explicit_type "boolean"
	  param in name "deadline" explicit_type "long"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "See above for explanation.

@param interruptible true if should check interrupts and if so
return INTERRUPTED
@param deadline if nonzero, the System.nanoTime value to timeout
at (and return zero)
@return next state, or INTERRUPTED
"
      end

      operation 9318914 "cancelWaiter"
	private explicit_return_type "long"
	nparams 3
	  param inout name "node" type class_ref 1132162 // WNode
	  param inout name "group" type class_ref 1132162 // WNode
	  param inout name "interrupted" explicit_type "boolean"
	
	preserve_java_body_indent java_def "  ${comment}${@}${visibility}${final}${static}${abstract}${synchronized}${type} ${name}${(}${t0} ${p0}, ${t1} ${p1}, ${t2} ${p2}${)}${throws}${staticnl}{
  ${body}}
"
	
	
	
	comment "If node non-null, forces cancel status and unsplices it from
queue if possible and wakes up any cowaiters (of the node, or
group, as applicable), and in any case helps release current
first waiter if lock is free. (Calling with null arguments
serves as a conditional form of release, which is not currently
needed but may be needed under possible future cancellation
policies). This is a variant of cancellation methods in
AbstractQueuedSynchronizer (see its detailed explanation in AQS
internal documentation).

@param node if nonnull, the waiter
@param group either node or the group node is cowaiting with
@param interrupted if already interrupted
@return INTERRUPTED if interrupted or Thread.interrupted, else zero
"
      end

      attribute 2170242 "U"
	class_attribute const_attribute private explicit_type "sun.misc.Unsafe"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Unsafe mechanics
"
      end

      attribute 2170370 "STATE"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2170498 "WHEAD"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2170626 "WTAIL"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2170754 "WNEXT"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2170882 "WSTATUS"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2171010 "WCOWAIT"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 2171138 "PARKBLOCKER"
	class_attribute const_attribute private explicit_type "long"
	cpp_decl ""
	java_decl "  ${comment}${@}${visibility}${static}${final}${transient}${volatile}${type} ${name}${value};
"
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      extra_member 177538 "initialization"
	
	cpp "" ""
	java "  static {
        try {
            U = sun.misc.Unsafe.getUnsafe();
            Class<?> k = StampedLock.class;
            Class<?> wk = WNode.class;
            STATE = U.objectFieldOffset
                (k.getDeclaredField(\"state\"));
            WHEAD = U.objectFieldOffset
                (k.getDeclaredField(\"whead\"));
            WTAIL = U.objectFieldOffset
                (k.getDeclaredField(\"wtail\"));
            WSTATUS = U.objectFieldOffset
                (wk.getDeclaredField(\"status\"));
            WNEXT = U.objectFieldOffset
                (wk.getDeclaredField(\"next\"));
            WCOWAIT = U.objectFieldOffset
                (wk.getDeclaredField(\"cowait\"));
            Class<?> tk = Thread.class;
            PARKBLOCKER = U.objectFieldOffset
                (tk.getDeclaredField(\"parkBlocker\"));

        } catch (Exception e) {
            throw new Error(e);
        }
    }"
	php ""
	python ""
	idl ""
	mysql ""
      end
    end
  end

  deploymentview 170754 "locks"
    //deployment diagram settings
    deploymentdiagramsettings
     end
    artifact 805506 "Lock"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.util.concurrent.TimeUnit;
${definition}"
      associated_elems
	class_ref 864642 // Lock
      end
      comment "ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.



























Written by Doug Lea with assistance from members of JCP JSR-166
Expert Group and released to the public domain, as explained at
http://creativecommons.org/publicdomain/zero/1.0/
"
    end

    artifact 805634 "AbstractOwnableSynchronizer"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 1106178 // AbstractOwnableSynchronizer
      end
      comment "ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.



























Written by Doug Lea with assistance from members of JCP JSR-166
Expert Group and released to the public domain, as explained at
http://creativecommons.org/publicdomain/zero/1.0/
"
    end

    artifact 805762 "Condition"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.util.concurrent.TimeUnit;
import java.util.Date;
${definition}"
      associated_elems
	class_ref 864770 // Condition
      end
      comment "ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.



























Written by Doug Lea with assistance from members of JCP JSR-166
Expert Group and released to the public domain, as explained at
http://creativecommons.org/publicdomain/zero/1.0/
"
    end

    artifact 805890 "AbstractQueuedSynchronizer"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.util.concurrent.TimeUnit;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import sun.misc.Unsafe;
${definition}"
      associated_elems
	class_ref 1106050 // AbstractQueuedSynchronizer
      end
      comment "ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.



























Written by Doug Lea with assistance from members of JCP JSR-166
Expert Group and released to the public domain, as explained at
http://creativecommons.org/publicdomain/zero/1.0/
"
    end

    artifact 806018 "ReentrantLock"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.util.concurrent.TimeUnit;
import java.util.Collection;
${definition}"
      associated_elems
	class_ref 968706 // ReentrantLock
      end
      comment "ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.



























Written by Doug Lea with assistance from members of JCP JSR-166
Expert Group and released to the public domain, as explained at
http://creativecommons.org/publicdomain/zero/1.0/
"
    end

    artifact 813186 "AbstractQueuedLongSynchronizer"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.util.concurrent.TimeUnit;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import sun.misc.Unsafe;
${definition}"
      associated_elems
	class_ref 1130498 // AbstractQueuedLongSynchronizer
      end
      comment "ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.



























Written by Doug Lea with assistance from members of JCP JSR-166
Expert Group and released to the public domain, as explained at
http://creativecommons.org/publicdomain/zero/1.0/
"
    end

    artifact 813314 "LockSupport"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import sun.misc.Unsafe;
${definition}"
      associated_elems
	class_ref 1130882 // LockSupport
      end
      comment "ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.



























Written by Doug Lea with assistance from members of JCP JSR-166
Expert Group and released to the public domain, as explained at
http://creativecommons.org/publicdomain/zero/1.0/
"
    end

    artifact 813442 "ReadWriteLock"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
${definition}"
      associated_elems
	class_ref 1131010 // ReadWriteLock
      end
      comment "ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.



























Written by Doug Lea with assistance from members of JCP JSR-166
Expert Group and released to the public domain, as explained at
http://creativecommons.org/publicdomain/zero/1.0/
"
    end

    artifact 813570 "ReentrantReadWriteLock"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.util.concurrent.TimeUnit;
import java.util.Collection;
${definition}"
      associated_elems
	class_ref 489090 // ReentrantReadWriteLock
      end
      comment "ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.



























Written by Doug Lea with assistance from members of JCP JSR-166
Expert Group and released to the public domain, as explained at
http://creativecommons.org/publicdomain/zero/1.0/
"
    end

    artifact 813698 "StampedLock"
      stereotype "source"
      java_src "${comment}
${package}
${imports}
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.LockSupport;
${definition}"
      associated_elems
	class_ref 1132034 // StampedLock
      end
      comment "ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.



























Written by Doug Lea with assistance from members of JCP JSR-166
Expert Group and released to the public domain, as explained at
http://creativecommons.org/publicdomain/zero/1.0/
"
    end
  end
end
